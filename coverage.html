
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>govc: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/caiatech/govc/concurrent_fixes.go (81.8%)</option>
				
				<option value="file1">github.com/caiatech/govc/govc.go (83.3%)</option>
				
				<option value="file2">github.com/caiatech/govc/govc_v2.go (0.0%)</option>
				
				<option value="file3">github.com/caiatech/govc/parallel.go (82.8%)</option>
				
				<option value="file4">github.com/caiatech/govc/repository.go (15.7%)</option>
				
				<option value="file5">github.com/caiatech/govc/repository_v2.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package govc

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/caiatech/govc/pkg/object"
)

// ConcurrentSafeRepository wraps Repository with thread-safe operations
type ConcurrentSafeRepository struct {
        *Repository
        globalMutex    sync.RWMutex        // Global repo lock
        transactionMux sync.Mutex          // Transaction serialization
        storeMux       sync.RWMutex        // Store operations lock
        refMux         sync.RWMutex        // Reference operations lock
        branchMux      sync.RWMutex        // Branch operations lock
        initialized    int32               // Atomic flag for initialization
        corrupted      int32               // Atomic flag for corruption state
        activeOps      int64               // Active operation counter
        retryPolicy    *RetryPolicy        // Retry configuration
}

// RetryPolicy defines retry behavior for transient failures
type RetryPolicy struct {
        MaxAttempts   int
        InitialDelay  time.Duration
        BackoffFactor float64
        MaxDelay      time.Duration
}

// DefaultRetryPolicy provides sensible defaults for retry behavior
func DefaultRetryPolicy() *RetryPolicy <span class="cov8" title="1">{
        return &amp;RetryPolicy{
                MaxAttempts:   3,
                InitialDelay:  10 * time.Millisecond,
                BackoffFactor: 2.0,
                MaxDelay:      1 * time.Second,
        }
}</span>

// NewConcurrentSafeRepository creates a thread-safe wrapper around Repository
func NewConcurrentSafeRepository(repo *Repository) *ConcurrentSafeRepository <span class="cov8" title="1">{
        if repo == nil </span><span class="cov8" title="1">{
                repo = NewRepository()
        }</span>
        
        <span class="cov8" title="1">return &amp;ConcurrentSafeRepository{
                Repository:  repo,
                retryPolicy: DefaultRetryPolicy(),
        }</span>
}

// Initialize ensures the repository is properly initialized with corruption checks
func (csr *ConcurrentSafeRepository) Initialize(ctx context.Context) error <span class="cov8" title="1">{
        if !atomic.CompareAndSwapInt32(&amp;csr.initialized, 0, 1) </span><span class="cov0" title="0">{
                return nil // Already initialized
        }</span>

        <span class="cov8" title="1">csr.globalMutex.Lock()
        defer csr.globalMutex.Unlock()

        return csr.initializeUnlocked()</span>
}

// initializeUnlocked performs initialization without locking (must be called while holding globalMutex)
func (csr *ConcurrentSafeRepository) initializeUnlocked() error <span class="cov8" title="1">{
        // Validate repository state
        if err := csr.validateRepositoryState(); err != nil </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;csr.corrupted, 1)
                return fmt.Errorf("repository validation failed: %w", err)
        }</span>

        // Initialize components with error recovery
        <span class="cov8" title="1">if err := csr.initializeComponents(); err != nil </span><span class="cov0" title="0">{
                atomic.StoreInt32(&amp;csr.corrupted, 1)
                return fmt.Errorf("component initialization failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRepositoryState checks for corruption and repairs if possible
func (csr *ConcurrentSafeRepository) validateRepositoryState() error <span class="cov8" title="1">{
        // Check if store is accessible
        if csr.Repository.store == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("store is nil")
        }</span>

        // Check if ref manager is accessible
        <span class="cov8" title="1">if csr.Repository.refManager == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("refManager is nil")
        }</span>

        // Validate HEAD reference
        <span class="cov8" title="1">if _, err := csr.Repository.refManager.GetHEAD(); err != nil </span><span class="cov0" title="0">{
                // Try to repair by creating default main branch
                if err := csr.Repository.refManager.CreateBranch("main", ""); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create default main branch: %w", err)
                }</span>
                <span class="cov0" title="0">if err := csr.Repository.refManager.SetHEADToBranch("main"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set HEAD to main: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// initializeComponents safely initializes repository components
func (csr *ConcurrentSafeRepository) initializeComponents() error <span class="cov8" title="1">{
        // Initialize staging area if needed
        if csr.Repository.staging == nil </span><span class="cov0" title="0">{
                csr.Repository.staging = NewStagingArea()
        }</span>

        // Initialize worktree if needed
        <span class="cov8" title="1">if csr.Repository.worktree == nil </span><span class="cov0" title="0">{
                csr.Repository.worktree = &amp;Worktree{
                        path:  ":memory:",
                        files: make(map[string][]byte),
                }
        }</span>

        // Initialize config if needed
        <span class="cov8" title="1">if csr.Repository.config == nil </span><span class="cov0" title="0">{
                csr.Repository.config = make(map[string]string)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SafeTransaction creates a thread-safe transactional commit
func (csr *ConcurrentSafeRepository) SafeTransaction() *ConcurrentSafeTransactionalCommit <span class="cov8" title="1">{
        return &amp;ConcurrentSafeTransactionalCommit{
                parent:      csr,
                staging:     NewStagingArea(),
                changes:     make(map[string][]byte),
                author:      object.Author{Name: "System", Email: "system@govc", Time: time.Now()},
                retryPolicy: csr.retryPolicy,
        }
}</span>

// ConcurrentSafeTransactionalCommit provides thread-safe transactional operations
type ConcurrentSafeTransactionalCommit struct {
        parent      *ConcurrentSafeRepository
        staging     *StagingArea
        message     string
        author      object.Author
        changes     map[string][]byte
        validated   bool
        committed   bool
        mu          sync.Mutex
        retryPolicy *RetryPolicy
}

// Add safely stages a file in the transaction with proper error handling
func (cstc *ConcurrentSafeTransactionalCommit) Add(path string, content []byte) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("path cannot be empty")
        }</span>
        <span class="cov8" title="1">if content == nil </span><span class="cov8" title="1">{
                content = []byte{} // Allow empty files but not nil content
        }</span>

        <span class="cov8" title="1">cstc.mu.Lock()
        defer cstc.mu.Unlock()

        if cstc.committed </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot add to committed transaction")
        }</span>

        // Check for repository corruption
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;cstc.parent.corrupted) == 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("repository is corrupted")
        }</span>

        // Increment active operations counter
        <span class="cov8" title="1">atomic.AddInt64(&amp;cstc.parent.activeOps, 1)
        defer atomic.AddInt64(&amp;cstc.parent.activeOps, -1)

        // Use retry logic for transient failures
        return cstc.withRetry(func() error </span><span class="cov8" title="1">{
                // Safely acquire store lock
                cstc.parent.storeMux.Lock()
                defer cstc.parent.storeMux.Unlock()

                // Validate store before use
                if cstc.parent.Repository.store == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("store is nil")
                }</span>

                // Store blob with error handling
                <span class="cov8" title="1">hash, err := cstc.parent.Repository.store.StoreBlob(content)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to store blob for %s: %w", path, err)
                }</span>

                // Update staging and changes atomically
                <span class="cov8" title="1">cstc.changes[path] = content
                if cstc.staging == nil </span><span class="cov0" title="0">{
                        cstc.staging = NewStagingArea()
                }</span>
                <span class="cov8" title="1">cstc.staging.Add(path, hash)

                return nil</span>
        })
}

// withRetry executes an operation with retry logic for transient failures
func (cstc *ConcurrentSafeTransactionalCommit) withRetry(operation func() error) error <span class="cov8" title="1">{
        var lastErr error
        delay := cstc.retryPolicy.InitialDelay

        for attempt := 0; attempt &lt; cstc.retryPolicy.MaxAttempts; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(delay)
                        delay = time.Duration(float64(delay) * cstc.retryPolicy.BackoffFactor)
                        if delay &gt; cstc.retryPolicy.MaxDelay </span><span class="cov0" title="0">{
                                delay = cstc.retryPolicy.MaxDelay
                        }</span>
                }

                <span class="cov8" title="1">err := operation()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                // Check if error is retryable
                if !cstc.isRetryableError(err) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("operation failed after %d attempts: %w", cstc.retryPolicy.MaxAttempts, lastErr)</span>
}

// isRetryableError determines if an error should trigger a retry
func (cstc *ConcurrentSafeTransactionalCommit) isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := err.Error()
        // Common transient errors that should be retried
        retryableErrors := []string{
                "invalid argument",
                "resource temporarily unavailable",
                "connection refused",
                "timeout",
                "temporary failure",
        }

        for _, retryable := range retryableErrors </span><span class="cov8" title="1">{
                if containsIgnoreCase(errStr, retryable) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Validate performs comprehensive validation with atomic state checking
func (cstc *ConcurrentSafeTransactionalCommit) Validate() error <span class="cov8" title="1">{
        cstc.mu.Lock()
        defer cstc.mu.Unlock()

        if cstc.committed </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction already committed")
        }</span>

        // Check repository state
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;cstc.parent.corrupted) == 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("repository is corrupted")
        }</span>

        // Validate all changes
        <span class="cov8" title="1">for path, content := range cstc.changes </span><span class="cov8" title="1">{
                if len(content) == 0 </span><span class="cov8" title="1">{
                        // Allow empty files but warn
                        continue</span>
                }
                
                // Add custom validation logic here
                <span class="cov8" title="1">if err := cstc.validateFileContent(path, content); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("validation failed for %s: %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">cstc.validated = true
        return nil</span>
}

// validateFileContent performs content-specific validation
func (cstc *ConcurrentSafeTransactionalCommit) validateFileContent(path string, content []byte) error <span class="cov8" title="1">{
        // Basic validation - can be extended based on file type
        if len(content) &gt; 100*1024*1024 </span><span class="cov8" title="1">{ // 100MB limit
                return fmt.Errorf("file too large: %d bytes", len(content))
        }</span>

        // Add more validation rules as needed
        <span class="cov8" title="1">return nil</span>
}

// Commit finalizes the transaction with full synchronization
func (cstc *ConcurrentSafeTransactionalCommit) Commit(message string) (*object.Commit, error) <span class="cov8" title="1">{
        cstc.mu.Lock()
        defer cstc.mu.Unlock()

        if cstc.committed </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("transaction already committed")
        }</span>

        <span class="cov8" title="1">if !cstc.validated </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("transaction not validated")
        }</span>

        // Check repository state
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;cstc.parent.corrupted) == 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repository is corrupted")
        }</span>

        // Use global transaction lock to serialize commits
        <span class="cov8" title="1">cstc.parent.transactionMux.Lock()
        defer cstc.parent.transactionMux.Unlock()

        // Increment active operations
        atomic.AddInt64(&amp;cstc.parent.activeOps, 1)
        defer atomic.AddInt64(&amp;cstc.parent.activeOps, -1)

        cstc.message = message
        cstc.author.Time = time.Now()

        // Perform atomic staging area swap
        var finalCommit *object.Commit
        err := cstc.withRetry(func() error </span><span class="cov8" title="1">{
                cstc.parent.globalMutex.Lock()
                defer cstc.parent.globalMutex.Unlock()

                // Validate repository components before commit
                if cstc.parent.Repository.store == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("store is nil")
                }</span>
                <span class="cov8" title="1">if cstc.parent.Repository.refManager == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("refManager is nil")
                }</span>

                // Swap staging areas atomically
                <span class="cov8" title="1">oldStaging := cstc.parent.Repository.staging
                cstc.parent.Repository.staging = cstc.staging
                
                defer func() </span><span class="cov8" title="1">{
                        // Restore old staging on error
                        if !cstc.committed </span><span class="cov0" title="0">{
                                cstc.parent.Repository.staging = oldStaging
                        }</span>
                }()

                // Perform the actual commit
                <span class="cov8" title="1">commit, commitErr := cstc.parent.Repository.Commit(message)
                if commitErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("commit failed: %w", commitErr)
                }</span>

                <span class="cov8" title="1">finalCommit = commit
                cstc.committed = true
                return nil</span>
        })
        
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return finalCommit, nil</span>
}

// Rollback discards all changes safely
func (cstc *ConcurrentSafeTransactionalCommit) Rollback() error <span class="cov8" title="1">{
        cstc.mu.Lock()
        defer cstc.mu.Unlock()

        if cstc.committed </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot rollback committed transaction")
        }</span>

        // Clear all state
        <span class="cov8" title="1">cstc.changes = make(map[string][]byte)
        cstc.staging = NewStagingArea()
        cstc.validated = false

        return nil</span>
}

// SafeCreateBranch creates a branch with proper synchronization
func (csr *ConcurrentSafeRepository) SafeCreateBranch(name, startPoint string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("branch name cannot be empty")
        }</span>

        // Check repository state
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;csr.corrupted) == 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("repository is corrupted")
        }</span>

        <span class="cov8" title="1">csr.branchMux.Lock()
        defer csr.branchMux.Unlock()

        atomic.AddInt64(&amp;csr.activeOps, 1)
        defer atomic.AddInt64(&amp;csr.activeOps, -1)

        return csr.withRetry(func() error </span><span class="cov8" title="1">{
                if csr.Repository.refManager == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("refManager is nil")
                }</span>

                <span class="cov8" title="1">return csr.Repository.refManager.CreateBranch(name, startPoint)</span>
        })
}

// SafeCheckout performs a safe branch checkout with validation
func (csr *ConcurrentSafeRepository) SafeCheckout(branch string) error <span class="cov8" title="1">{
        if branch == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("branch name cannot be empty")
        }</span>

        // Check repository state
        <span class="cov8" title="1">if atomic.LoadInt32(&amp;csr.corrupted) == 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("repository is corrupted")
        }</span>

        <span class="cov8" title="1">csr.branchMux.Lock()
        defer csr.branchMux.Unlock()

        atomic.AddInt64(&amp;csr.activeOps, 1)
        defer atomic.AddInt64(&amp;csr.activeOps, -1)

        return csr.withRetry(func() error </span><span class="cov8" title="1">{
                if csr.Repository.refManager == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("refManager is nil")
                }</span>

                <span class="cov8" title="1">return csr.Repository.Checkout(branch)</span>
        })
}

// WaitForQuiescence waits for all active operations to complete
func (csr *ConcurrentSafeRepository) WaitForQuiescence(timeout time.Duration) error <span class="cov8" title="1">{
        deadline := time.Now().Add(timeout)
        
        for time.Now().Before(deadline) </span><span class="cov8" title="1">{
                if atomic.LoadInt64(&amp;csr.activeOps) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">time.Sleep(10 * time.Millisecond)</span>
        }
        
        <span class="cov8" title="1">return fmt.Errorf("timeout waiting for operations to complete")</span>
}

// IsCorrupted returns true if the repository is in a corrupted state
func (csr *ConcurrentSafeRepository) IsCorrupted() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;csr.corrupted) == 1
}</span>

// RecoverFromCorruption attempts to recover from corruption
func (csr *ConcurrentSafeRepository) RecoverFromCorruption() error <span class="cov8" title="1">{
        csr.globalMutex.Lock()
        defer csr.globalMutex.Unlock()

        // Wait for active operations to complete
        if err := csr.WaitForQuiescence(5 * time.Second); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot recover while operations are active: %w", err)
        }</span>

        // Reset corruption flag
        <span class="cov8" title="1">atomic.StoreInt32(&amp;csr.corrupted, 0)

        // Re-initialize repository (we're already holding the lock)
        atomic.StoreInt32(&amp;csr.initialized, 0)
        return csr.initializeUnlocked()</span>
}

// withRetry provides retry logic for repository operations
func (csr *ConcurrentSafeRepository) withRetry(operation func() error) error <span class="cov8" title="1">{
        return (&amp;ConcurrentSafeTransactionalCommit{
                parent:      csr,
                retryPolicy: csr.retryPolicy,
        }).withRetry(operation)
}</span>

// Helper function for case-insensitive string containment check
func containsIgnoreCase(s, substr string) bool <span class="cov8" title="1">{
        s = strings.ToLower(s)
        substr = strings.ToLower(substr)
        return strings.Contains(s, substr)
}</span>

// RepositoryManager manages multiple concurrent-safe repositories
type RepositoryManager struct {
        repositories map[string]*ConcurrentSafeRepository
        mu           sync.RWMutex
}

// NewRepositoryManager creates a new repository manager
func NewRepositoryManager() *RepositoryManager <span class="cov8" title="1">{
        return &amp;RepositoryManager{
                repositories: make(map[string]*ConcurrentSafeRepository),
        }
}</span>

// GetOrCreateRepository safely gets or creates a repository
func (rm *RepositoryManager) GetOrCreateRepository(name string) (*ConcurrentSafeRepository, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("repository name cannot be empty")
        }</span>

        <span class="cov8" title="1">rm.mu.Lock()
        defer rm.mu.Unlock()

        if repo, exists := rm.repositories[name]; exists </span><span class="cov8" title="1">{
                return repo, nil
        }</span>

        // Create new repository
        <span class="cov8" title="1">baseRepo := NewRepository()
        safeRepo := NewConcurrentSafeRepository(baseRepo)
        
        // Initialize the repository
        if err := safeRepo.Initialize(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize repository %s: %w", name, err)
        }</span>

        <span class="cov8" title="1">rm.repositories[name] = safeRepo
        return safeRepo, nil</span>
}

// RemoveRepository safely removes a repository
func (rm *RepositoryManager) RemoveRepository(name string) error <span class="cov8" title="1">{
        rm.mu.Lock()
        defer rm.mu.Unlock()

        if repo, exists := rm.repositories[name]; exists </span><span class="cov8" title="1">{
                // Wait for operations to complete
                if err := repo.WaitForQuiescence(5 * time.Second); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("cannot remove repository while operations are active: %w", err)
                }</span>
                <span class="cov8" title="1">delete(rm.repositories, name)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SafeGetStagedFiles returns a thread-safe copy of staged files
func (csr *ConcurrentSafeRepository) SafeGetStagedFiles() map[string]string <span class="cov8" title="1">{
        csr.globalMutex.RLock()
        defer csr.globalMutex.RUnlock()
        
        if csr.Repository.staging == nil </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>
        
        <span class="cov8" title="1">return csr.Repository.staging.GetFiles()</span>
}

// SafeListStagedFiles returns a thread-safe list of staged file paths
func (csr *ConcurrentSafeRepository) SafeListStagedFiles() []string <span class="cov8" title="1">{
        csr.globalMutex.RLock()
        defer csr.globalMutex.RUnlock()
        
        if csr.Repository.staging == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        
        <span class="cov8" title="1">return csr.Repository.staging.List()</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package govc provides a memory-first Git implementation that enables
// parallel realities, transactional commits, and reactive infrastructure.
//
// govc reimagines Git as a memory-first reality engine where branches are
// lightweight parallel universes and commits trigger reactive events.
//
// Basic usage:
//
//        repo := govc.New()
//
//        // Create parallel realities for testing
//        realities := repo.ParallelRealities([]string{"test-a", "test-b", "test-c"})
//
//        // Transactional commits
//        tx := repo.Transaction()
//        tx.Add("config.yaml", []byte("version: 2.0"))
//        if err := tx.Validate(); err == nil {
//            tx.Commit("Updated config")
//        }
//
//        // Watch for changes
//        repo.Watch(func(event CommitEvent) {
//            fmt.Printf("New commit: %s\n", event.Message)
//        })
package govc

import (
        "github.com/caiatech/govc/pkg/object"
        "github.com/caiatech/govc/pkg/refs"
        "github.com/caiatech/govc/pkg/storage"
)

// New creates a memory-first repository that operates entirely in RAM.
// This is the recommended way to use govc for infrastructure management.
func New() *Repository <span class="cov8" title="1">{
        return NewRepository()
}</span>

// Init initializes a new repository at the given path with optional persistence.
// Use this when you need Git compatibility or want to persist state.
func Init(path string) (*Repository, error) <span class="cov8" title="1">{
        return InitRepository(path)
}</span>

// Open opens an existing repository from disk.
func Open(path string) (*Repository, error) <span class="cov8" title="1">{
        return OpenRepository(path)
}</span>

// NewMemoryStore creates a pure in-memory object store.
// Useful for testing or temporary operations.
func NewMemoryStore() *storage.Store <span class="cov0" title="0">{
        backend := storage.NewMemoryBackend()
        return storage.NewStore(backend)
}</span>

// Config holds repository configuration options.
type Config struct {
        // Memory-first operation (no disk I/O)
        MemoryOnly bool

        // Enable event streaming
        EventStream bool

        // Maximum parallel realities
        MaxRealities int

        // Author information
        Author ConfigAuthor
}

// ConfigAuthor holds author configuration.
type ConfigAuthor struct {
        Name  string
        Email string
}

// NewWithConfig creates a repository with custom configuration.
func NewWithConfig(config Config) *Repository <span class="cov8" title="1">{
        repo := NewRepository()

        if config.Author.Name != "" </span><span class="cov8" title="1">{
                repo.SetConfig("user.name", config.Author.Name)
        }</span>
        <span class="cov8" title="1">if config.Author.Email != "" </span><span class="cov8" title="1">{
                repo.SetConfig("user.email", config.Author.Email)
        }</span>

        <span class="cov8" title="1">return repo</span>
}

// Reality represents a parallel reality (isolated branch universe).
// This is the key abstraction that enables testing multiple states simultaneously.
type Reality = ParallelReality

// Transaction represents a transactional commit that can be validated
// before persisting. This ensures infrastructure changes are safe.
type Transaction = TransactionalCommit

// Event represents a commit event in the repository.
// Use this to build reactive infrastructure systems.
type Event = CommitEvent

// Snapshot represents a point-in-time view of the repository.
// Use TimeTravel() to create snapshots for debugging or analysis.
type Snapshot = HistoricalSnapshot

// Object types re-exported for library users
type (
        Blob   = object.Blob
        Tree   = object.Tree
        Commit = object.Commit
        Tag    = object.Tag
        Author = object.Author
)

// Reference types re-exported for library users
type (
        Ref        = refs.Ref
        RefManager = refs.RefManager
)

// QuickStart provides a simple example of using govc as a library.
func QuickStart() <span class="cov8" title="1">{
        // Create a memory-first repository
        repo := New()

        // Start a transaction
        tx := repo.Transaction()
        tx.Add("config.yaml", []byte("version: 1.0"))
        tx.Add("app.yaml", []byte("name: myapp"))

        // Validate before committing
        if err := tx.Validate(); err != nil </span><span class="cov0" title="0">{
                // Rollback if validation fails
                tx.Rollback()
                return
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">tx.Commit("Initial configuration")

        // Create parallel realities for testing
        realities := repo.ParallelRealities([]string{"staging", "production"})

        // Test changes in staging
        staging := realities[0]
        staging.Apply(map[string][]byte{
                "config.yaml": []byte("version: 2.0-beta"),
        })

        // If tests pass, merge to main
        if staging.Benchmark().Better() </span><span class="cov8" title="1">{
                repo.Merge(staging.Name(), "main")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package govc

import (
        "github.com/caiatech/govc/pkg/core"
        "github.com/caiatech/govc/pkg/refs"
        "github.com/caiatech/govc/pkg/storage"
)

// NewMemoryRepositoryV2Helper creates a pure in-memory repository using clean architecture
// (Actual implementation is in repository_v2.go)
func NewMemoryRepositoryV2Helper() *RepositoryV2 <span class="cov0" title="0">{
        return NewMemoryRepositoryV2()
}</span>

// QuickStartV2 provides a simple way to create an in-memory repository with all components
type QuickStartV2 struct {
        Repository *core.CleanRepository
        Workspace  *core.CleanWorkspace
        Operations *core.Operations
        Config     *core.Config
        Stash      *core.StashManager
        Webhooks   *core.WebhookManager
}

// NewQuickStartV2 creates a complete in-memory Git environment
func NewQuickStartV2() *QuickStartV2 <span class="cov0" title="0">{
        // Create stores
        objects := core.NewMemoryObjectStore()
        refs := core.NewMemoryRefStore()
        working := core.NewMemoryWorkingStorage()
        config := core.NewMemoryConfigStore()

        // Create components
        repo := core.NewCleanRepository(objects, refs)
        workspace := core.NewCleanWorkspace(repo, working)
        cfg := core.NewConfig(config)
        ops := core.NewOperations(repo, workspace, cfg)

        // Create managers
        stash := core.NewStashManager(repo, workspace)
        webhooks := core.NewWebhookManager()

        // Initialize repository
        ops.Init()

        return &amp;QuickStartV2{
                Repository: repo,
                Workspace:  workspace,
                Operations: ops,
                Config:     cfg,
                Stash:      stash,
                Webhooks:   webhooks,
        }
}</span>

// NewFileBackedQuickStartV2 creates a file-backed Git environment
func NewFileBackedQuickStartV2(path string) (*QuickStartV2, error) <span class="cov0" title="0">{
        // Setup directories
        gitDir := path + "/.govc"

        // Create storage backends
        backend := storage.NewFileBackend(gitDir)
        store := storage.NewStore(backend)
        objects := &amp;core.ObjectStoreAdapter{Store: store}

        fileRefStore := refs.NewFileRefStore(gitDir)
        refManager := refs.NewRefManager(fileRefStore)
        refStore := &amp;core.RefStoreAdapter{RefManager: refManager, Store: fileRefStore}

        working := core.NewFileWorkingStorage(path)
        config := core.NewMemoryConfigStore() // Config can still be in memory

        // Create components
        repo := core.NewCleanRepository(objects, refStore)
        workspace := core.NewCleanWorkspace(repo, working)
        cfg := core.NewConfig(config)
        ops := core.NewOperations(repo, workspace, cfg)

        // Create managers
        stash := core.NewStashManager(repo, workspace)
        webhooks := core.NewWebhookManager()

        // Initialize repository
        if err := ops.Init(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;QuickStartV2{
                Repository: repo,
                Workspace:  workspace,
                Operations: ops,
                Config:     cfg,
                Stash:      stash,
                Webhooks:   webhooks,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package govc

import (
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/caiatech/govc/pkg/object"
        "github.com/caiatech/govc/pkg/refs"
        "github.com/caiatech/govc/pkg/storage"
)

// ParallelReality represents an isolated branch that exists only in memory.
// Each ParallelReality is a complete universe where changes can be tested
// without affecting other realities. This is the key to govc's memory-first
// approach - branches aren't just pointers, they're isolated worlds.
type ParallelReality struct {
        name      string
        repo      *Repository
        isolated  bool
        ephemeral bool // Never persists to disk
        startTime time.Time
        mu        sync.RWMutex
}

// Name returns the name of this reality.
func (pr *ParallelReality) Name() string <span class="cov8" title="1">{
        return pr.name
}</span>

// NewRepository creates a memory-first repository.
// Unlike traditional Git, this repository operates entirely in memory
// by default, making operations instant and enabling parallel realities.
func NewRepository() *Repository <span class="cov8" title="1">{
        refManager := NewMemoryRefManager()
        // Initialize with main branch
        refManager.SetHEADToBranch("main")
        // Create the main branch ref pointing to nil (no commits yet)
        refManager.CreateBranch("main", "")

        return &amp;Repository{
                path:       ":memory:",
                store:      createMemoryStore(),
                refManager: refManager,
                staging:    NewStagingArea(),
                worktree:   &amp;Worktree{path: ":memory:", files: make(map[string][]byte)},
                config:     make(map[string]string),
                stashes:    make([]*Stash, 0),
                webhooks:   make(map[string]*Webhook),
                events:     make(chan *RepositoryEvent, 100),
        }
}</span>

// ParallelReality creates an isolated branch universe.
// This is instant because it's memory-only - no disk I/O involved.
func (r *Repository) ParallelReality(name string) *ParallelReality <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Memory-first: Creating a branch is just creating a pointer
        // This is why we can create 1000 branches in milliseconds
        branchName := fmt.Sprintf("parallel/%s", name)
        currentHash, _ := r.refManager.GetHEAD()
        r.refManager.CreateBranch(branchName, currentHash)

        return &amp;ParallelReality{
                name:      branchName,
                repo:      r,
                isolated:  true,
                ephemeral: true,
                startTime: time.Now(),
        }
}</span>

// ParallelRealities creates multiple isolated universes at once.
// Perfect for testing multiple configurations simultaneously.
func (r *Repository) ParallelRealities(names []string) []*ParallelReality <span class="cov8" title="1">{
        realities := make([]*ParallelReality, len(names))
        for i, name := range names </span><span class="cov8" title="1">{
                realities[i] = r.ParallelReality(name)
        }</span>
        <span class="cov8" title="1">return realities</span>
}

// IsolatedBranch creates a branch that's completely isolated from others.
// Changes here won't affect any other branch until explicitly merged.
func (r *Repository) IsolatedBranch(name string) *ParallelReality <span class="cov0" title="0">{
        reality := r.ParallelReality(name)
        reality.isolated = true
        return reality
}</span>

// Apply applies changes to this reality without affecting others.
// This is where the memory-first approach shines - changes are instant.
func (pr *ParallelReality) Apply(changes interface{}) error <span class="cov8" title="1">{
        pr.mu.Lock()
        defer pr.mu.Unlock()

        // Switch to this reality
        oldBranch, _ := pr.repo.CurrentBranch()
        pr.repo.Checkout(pr.Name())
        defer pr.repo.Checkout(oldBranch)

        // Apply changes based on type
        switch c := changes.(type) </span>{
        case map[string][]byte:<span class="cov8" title="1">
                for path, content := range c </span><span class="cov8" title="1">{
                        hash, _ := pr.repo.store.StoreBlob(content)
                        pr.repo.staging.Add(path, hash)
                }</span>
        case func(*ParallelReality):<span class="cov0" title="0">
                c(pr)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported change type: %T", changes)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Evaluate runs tests or benchmarks in this isolated reality.
func (pr *ParallelReality) Evaluate() interface{} <span class="cov8" title="1">{
        pr.mu.RLock()
        defer pr.mu.RUnlock()

        // In this reality, we can run any evaluation without affecting others
        return map[string]interface{}{
                "reality":  pr.name,
                "duration": time.Since(pr.startTime),
                "isolated": pr.isolated,
        }
}</span>

// Benchmark runs performance tests in this reality.
func (pr *ParallelReality) Benchmark() *BenchmarkResult <span class="cov8" title="1">{
        return &amp;BenchmarkResult{
                Reality:   pr.name,
                StartTime: pr.startTime,
                Metrics:   make(map[string]float64),
        }
}</span>

// TransactionalCommit represents a commit that can be validated before persisting.
// This is only possible because we operate in memory first.
type TransactionalCommit struct {
        repo      *Repository
        staging   *StagingArea
        message   string
        author    object.Author
        changes   map[string][]byte
        validated bool
        mu        sync.Mutex
}

// Transaction creates a new transactional commit.
// Changes are staged in memory and can be rolled back before committing.
func (r *Repository) Transaction() *TransactionalCommit <span class="cov8" title="1">{
        return &amp;TransactionalCommit{
                repo:    r,
                staging: NewStagingArea(),
                changes: make(map[string][]byte),
                author: object.Author{
                        Name:  "System",
                        Email: "system@govc",
                        Time:  time.Now(),
                },
        }
}</span>

// Add stages a file in the transaction.
// Nothing is written to disk until Commit() is called.
func (tc *TransactionalCommit) Add(path string, content []byte) <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()

        tc.changes[path] = content
        hash, _ := tc.repo.store.StoreBlob(content)
        tc.staging.Add(path, hash)
}</span>

// Validate checks if the transaction is valid.
// This is where you can run tests, linting, security checks, etc.
func (tc *TransactionalCommit) Validate() error <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()

        // Memory-first benefit: We can validate the entire state
        // before any permanent changes are made
        for path, content := range tc.changes </span><span class="cov8" title="1">{
                if len(content) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("empty file: %s", path)
                }</span>
                // Add more validation logic here
        }
        <span class="cov8" title="1">tc.validated = true
        return nil</span>
}

// Commit finalizes the transaction if validation passed.
// Only now do changes become "real" in the repository.
func (tc *TransactionalCommit) Commit(message string) (*object.Commit, error) <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()

        if !tc.validated </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("transaction not validated")
        }</span>

        <span class="cov8" title="1">tc.message = message

        // Update the author time to the current time when committing
        tc.author.Time = time.Now()

        // Swap staging areas atomically
        oldStaging := tc.repo.staging
        tc.repo.staging = tc.staging
        defer func() </span><span class="cov8" title="1">{ tc.repo.staging = oldStaging }</span>()

        <span class="cov8" title="1">return tc.repo.Commit(message)</span>
}

// Rollback discards all changes in the transaction.
// Because we're memory-first, this is instant and leaves no trace.
func (tc *TransactionalCommit) Rollback() <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()

        tc.changes = make(map[string][]byte)
        tc.staging = NewStagingArea()
        tc.validated = false
}</span>

// CommitEvent represents a commit as an event in the system.
// This enables reactive programming with version control.
type CommitEvent struct {
        Hash      string
        Author    string
        Message   string
        Timestamp time.Time
        Changes   []string
        Branch    string
}

// Watch sets up a commit event stream.
// Every commit becomes an event that can trigger actions.
func (r *Repository) Watch(handler func(CommitEvent)) <span class="cov8" title="1">{
        // This is a simplified version - in production you'd want
        // a proper event bus with channels
        go func() </span><span class="cov8" title="1">{
                lastHash := ""
                for </span><span class="cov8" title="1">{
                        time.Sleep(100 * time.Millisecond)

                        currentHash, err := r.refManager.GetHEAD()
                        if err != nil || currentHash == lastHash </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">commit, err := r.store.GetCommit(currentHash)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">branch, _ := r.CurrentBranch()

                        event := CommitEvent{
                                Hash:      currentHash,
                                Author:    commit.Author.Name,
                                Message:   commit.Message,
                                Timestamp: commit.Author.Time,
                                Branch:    branch,
                        }

                        handler(event)
                        lastHash = currentHash</span>
                }
        }()
}

// TimeTravel returns the repository state at a specific time.
// Memory-first makes this operation instant.
func (r *Repository) TimeTravel(moment time.Time) *HistoricalSnapshot <span class="cov8" title="1">{
        commits, _ := r.Log(0) // Get all commits (newest first)

        // Find the most recent commit at or before the requested time
        // We need to check from newest to oldest and find the last one that's not after the moment
        var bestCommit *object.Commit
        for _, commit := range commits </span><span class="cov8" title="1">{
                // Check if this commit happened at or before the target moment
                if commit.Author.Time.Before(moment) || commit.Author.Time.Equal(moment) </span><span class="cov8" title="1">{
                        // This commit is at or before the target time
                        bestCommit = commit
                        break</span>
                }
        }

        <span class="cov8" title="1">if bestCommit != nil </span><span class="cov8" title="1">{
                return &amp;HistoricalSnapshot{
                        repo:   r,
                        commit: bestCommit,
                        time:   moment,
                }
        }</span>

        // If no commits at or before the requested time, return an empty snapshot
        <span class="cov0" title="0">return &amp;HistoricalSnapshot{
                repo:   r,
                commit: nil, // No commit yet
                time:   moment,
        }</span>
}

// HistoricalSnapshot represents a point-in-time view of the repository.
type HistoricalSnapshot struct {
        repo   *Repository
        commit *object.Commit
        time   time.Time
}

// Read returns file content at this point in history.
func (hs *HistoricalSnapshot) Read(path string) ([]byte, error) <span class="cov8" title="1">{
        if hs.commit == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no commit at this point in time")
        }</span>

        <span class="cov8" title="1">tree, err := hs.repo.store.GetTree(hs.commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Try to find the file in the tree
        <span class="cov8" title="1">hash, err := hs.findFileInTree(tree, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found in snapshot: %s", path)
        }</span>

        <span class="cov8" title="1">blob, err := hs.repo.store.GetBlob(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return blob.Content, nil</span>
}

// findFileInTree recursively searches for a file in the tree
func (hs *HistoricalSnapshot) findFileInTree(tree *object.Tree, path string) (string, error) <span class="cov8" title="1">{
        // Direct match
        for _, entry := range tree.Entries </span><span class="cov8" title="1">{
                if entry.Name == path </span><span class="cov8" title="1">{
                        return entry.Hash, nil
                }</span>
        }

        // Try subdirectories
        <span class="cov0" title="0">parts := strings.SplitN(path, "/", 2)
        if len(parts) == 2 </span><span class="cov0" title="0">{
                for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                        if entry.Name == parts[0] &amp;&amp; entry.Mode == "040000" </span><span class="cov0" title="0">{
                                // This is a directory, recurse
                                subTree, err := hs.repo.store.GetTree(entry.Hash)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return hs.findFileInTree(subTree, parts[1])</span>
                        }
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("not found")</span>
}

// LastCommit returns the commit at this snapshot.
func (hs *HistoricalSnapshot) LastCommit() *object.Commit <span class="cov8" title="1">{
        return hs.commit
}</span>

// BenchmarkResult holds performance metrics for a reality.
type BenchmarkResult struct {
        Reality   string
        StartTime time.Time
        Metrics   map[string]float64
}

// Better compares this result to a baseline.
func (br *BenchmarkResult) Better() bool <span class="cov8" title="1">{
        // Simplified - real implementation would compare metrics
        return true
}</span>

// createMemoryStore creates a store that operates entirely in memory.
// This is what makes govc's instant operations possible.
func createMemoryStore() *storage.Store <span class="cov8" title="1">{
        backend := storage.NewMemoryBackend()
        return storage.NewStore(backend)
}</span>

// NewMemoryRefManager creates a reference manager in memory.
func NewMemoryRefManager() *refs.RefManager <span class="cov8" title="1">{
        store := refs.NewMemoryRefStore()
        return refs.NewRefManager(store)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package govc

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/caiatech/govc/pkg/object"
        "github.com/caiatech/govc/pkg/refs"
        "github.com/caiatech/govc/pkg/storage"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
)

// isCommitHash checks if a string looks like a commit hash (hexadecimal, 7-40 chars)
func isCommitHash(ref string) bool <span class="cov0" title="0">{
        // Match hexadecimal strings between 7 and 40 characters
        matched, _ := regexp.MatchString("^[a-fA-F0-9]{7,40}$", ref)
        return matched
}</span>

// Repository is govc's core abstraction - a memory-first Git repository.
// Unlike traditional Git, this repository can exist entirely in memory,
// enabling instant operations and parallel realities. The path can be
// ":memory:" for pure in-memory operation or a filesystem path for
// optional persistence.
type Repository struct {
        path       string                // ":memory:" for pure memory operation
        store      *storage.Store        // Memory-first object storage
        refManager *refs.RefManager      // Instant branch operations
        staging    *StagingArea          // In-memory staging
        worktree   *Worktree             // Can be virtual (memory-only)
        config     map[string]string     // In-memory config
        stashes    []*Stash              // In-memory stash list
        webhooks   map[string]*Webhook   // Registered webhooks
        events     chan *RepositoryEvent // Event stream
        mu         sync.RWMutex
}

// InitRepository initializes a new repository with file persistence.
func InitRepository(path string) (*Repository, error) <span class="cov8" title="1">{
        gitDir := filepath.Join(path, ".govc")
        if err := os.MkdirAll(gitDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create .govc directory: %v", err)
        }</span>

        <span class="cov8" title="1">objectsDir := filepath.Join(gitDir, "objects")
        if err := os.MkdirAll(objectsDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create objects directory: %v", err)
        }</span>

        <span class="cov8" title="1">refsDir := filepath.Join(gitDir, "refs", "heads")
        if err := os.MkdirAll(refsDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create refs directory: %v", err)
        }</span>

        <span class="cov8" title="1">backend := storage.NewFileBackend(gitDir)
        store := storage.NewStore(backend)
        refStore := refs.NewFileRefStore(gitDir)
        refManager := refs.NewRefManager(refStore)

        // Create main branch pointing to nil (no commits yet)
        if err := refManager.CreateBranch("main", ""); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create main branch: %v", err)
        }</span>

        <span class="cov8" title="1">if err := refManager.SetHEADToBranch("main"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set HEAD: %v", err)
        }</span>

        <span class="cov8" title="1">repo := &amp;Repository{
                path:       path,
                store:      store,
                refManager: refManager,
                staging:    NewStagingArea(),
                worktree:   NewWorktree(path),
                config:     make(map[string]string),
                webhooks:   make(map[string]*Webhook),
                events:     make(chan *RepositoryEvent, 100),
        }

        return repo, nil</span>
}

// OpenRepository opens an existing repository from disk.
func OpenRepository(path string) (*Repository, error) <span class="cov8" title="1">{
        gitDir := filepath.Join(path, ".govc")
        if _, err := os.Stat(gitDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a govc repository: %v", err)
        }</span>

        <span class="cov8" title="1">backend := storage.NewFileBackend(gitDir)
        store := storage.NewStore(backend)
        refStore := refs.NewFileRefStore(gitDir)
        refManager := refs.NewRefManager(refStore)

        return &amp;Repository{
                path:       path,
                store:      store,
                refManager: refManager,
                staging:    NewStagingArea(),
                worktree:   NewWorktree(path),
                config:     make(map[string]string),
                stashes:    make([]*Stash, 0),
                webhooks:   make(map[string]*Webhook),
                events:     make(chan *RepositoryEvent, 100),
        }, nil</span>
}

func (r *Repository) Add(patterns ...string) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if len(patterns) == 0 </span><span class="cov0" title="0">{
                patterns = []string{"."}
        }</span>

        <span class="cov8" title="1">for _, pattern := range patterns </span><span class="cov8" title="1">{
                files, err := r.worktree.MatchFiles(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        content, err := r.worktree.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">hash, err := r.store.StoreBlob(content)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">r.staging.Add(file, hash)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository) Commit(message string) (*object.Commit, error) <span class="cov8" title="1">{
        // Execute pre-commit hooks first
        if err := r.executePreCommitHooks(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pre-commit hooks failed: %v", err)
        }</span>

        // Get config values before locking
        <span class="cov8" title="1">authorName := r.getConfigValue("user.name", "Unknown")
        authorEmail := r.getConfigValue("user.email", "unknown@example.com")

        r.mu.Lock()
        defer r.mu.Unlock()

        tree, err := r.createTreeFromStaging()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">treeHash, err := r.store.StoreTree(tree)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">author := object.Author{
                Name:  authorName,
                Email: authorEmail,
                Time:  time.Now(),
        }

        commit := object.NewCommit(treeHash, author, message)

        currentBranch, err := r.refManager.GetCurrentBranch()
        if err == nil &amp;&amp; currentBranch != "" </span><span class="cov8" title="1">{
                parentHash, err := r.refManager.GetBranch(currentBranch)
                if err == nil </span><span class="cov8" title="1">{
                        commit.SetParent(parentHash)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                // If we can't get current branch, we might be on main but it doesn't exist yet
                currentBranch = "main"
        }</span>

        <span class="cov8" title="1">commitHash, err := r.store.StoreCommit(commit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if currentBranch != "" </span><span class="cov8" title="1">{
                // Update or create the branch
                if err := r.refManager.UpdateRef("refs/heads/"+currentBranch, commitHash, ""); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Make sure HEAD points to the branch
                <span class="cov8" title="1">if err := r.refManager.SetHEADToBranch(currentBranch); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.refManager.SetHEADToCommit(commitHash); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">r.staging.Clear()

        // Execute post-commit hooks
        if err := r.executePostCommitHooks(commit); err != nil </span><span class="cov0" title="0">{
                // Post-commit hooks failing shouldn't fail the commit itself
                // but we should log or emit an event about the failure
                r.EmitEvent("post-commit-hook-failed", map[string]interface{}{
                        "commit": commit.Hash(),
                        "error":  err.Error(),
                })
        }</span>

        <span class="cov8" title="1">return commit, nil</span>
}

func (r *Repository) Branch(name string) *BranchBuilder <span class="cov8" title="1">{
        return &amp;BranchBuilder{
                repo: r,
                name: name,
        }
}</span>

func (r *Repository) ListBranches() ([]refs.Ref, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        return r.refManager.ListBranches()
}</span>

func (r *Repository) CurrentBranch() (string, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        return r.refManager.GetCurrentBranch()
}</span>

// CreateTag creates a new tag at the current HEAD
func (r *Repository) CreateTag(name string, message string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Get current HEAD
        commitHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Create tag
        <span class="cov0" title="0">return r.refManager.CreateTag(name, commitHash)</span>
}

// ListTags returns all tags
func (r *Repository) ListTags() ([]string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        refs, err := r.refManager.ListTags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tags := make([]string, len(refs))
        for i, ref := range refs </span><span class="cov0" title="0">{
                // Remove refs/tags/ prefix
                tags[i] = strings.TrimPrefix(ref.Name, "refs/tags/")
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// GetTagCommit returns the commit hash for a given tag
func (r *Repository) GetTagCommit(tagName string) (string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        
        return r.refManager.GetTag(tagName)
}</span>

// CurrentCommit returns the current HEAD commit
func (r *Repository) CurrentCommit() (*object.Commit, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        head, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.store.GetCommit(head)</span>
}

func (r *Repository) Checkout(ref string) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // First check if this is a branch name
        // Branch names can contain slashes (e.g., feature/add-tests)
        // So we need to check if it's a valid branch first
        isBranch := false
        branchName := ref
        if strings.HasPrefix(ref, "refs/heads/") </span><span class="cov0" title="0">{
                branchName = strings.TrimPrefix(ref, "refs/heads/")
                isBranch = true
        }</span> else<span class="cov8" title="1"> {
                // Check if this ref exists as a branch
                if _, err := r.refManager.GetBranch(ref); err == nil </span><span class="cov8" title="1">{
                        branchName = ref
                        isBranch = true
                }</span> else<span class="cov0" title="0"> {
                        // Branch doesn't exist, but check if it looks like a commit hash
                        // If it doesn't look like a commit hash, treat it as a new branch name
                        if !isCommitHash(ref) </span><span class="cov0" title="0">{
                                branchName = ref
                                isBranch = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if isBranch </span><span class="cov8" title="1">{

                // Check if the branch exists
                branchHash, err := r.refManager.GetBranch(branchName)
                if err != nil </span><span class="cov0" title="0">{
                        // Branch doesn't exist - return error
                        return fmt.Errorf("branch not found: %s", branchName)
                }</span>

                // Branch exists, update worktree
                <span class="cov8" title="1">if branchHash == "" </span><span class="cov8" title="1">{
                        // Empty branch - clear the worktree
                        files := r.worktree.ListFiles()
                        for _, file := range files </span><span class="cov0" title="0">{
                                r.worktree.RemoveFile(file)
                        }</span>
                        <span class="cov8" title="1">return r.refManager.SetHEADToBranch(branchName)</span>
                }

                <span class="cov8" title="1">commit, err := r.store.GetCommit(branchHash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">tree, err := r.store.GetTree(commit.TreeHash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := r.updateWorktree(tree); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return r.refManager.SetHEADToBranch(branchName)</span>
        }

        // Not a branch, resolve as commit
        <span class="cov0" title="0">commitHash, err := r.resolveRef(ref)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.updateWorktree(tree); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return r.refManager.SetHEADToCommit(commitHash)</span>
}

func (r *Repository) Status() (*Status, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        status := &amp;Status{
                Branch:    r.getCurrentBranchName(),
                Staged:    make([]string, 0),
                Modified:  make([]string, 0),
                Untracked: make([]string, 0),
        }

        // Get staged files
        status.Staged = r.staging.List()

        // Get worktree files to check for untracked/modified
        worktreeFiles := r.worktree.ListFiles()

        // Get committed files
        var committedFiles map[string]bool
        headHash, err := r.refManager.GetHEAD()
        if err == nil &amp;&amp; headHash != "" </span><span class="cov8" title="1">{
                commit, err := r.store.GetCommit(headHash)
                if err == nil </span><span class="cov8" title="1">{
                        tree, err := r.store.GetTree(commit.TreeHash)
                        if err == nil </span><span class="cov8" title="1">{
                                committedFiles = make(map[string]bool)
                                for _, entry := range tree.Entries </span><span class="cov8" title="1">{
                                        committedFiles[entry.Name] = true
                                }</span>
                        }
                }
        }

        // Check each worktree file
        <span class="cov8" title="1">for _, file := range worktreeFiles </span><span class="cov8" title="1">{
                // Skip if already staged
                if r.staging.Contains(file) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if untracked
                <span class="cov8" title="1">if committedFiles == nil || !committedFiles[file] </span><span class="cov8" title="1">{
                        status.Untracked = append(status.Untracked, file)
                }</span>
        }

        <span class="cov8" title="1">return status, nil</span>
}

func (r *Repository) Log(limit int) ([]*object.Commit, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        commits := make([]*object.Commit, 0)

        headHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                // No commits yet, return empty slice
                return commits, nil
        }</span>
        <span class="cov8" title="1">currentHash := headHash

        for i := 0; (limit &lt;= 0 || i &lt; limit) &amp;&amp; currentHash != ""; i++ </span><span class="cov8" title="1">{
                commit, err := r.store.GetCommit(currentHash)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">commits = append(commits, commit)
                currentHash = commit.ParentHash</span>
        }

        <span class="cov8" title="1">return commits, nil</span>
}

func (r *Repository) createTreeFromStaging() (*object.Tree, error) <span class="cov8" title="1">{
        tree := object.NewTree()

        // Get current branch to find parent commit
        currentBranch, err := r.refManager.GetCurrentBranch()
        if err == nil &amp;&amp; currentBranch != "" </span><span class="cov8" title="1">{
                parentHash, err := r.refManager.GetBranch(currentBranch)
                if err == nil &amp;&amp; parentHash != "" </span><span class="cov8" title="1">{
                        // Load parent commit's tree
                        parentCommit, err := r.store.GetCommit(parentHash)
                        if err == nil </span><span class="cov8" title="1">{
                                parentTree, err := r.store.GetTree(parentCommit.TreeHash)
                                if err == nil </span><span class="cov8" title="1">{
                                        // Copy all entries from parent tree
                                        for _, entry := range parentTree.Entries </span><span class="cov8" title="1">{
                                                // Skip if this file is being updated in staging or removed
                                                if !r.staging.Contains(entry.Name) &amp;&amp; !r.staging.IsRemoved(entry.Name) </span><span class="cov8" title="1">{
                                                        tree.AddEntry(entry.Mode, entry.Name, entry.Hash)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Add/update files from staging
        <span class="cov8" title="1">r.staging.ForEach(func(file, hash string) </span><span class="cov8" title="1">{
                mode := "100644"
                tree.AddEntry(mode, file, hash)
        }</span>)

        <span class="cov8" title="1">return tree, nil</span>
}

func (r *Repository) updateWorktree(tree *object.Tree) error <span class="cov8" title="1">{
        // First, clear the worktree
        // Get all current files
        currentFiles := r.worktree.ListFiles()

        // Build a set of files that should exist
        shouldExist := make(map[string]bool)
        for _, entry := range tree.Entries </span><span class="cov8" title="1">{
                shouldExist[entry.Name] = true
        }</span>

        // Remove files that shouldn't exist
        <span class="cov8" title="1">for _, file := range currentFiles </span><span class="cov8" title="1">{
                if !shouldExist[file] </span><span class="cov0" title="0">{
                        if err := r.worktree.RemoveFile(file); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Now write all files from the tree
        <span class="cov8" title="1">for _, entry := range tree.Entries </span><span class="cov8" title="1">{
                blob, err := r.store.GetBlob(entry.Hash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := r.worktree.WriteFile(entry.Name, blob.Content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *Repository) resolveRef(ref string) (string, error) <span class="cov0" title="0">{
        // Handle special refs
        if ref == "HEAD" </span><span class="cov0" title="0">{
                return r.refManager.GetHEAD()
        }</span>

        // Handle shortened refs like HEAD~1, HEAD^
        <span class="cov0" title="0">if strings.HasPrefix(ref, "HEAD") </span><span class="cov0" title="0">{
                headHash, err := r.refManager.GetHEAD()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Simple HEAD~N parsing
                <span class="cov0" title="0">if strings.HasPrefix(ref, "HEAD~") </span><span class="cov0" title="0">{
                        n := 1
                        if len(ref) &gt; 5 </span><span class="cov0" title="0">{
                                fmt.Sscanf(ref[5:], "%d", &amp;n)
                        }</span>

                        // Walk back n commits
                        <span class="cov0" title="0">currentHash := headHash
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                commit, err := r.store.GetCommit(currentHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", fmt.Errorf("cannot resolve %s: %w", ref, err)
                                }</span>
                                <span class="cov0" title="0">if commit.ParentHash == "" </span><span class="cov0" title="0">{
                                        return "", fmt.Errorf("cannot go back %d commits from HEAD", n)
                                }</span>
                                <span class="cov0" title="0">currentHash = commit.ParentHash</span>
                        }
                        <span class="cov0" title="0">return currentHash, nil</span>
                }

                <span class="cov0" title="0">if ref == "HEAD^" </span><span class="cov0" title="0">{
                        commit, err := r.store.GetCommit(headHash)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">if commit.ParentHash == "" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("HEAD has no parent")
                        }</span>
                        <span class="cov0" title="0">return commit.ParentHash, nil</span>
                }
        }

        // Full hash
        <span class="cov0" title="0">if len(ref) == 40 </span><span class="cov0" title="0">{
                return ref, nil
        }</span>

        // Try as branch name
        <span class="cov0" title="0">hash, err := r.refManager.GetBranch(ref)
        if err == nil </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        // Try as tag
        <span class="cov0" title="0">hash, err = r.refManager.GetTag(ref)
        if err == nil </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        // Try as shortened commit hash (at least 4 chars)
        <span class="cov0" title="0">if len(ref) &gt;= 4 &amp;&amp; len(ref) &lt; 40 </span><span class="cov0" title="0">{
                // This is a simplified approach - in a real implementation,
                // we'd need to search through all commits
                // For now, we'll check if it's a valid hex string
                for _, c := range ref </span><span class="cov0" title="0">{
                        if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("ref not found: %s", ref)
                        }</span>
                }
                // In a real implementation, we'd search for commits starting with this prefix
                <span class="cov0" title="0">return "", fmt.Errorf("shortened commit hash not yet supported: %s", ref)</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("ref not found: %s", ref)</span>
}

// SetConfig sets a configuration value.
func (r *Repository) SetConfig(key, value string) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.config[key] = value
}</span>

// GetConfig gets a configuration value.
func (r *Repository) GetConfig(key string) string <span class="cov8" title="1">{
        return r.getConfigValue(key, "")
}</span>

func (r *Repository) getConfigValue(key, defaultValue string) string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if val, ok := r.config[key]; ok </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func (r *Repository) getCurrentBranchName() string <span class="cov8" title="1">{
        branch, err := r.refManager.GetCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return "HEAD"
        }</span>
        <span class="cov8" title="1">return branch</span>
}

type StagingArea struct {
        files   map[string]string // Files staged for addition/modification
        removed map[string]bool   // Files staged for removal
        mu      sync.RWMutex
}

func NewStagingArea() *StagingArea <span class="cov8" title="1">{
        return &amp;StagingArea{
                files:   make(map[string]string),
                removed: make(map[string]bool),
        }
}</span>

func (s *StagingArea) Add(path, hash string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.files[path] = hash
}</span>

func (s *StagingArea) Remove(path string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.files, path)
        s.removed[path] = true
}</span>

func (s *StagingArea) Clear() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.files = make(map[string]string)
        s.removed = make(map[string]bool)
}</span>

func (s *StagingArea) IsRemoved(path string) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.removed[path]
}</span>

func (s *StagingArea) GetFiles() map[string]string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        files := make(map[string]string)
        for k, v := range s.files </span><span class="cov8" title="1">{
                files[k] = v
        }</span>
        <span class="cov8" title="1">return files</span>
}

func (s *StagingArea) List() []string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        result := make([]string, 0, len(s.files))
        for path := range s.files </span><span class="cov8" title="1">{
                result = append(result, path)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ForEach iterates over staged files safely with a callback
func (s *StagingArea) ForEach(callback func(path, hash string)) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        for path, hash := range s.files </span><span class="cov8" title="1">{
                callback(path, hash)
        }</span>
}

// Contains checks if a path is staged
func (s *StagingArea) Contains(path string) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        _, exists := s.files[path]
        return exists
}</span>

// GetHash returns the hash for a specific staged file
func (s *StagingArea) GetHash(path string) (string, bool) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        
        hash, exists := s.files[path]
        return hash, exists
}</span>

// SetFile sets a file hash directly (for internal operations like stash apply)
func (s *StagingArea) SetFile(path, hash string) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        s.files[path] = hash
}</span>

type Worktree struct {
        path  string
        files map[string][]byte // For memory-based worktree
        mu    sync.RWMutex
}

func NewWorktree(path string) *Worktree <span class="cov8" title="1">{
        wt := &amp;Worktree{path: path}
        if path == ":memory:" </span><span class="cov0" title="0">{
                wt.files = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">return wt</span>
}

func (w *Worktree) MatchFiles(pattern string) ([]string, error) <span class="cov8" title="1">{
        var files []string

        if w.path == ":memory:" </span><span class="cov8" title="1">{
                // For memory worktree, return files from memory
                w.mu.RLock()
                defer w.mu.RUnlock()
                for path := range w.files </span><span class="cov8" title="1">{
                        // Simple pattern matching for "*" or specific patterns
                        if pattern == "*" || pattern == "." </span><span class="cov0" title="0">{
                                files = append(files, path)
                        }</span> else<span class="cov8" title="1"> if matched, _ := filepath.Match(pattern, path); matched </span><span class="cov8" title="1">{
                                files = append(files, path)
                        }</span>
                }
                <span class="cov8" title="1">return files, nil</span>
        }

        <span class="cov0" title="0">if pattern == "." || pattern == "*" </span><span class="cov0" title="0">{
                err := filepath.Walk(w.path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if info.IsDir() || strings.Contains(path, ".govc") </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">relPath, err := filepath.Rel(w.path, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">files = append(files, relPath)
                        return nil</span>
                })
                <span class="cov0" title="0">return files, err</span>
        }

        <span class="cov0" title="0">if strings.Contains(pattern, "*") </span><span class="cov0" title="0">{
                matches, err := filepath.Glob(filepath.Join(w.path, pattern))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                        relPath, err := filepath.Rel(w.path, match)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">files = append(files, relPath)</span>
                }
                <span class="cov0" title="0">return files, nil</span>
        }

        <span class="cov0" title="0">fullPath := filepath.Join(w.path, pattern)
        if _, err := os.Stat(fullPath); err == nil </span><span class="cov0" title="0">{
                files = append(files, pattern)
        }</span>

        <span class="cov0" title="0">return files, nil</span>
}

func (w *Worktree) ListFiles() []string <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if w.path == ":memory:" </span><span class="cov8" title="1">{
                // For memory-based worktree, list from memory
                files := make([]string, 0, len(w.files))
                for path := range w.files </span><span class="cov8" title="1">{
                        files = append(files, path)
                }</span>
                <span class="cov8" title="1">return files</span>
        }

        // For file-based worktree, walk the directory
        <span class="cov0" title="0">var files []string
        filepath.Walk(w.path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil || info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Skip .git directory
                <span class="cov0" title="0">if strings.Contains(path, ".git") </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(w.path, path)
                if err == nil </span><span class="cov0" title="0">{
                        files = append(files, relPath)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return files</span>
}

func (w *Worktree) ReadFile(path string) ([]byte, error) <span class="cov8" title="1">{
        if w.path == ":memory:" </span><span class="cov8" title="1">{
                // For memory-based worktree, read from memory
                w.mu.RLock()
                defer w.mu.RUnlock()
                if content, ok := w.files[path]; ok </span><span class="cov8" title="1">{
                        return content, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("file not found in memory worktree: %s", path)</span>
        }
        <span class="cov0" title="0">return os.ReadFile(filepath.Join(w.path, path))</span>
}

func (w *Worktree) WriteFile(path string, content []byte) error <span class="cov8" title="1">{
        if w.path == ":memory:" </span><span class="cov8" title="1">{
                // For memory-based worktree, store in memory
                w.mu.Lock()
                defer w.mu.Unlock()
                w.files[path] = content
                return nil
        }</span>
        <span class="cov0" title="0">fullPath := filepath.Join(w.path, path)
        dir := filepath.Dir(fullPath)

        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(fullPath, content, 0644)</span>
}

func (w *Worktree) RemoveFile(path string) error <span class="cov0" title="0">{
        if w.path == ":memory:" </span><span class="cov0" title="0">{
                // For memory-based worktree, remove from memory
                w.mu.Lock()
                defer w.mu.Unlock()
                delete(w.files, path)
                return nil
        }</span>
        <span class="cov0" title="0">fullPath := filepath.Join(w.path, path)
        return os.Remove(fullPath)</span>
}

type Status struct {
        Branch    string
        Staged    []string
        Modified  []string
        Untracked []string
}

// Stash represents a saved working directory and staging area state
type Stash struct {
        ID           string
        Message      string
        Author       object.Author
        TreeHash     string            // Hash of the stashed tree
        ParentCommit string            // Commit hash when stash was created
        StagedFiles  map[string]string // path -&gt; hash of staged files
        WorkingFiles map[string][]byte // path -&gt; content of working files
        Timestamp    time.Time
}

type BranchBuilder struct {
        repo *Repository
        name string
}

func (b *BranchBuilder) Create() error <span class="cov8" title="1">{
        b.repo.mu.Lock()
        defer b.repo.mu.Unlock()

        // Get the actual commit hash that HEAD points to
        currentBranch, err := b.repo.refManager.GetCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                // HEAD is detached, get the commit directly
                headHash, err := b.repo.refManager.GetHEAD()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return b.repo.refManager.CreateBranch(b.name, headHash)</span>
        }

        // HEAD points to a branch, get the branch's commit
        <span class="cov8" title="1">branchHash, err := b.repo.refManager.GetBranch(currentBranch)
        if err != nil </span><span class="cov0" title="0">{
                // Current branch has no commits yet
                // Create the new branch pointing to nothing (will be set on first commit)
                return b.repo.refManager.CreateBranch(b.name, "")
        }</span>

        <span class="cov8" title="1">return b.repo.refManager.CreateBranch(b.name, branchHash)</span>
}

func (b *BranchBuilder) Checkout() error <span class="cov8" title="1">{
        if err := b.Create(); err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), "already exists") </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return b.repo.Checkout(b.name)</span>
}

func (b *BranchBuilder) Delete() error <span class="cov0" title="0">{
        b.repo.mu.Lock()
        defer b.repo.mu.Unlock()

        // Check if this is the current branch
        currentBranch, err := b.repo.refManager.GetCurrentBranch()
        if err == nil &amp;&amp; currentBranch == b.name </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete current branch")
        }</span>

        <span class="cov0" title="0">return b.repo.refManager.DeleteBranch(b.name)</span>
}

func Clone(url, path string) (*Repository, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("clone not yet implemented")
}</span>

func (r *Repository) Push(remote, branch string) error <span class="cov0" title="0">{
        // Execute pre-push hooks first
        if err := r.executePrePushHooks(remote, branch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pre-push hooks failed: %v", err)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("push not yet implemented")</span>
}

func (r *Repository) Pull(remote, branch string) error <span class="cov0" title="0">{
        return fmt.Errorf("pull not yet implemented")
}</span>

// Merge merges changes from the specified branch into the current branch.
// Supports both fast-forward and three-way merge.
func (r *Repository) Merge(from, to string) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Save current branch
        currentBranch, err := r.refManager.GetCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not on a branch")
        }</span>

        // Switch to target branch if needed
        <span class="cov8" title="1">if to != "" &amp;&amp; to != currentBranch </span><span class="cov0" title="0">{
                if err := r.Checkout(to); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to checkout %s: %v", to, err)
                }</span>
                <span class="cov0" title="0">defer r.Checkout(currentBranch)</span> // Switch back after merge
        }

        <span class="cov8" title="1">targetHash, err := r.refManager.GetBranch(from)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("branch not found: %s", from)
        }</span>

        <span class="cov8" title="1">currentHash, err := r.refManager.GetBranch(r.getCurrentBranchName())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("current branch has no commits")
        }</span>

        <span class="cov8" title="1">if r.canFastForward(currentHash, targetHash) </span><span class="cov8" title="1">{
                return r.refManager.UpdateRef("refs/heads/"+r.getCurrentBranchName(), targetHash, currentHash)
        }</span>

        <span class="cov0" title="0">mergeBase, err := r.findMergeBase(currentHash, targetHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if mergeBase == targetHash </span><span class="cov0" title="0">{
                return fmt.Errorf("already up to date")
        }</span>

        <span class="cov0" title="0">if mergeBase == currentHash </span><span class="cov0" title="0">{
                return r.refManager.UpdateRef("refs/heads/"+r.getCurrentBranchName(), targetHash, currentHash)
        }</span>

        <span class="cov0" title="0">return r.threeWayMerge(currentHash, targetHash, mergeBase, from)</span>
}

func (r *Repository) canFastForward(currentHash, targetHash string) bool <span class="cov8" title="1">{
        commitHash := targetHash
        for commitHash != "" </span><span class="cov8" title="1">{
                if commitHash == currentHash </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">commit, err := r.store.GetCommit(commitHash)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">commitHash = commit.ParentHash</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (r *Repository) findMergeBase(hash1, hash2 string) (string, error) <span class="cov0" title="0">{
        ancestors1 := make(map[string]bool)

        commitHash := hash1
        for commitHash != "" </span><span class="cov0" title="0">{
                ancestors1[commitHash] = true
                commit, err := r.store.GetCommit(commitHash)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">commitHash = commit.ParentHash</span>
        }

        <span class="cov0" title="0">commitHash = hash2
        for commitHash != "" </span><span class="cov0" title="0">{
                if ancestors1[commitHash] </span><span class="cov0" title="0">{
                        return commitHash, nil
                }</span>
                <span class="cov0" title="0">commit, err := r.store.GetCommit(commitHash)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">commitHash = commit.ParentHash</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no common ancestor found")</span>
}

func (r *Repository) threeWayMerge(ourHash, theirHash, baseHash, branchName string) error <span class="cov0" title="0">{
        baseCommit, err := r.store.GetCommit(baseHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">baseTree, err := r.store.GetTree(baseCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ourCommit, err := r.store.GetCommit(ourHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ourTree, err := r.store.GetTree(ourCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">theirCommit, err := r.store.GetCommit(theirHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">theirTree, err := r.store.GetTree(theirCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mergedTree, conflicts := r.mergeTrees(baseTree, ourTree, theirTree)
        if len(conflicts) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("merge conflicts in files: %v", conflicts)
        }</span>

        <span class="cov0" title="0">mergedTreeHash, err := r.store.StoreTree(mergedTree)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">author := object.Author{
                Name:  r.getConfigValue("user.name", "Unknown"),
                Email: r.getConfigValue("user.email", "unknown@example.com"),
                Time:  time.Now(),
        }

        mergeCommit := &amp;object.Commit{
                TreeHash:   mergedTreeHash,
                ParentHash: ourHash,
                Author:     author,
                Committer:  author,
                Message:    fmt.Sprintf("Merge branch '%s'", branchName),
        }

        mergeCommitHash, err := r.store.StoreCommit(mergeCommit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currentBranch, _ := r.refManager.GetCurrentBranch()
        return r.refManager.UpdateRef("refs/heads/"+currentBranch, mergeCommitHash, ourHash)</span>
}

func (r *Repository) mergeTrees(base, ours, theirs *object.Tree) (*object.Tree, []string) <span class="cov0" title="0">{
        merged := object.NewTree()
        conflicts := []string{}

        allFiles := make(map[string]bool)
        for _, entry := range base.Entries </span><span class="cov0" title="0">{
                allFiles[entry.Name] = true
        }</span>
        <span class="cov0" title="0">for _, entry := range ours.Entries </span><span class="cov0" title="0">{
                allFiles[entry.Name] = true
        }</span>
        <span class="cov0" title="0">for _, entry := range theirs.Entries </span><span class="cov0" title="0">{
                allFiles[entry.Name] = true
        }</span>

        <span class="cov0" title="0">for file := range allFiles </span><span class="cov0" title="0">{
                baseEntry := r.findTreeEntry(base, file)
                ourEntry := r.findTreeEntry(ours, file)
                theirEntry := r.findTreeEntry(theirs, file)

                if ourEntry == nil &amp;&amp; theirEntry == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if ourEntry != nil &amp;&amp; theirEntry == nil </span><span class="cov0" title="0">{
                        if baseEntry != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">merged.AddEntry(ourEntry.Mode, ourEntry.Name, ourEntry.Hash)
                        continue</span>
                }

                <span class="cov0" title="0">if ourEntry == nil &amp;&amp; theirEntry != nil </span><span class="cov0" title="0">{
                        if baseEntry != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">merged.AddEntry(theirEntry.Mode, theirEntry.Name, theirEntry.Hash)
                        continue</span>
                }

                <span class="cov0" title="0">if ourEntry.Hash == theirEntry.Hash </span><span class="cov0" title="0">{
                        merged.AddEntry(ourEntry.Mode, ourEntry.Name, ourEntry.Hash)
                        continue</span>
                }

                <span class="cov0" title="0">if baseEntry != nil &amp;&amp; baseEntry.Hash == ourEntry.Hash </span><span class="cov0" title="0">{
                        merged.AddEntry(theirEntry.Mode, theirEntry.Name, theirEntry.Hash)
                        continue</span>
                }

                <span class="cov0" title="0">if baseEntry != nil &amp;&amp; baseEntry.Hash == theirEntry.Hash </span><span class="cov0" title="0">{
                        merged.AddEntry(ourEntry.Mode, ourEntry.Name, ourEntry.Hash)
                        continue</span>
                }

                <span class="cov0" title="0">conflicts = append(conflicts, file)</span>
        }

        <span class="cov0" title="0">return merged, conflicts</span>
}

func (r *Repository) findTreeEntry(tree *object.Tree, name string) *object.TreeEntry <span class="cov0" title="0">{
        for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                if entry.Name == name </span><span class="cov0" title="0">{
                        return &amp;entry
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) Serve(addr string) error <span class="cov0" title="0">{
        return StartServer(r, addr)
}</span>

func StartServer(repo *Repository, addr string) error <span class="cov0" title="0">{
        server := NewHTTPServer(repo)
        return http.ListenAndServe(addr, server)
}</span>

type HTTPServer struct {
        repo   *Repository
        router *mux.Router
}

func NewHTTPServer(repo *Repository) *HTTPServer <span class="cov0" title="0">{
        s := &amp;HTTPServer{
                repo:   repo,
                router: mux.NewRouter(),
        }
        s.setupRoutes()
        return s
}</span>

func (s *HTTPServer) setupRoutes() <span class="cov0" title="0">{
        s.router.HandleFunc("/{repo}/info/refs", s.handleInfoRefs).Methods("GET")
        s.router.HandleFunc("/{repo}/git-upload-pack", s.handleUploadPack).Methods("POST")
        s.router.HandleFunc("/{repo}/git-receive-pack", s.handleReceivePack).Methods("POST")
}</span>

func (s *HTTPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.router.ServeHTTP(w, r)
}</span>

func (s *HTTPServer) handleInfoRefs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        service := r.URL.Query().Get("service")

        if service != "git-upload-pack" &amp;&amp; service != "git-receive-pack" </span><span class="cov0" title="0">{
                http.Error(w, "Invalid service", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", fmt.Sprintf("application/x-%s-advertisement", service))
        w.Header().Set("Cache-Control", "no-cache")

        packet := fmt.Sprintf("# service=%s\n", service)
        fmt.Fprintf(w, "%04x%s0000", len(packet)+4, packet)

        branches, _ := s.repo.ListBranches()
        for i, branch := range branches </span><span class="cov0" title="0">{
                line := fmt.Sprintf("%s %s", branch.Hash, branch.Name)
                if i == 0 </span><span class="cov0" title="0">{
                        line += "\x00capabilities^{}"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "%04x%s\n", len(line)+5, line)</span>
        }

        <span class="cov0" title="0">fmt.Fprint(w, "0000")</span>
}

func (s *HTTPServer) handleUploadPack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/x-git-upload-pack-result")
        w.Header().Set("Cache-Control", "no-cache")
        fmt.Fprint(w, "0008NAK\n")
}</span>

func (s *HTTPServer) handleReceivePack(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/x-git-receive-pack-result")
        w.Header().Set("Cache-Control", "no-cache")
        fmt.Fprint(w, "0000")
}</span>

func (r *Repository) GetObject(hash string) (object.Object, error) <span class="cov0" title="0">{
        return r.store.GetObject(hash)
}</span>

func (r *Repository) HasObject(hash string) bool <span class="cov0" title="0">{
        return r.store.HasObject(hash)
}</span>

func (r *Repository) Export(w io.Writer, format string) error <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if format != "fast-export" </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported export format: %s", format)
        }</span>

        // Get all branches
        <span class="cov0" title="0">branches, err := r.refManager.ListBranches()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list branches: %w", err)
        }</span>

        // Get all tags
        <span class="cov0" title="0">tags, err := r.refManager.ListTags()
        if err != nil </span><span class="cov0" title="0">{
                // Tags might not exist, that's OK
                tags = []refs.Ref{}
        }</span>

        // Track exported commits and their marks
        <span class="cov0" title="0">commitToMark := make(map[string]int)
        markCounter := 1

        // Start with empty blob
        fmt.Fprintf(w, "blob\n")
        fmt.Fprintf(w, "mark :%d\n", markCounter)
        fmt.Fprintf(w, "data 0\n\n")
        markCounter++

        // Collect all unique commits from all branches
        allCommits := make(map[string]*object.Commit)
        commitOrder := make([]string, 0)

        var collectCommits func(hash string) error
        collectCommits = func(hash string) error </span><span class="cov0" title="0">{
                if hash == "" || allCommits[hash] != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">commit, err := r.store.GetCommit(hash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Recurse to parent first
                <span class="cov0" title="0">if commit.ParentHash != "" </span><span class="cov0" title="0">{
                        if err := collectCommits(commit.ParentHash); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">allCommits[hash] = commit
                commitOrder = append(commitOrder, hash)
                return nil</span>
        }

        // Collect commits from all branches
        <span class="cov0" title="0">for _, branch := range branches </span><span class="cov0" title="0">{
                if branch.Hash != "" </span><span class="cov0" title="0">{
                        collectCommits(branch.Hash)
                }</span>
        }

        // Export all commits first
        <span class="cov0" title="0">for _, hash := range commitOrder </span><span class="cov0" title="0">{
                commit := allCommits[hash]
                commitToMark[hash] = markCounter

                // For now, export all commits to the main branch
                // This is a simplification - a full implementation would track branch points
                fmt.Fprintf(w, "commit refs/heads/main\n")
                fmt.Fprintf(w, "mark :%d\n", markCounter)
                fmt.Fprintf(w, "author %s &lt;%s&gt; %d +0000\n", commit.Author.Name, commit.Author.Email, commit.Author.Time.Unix())
                fmt.Fprintf(w, "committer %s &lt;%s&gt; %d +0000\n", commit.Committer.Name, commit.Committer.Email, commit.Committer.Time.Unix())
                fmt.Fprintf(w, "data %d\n%s\n", len(commit.Message), commit.Message)

                if commit.ParentHash != "" </span><span class="cov0" title="0">{
                        if parentMark, exists := commitToMark[commit.ParentHash]; exists </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "from :%d\n", parentMark)
                        }</span>
                }

                // Export tree
                <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
                if err == nil </span><span class="cov0" title="0">{
                        for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                                blob, err := r.store.GetBlob(entry.Hash)
                                if err == nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(w, "M 100644 inline %s\n", entry.Name)
                                        fmt.Fprintf(w, "data %d\n", len(blob.Content))
                                        w.Write(blob.Content)
                                        fmt.Fprintf(w, "\n")
                                }</span>
                        }
                }

                <span class="cov0" title="0">markCounter++</span>
        }

        // Export branch refs
        <span class="cov0" title="0">for _, branch := range branches </span><span class="cov0" title="0">{
                if branch.Hash != "" &amp;&amp; branch.Name != "refs/heads/main" </span><span class="cov0" title="0">{
                        if mark, exists := commitToMark[branch.Hash]; exists </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "reset %s\n", branch.Name)
                                fmt.Fprintf(w, "from :%d\n\n", mark)
                        }</span>
                }
        }

        // Export tags
        <span class="cov0" title="0">for _, tag := range tags </span><span class="cov0" title="0">{
                if mark, exists := commitToMark[tag.Hash]; exists </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "tag %s\n", strings.TrimPrefix(tag.Name, "refs/tags/"))
                        fmt.Fprintf(w, "from :%d\n", mark)
                        fmt.Fprintf(w, "tagger Unknown &lt;unknown@example.com&gt; %d +0000\n", time.Now().Unix())
                        fmt.Fprintf(w, "data 0\n\n")
                }</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(w, "done\n")
        return nil</span>
}

// ReadFile reads a file from the working directory if it exists, otherwise from HEAD
func (r *Repository) ReadFile(path string) ([]byte, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // First try to read from working directory
        content, err := r.worktree.ReadFile(path)
        if err == nil </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        // Check if the file has been explicitly removed
        <span class="cov0" title="0">if r.staging.IsRemoved(path) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", path)
        }</span>

        // If not in working directory and not removed, try to read from HEAD
        <span class="cov0" title="0">headHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Get the commit
        <span class="cov0" title="0">commit, err := r.store.GetCommit(headHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit: %w", err)
        }</span>

        // Get the tree
        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tree: %w", err)
        }</span>

        // Find the file in the tree
        <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                if entry.Name == path </span><span class="cov0" title="0">{
                        blob, err := r.store.GetBlob(entry.Hash)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get blob: %w", err)
                        }</span>
                        <span class="cov0" title="0">return blob.Content, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("file not found: %s", path)</span>
}

// ListFiles lists all files that are currently accessible (working directory + HEAD - removed files)
func (r *Repository) ListFiles() ([]string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Start with files from working directory
        files := make(map[string]bool)
        worktreeFiles := r.worktree.ListFiles()
        for _, file := range worktreeFiles </span><span class="cov0" title="0">{
                files[file] = true
        }</span>

        // Add files from HEAD that haven't been explicitly removed
        <span class="cov0" title="0">headHash, err := r.refManager.GetHEAD()
        if err == nil </span><span class="cov0" title="0">{
                commit, err := r.store.GetCommit(headHash)
                if err == nil </span><span class="cov0" title="0">{
                        tree, err := r.store.GetTree(commit.TreeHash)
                        if err == nil </span><span class="cov0" title="0">{
                                for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                                        // Only add if not explicitly removed and not already in worktree
                                        if !r.staging.IsRemoved(entry.Name) </span><span class="cov0" title="0">{
                                                files[entry.Name] = true
                                        }</span>
                                }
                        }
                }
        }

        // Convert to slice
        <span class="cov0" title="0">result := make([]string, 0, len(files))
        for file := range files </span><span class="cov0" title="0">{
                result = append(result, file)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Remove removes a file from the staging area and working directory
func (r *Repository) Remove(path string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Remove from staging
        r.staging.Remove(path)

        // Also remove from working directory
        return r.worktree.RemoveFile(path)
}</span>

// WriteFile writes a file to the worktree
func (r *Repository) WriteFile(path string, content []byte) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        return r.worktree.WriteFile(path, content)
}</span>

// Diff generates a diff between two commits or refs
func (r *Repository) Diff(from, to, format string) (string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Resolve refs to commit hashes
        fromHash, err := r.resolveRef(from)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve 'from' ref: %w", err)
        }</span>

        <span class="cov0" title="0">toHash, err := r.resolveRef(to)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve 'to' ref: %w", err)
        }</span>

        // Get the commits
        <span class="cov0" title="0">fromCommit, err := r.store.GetCommit(fromHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get 'from' commit: %w", err)
        }</span>

        <span class="cov0" title="0">toCommit, err := r.store.GetCommit(toHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get 'to' commit: %w", err)
        }</span>

        // Get the trees
        <span class="cov0" title="0">fromTree, err := r.store.GetTree(fromCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get 'from' tree: %w", err)
        }</span>

        <span class="cov0" title="0">toTree, err := r.store.GetTree(toCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get 'to' tree: %w", err)
        }</span>

        // Generate diff based on format
        <span class="cov0" title="0">switch format </span>{
        case "unified":<span class="cov0" title="0">
                return r.generateUnifiedDiff(fromTree, toTree, fromHash, toHash)</span>
        case "raw":<span class="cov0" title="0">
                return r.generateRawDiff(fromTree, toTree)</span>
        case "name-only":<span class="cov0" title="0">
                return r.generateNameOnlyDiff(fromTree, toTree)</span>
        default:<span class="cov0" title="0">
                return r.generateUnifiedDiff(fromTree, toTree, fromHash, toHash)</span>
        }
}

// DiffFile generates a diff for a specific file between two commits
func (r *Repository) DiffFile(from, to, filePath string) (string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Resolve refs to commit hashes
        fromHash, err := r.resolveRef(from)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve 'from' ref: %w", err)
        }</span>

        <span class="cov0" title="0">toHash, err := r.resolveRef(to)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve 'to' ref: %w", err)
        }</span>

        // Get the file content from both commits
        <span class="cov0" title="0">fromContent, err := r.getFileAtCommit(fromHash, filePath)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file from 'from' commit: %w", err)
        }</span>

        <span class="cov0" title="0">toContent, err := r.getFileAtCommit(toHash, filePath)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file from 'to' commit: %w", err)
        }</span>

        // Generate unified diff for the file
        <span class="cov0" title="0">return generateFileDiff(filePath, fromContent, toContent), nil</span>
}

// FileDiffInfo represents changes to a single file
type FileDiffInfo struct {
        Path      string
        OldPath   string
        Status    string // added, modified, deleted, renamed
        Additions int
        Deletions int
        Patch     string
}

// WorkingDiffInfo represents staged and unstaged changes
type WorkingDiffInfo struct {
        Staged   []FileDiffInfo
        Unstaged []FileDiffInfo
}

// DiffWorking generates diff between HEAD and working directory
func (r *Repository) DiffWorking() (*WorkingDiffInfo, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Get current HEAD
        headHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Get HEAD commit and tree
        <span class="cov0" title="0">headCommit, err := r.store.GetCommit(headHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD commit: %w", err)
        }</span>

        <span class="cov0" title="0">headTree, err := r.store.GetTree(headCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD tree: %w", err)
        }</span>

        // Build map of files in HEAD
        <span class="cov0" title="0">headFiles := make(map[string]string)
        for _, entry := range headTree.Entries </span><span class="cov0" title="0">{
                headFiles[entry.Name] = entry.Hash
        }</span>

        // Get staged files
        <span class="cov0" title="0">stagedDiffs := []FileDiffInfo{}
        r.staging.ForEach(func(path, hash string) </span><span class="cov0" title="0">{
                oldHash, exists := headFiles[path]
                status := "modified"
                if !exists </span><span class="cov0" title="0">{
                        status = "added"
                }</span>

                // Get content for diff
                <span class="cov0" title="0">var oldContent, newContent []byte
                if exists </span><span class="cov0" title="0">{
                        if blob, err := r.store.GetBlob(oldHash); err == nil </span><span class="cov0" title="0">{
                                oldContent = blob.Content
                        }</span>
                }
                <span class="cov0" title="0">if blob, err := r.store.GetBlob(hash); err == nil </span><span class="cov0" title="0">{
                        newContent = blob.Content
                }</span>

                <span class="cov0" title="0">patch := generateFileDiff(path, oldContent, newContent)
                additions, deletions := countChanges(patch)

                stagedDiffs = append(stagedDiffs, FileDiffInfo{
                        Path:      path,
                        Status:    status,
                        Additions: additions,
                        Deletions: deletions,
                        Patch:     patch,
                })</span>
        })

        // For unstaged changes, we'd need to compare working directory with staging
        // This is simplified for now
        <span class="cov0" title="0">unstagedDiffs := []FileDiffInfo{}

        return &amp;WorkingDiffInfo{
                Staged:   stagedDiffs,
                Unstaged: unstagedDiffs,
        }, nil</span>
}

// Helper method to get file content at a specific commit
func (r *Repository) getFileAtCommit(commitHash, filePath string) ([]byte, error) <span class="cov0" title="0">{
        commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                if entry.Name == filePath </span><span class="cov0" title="0">{
                        blob, err := r.store.GetBlob(entry.Hash)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return blob.Content, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("file not found: %s", filePath)</span>
}

// Generate unified diff between two trees
func (r *Repository) generateUnifiedDiff(fromTree, toTree *object.Tree, fromRef, toRef string) (string, error) <span class="cov0" title="0">{
        var diff strings.Builder

        // Create maps for easy lookup
        fromFiles := make(map[string]string)
        for _, entry := range fromTree.Entries </span><span class="cov0" title="0">{
                fromFiles[entry.Name] = entry.Hash
        }</span>

        <span class="cov0" title="0">toFiles := make(map[string]string)
        for _, entry := range toTree.Entries </span><span class="cov0" title="0">{
                toFiles[entry.Name] = entry.Hash
        }</span>

        // Find all unique files
        <span class="cov0" title="0">allFiles := make(map[string]bool)
        for name := range fromFiles </span><span class="cov0" title="0">{
                allFiles[name] = true
        }</span>
        <span class="cov0" title="0">for name := range toFiles </span><span class="cov0" title="0">{
                allFiles[name] = true
        }</span>

        // Generate diff for each file
        <span class="cov0" title="0">for path := range allFiles </span><span class="cov0" title="0">{
                fromHash, inFrom := fromFiles[path]
                toHash, inTo := toFiles[path]

                // Skip if file unchanged
                if inFrom &amp;&amp; inTo &amp;&amp; fromHash == toHash </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get file contents
                <span class="cov0" title="0">var fromContent, toContent []byte
                if inFrom </span><span class="cov0" title="0">{
                        if blob, err := r.store.GetBlob(fromHash); err == nil </span><span class="cov0" title="0">{
                                fromContent = blob.Content
                        }</span>
                }
                <span class="cov0" title="0">if inTo </span><span class="cov0" title="0">{
                        if blob, err := r.store.GetBlob(toHash); err == nil </span><span class="cov0" title="0">{
                                toContent = blob.Content
                        }</span>
                }

                // Add file diff
                <span class="cov0" title="0">diff.WriteString(fmt.Sprintf("diff --git a/%s b/%s\n", path, path))
                if !inFrom </span><span class="cov0" title="0">{
                        diff.WriteString("new file mode 100644\n")
                }</span> else<span class="cov0" title="0"> if !inTo </span><span class="cov0" title="0">{
                        diff.WriteString("deleted file mode 100644\n")
                }</span>
                <span class="cov0" title="0">diff.WriteString(fmt.Sprintf("--- a/%s\n", path))
                diff.WriteString(fmt.Sprintf("+++ b/%s\n", path))
                diff.WriteString(generateFileDiff(path, fromContent, toContent))
                diff.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return diff.String(), nil</span>
}

// Generate raw diff format
func (r *Repository) generateRawDiff(fromTree, toTree *object.Tree) (string, error) <span class="cov0" title="0">{
        var diff strings.Builder

        // Create maps for easy lookup
        fromFiles := make(map[string]string)
        for _, entry := range fromTree.Entries </span><span class="cov0" title="0">{
                fromFiles[entry.Name] = entry.Hash
        }</span>

        <span class="cov0" title="0">toFiles := make(map[string]string)
        for _, entry := range toTree.Entries </span><span class="cov0" title="0">{
                toFiles[entry.Name] = entry.Hash
        }</span>

        // Check all files
        <span class="cov0" title="0">for path, fromHash := range fromFiles </span><span class="cov0" title="0">{
                if toHash, exists := toFiles[path]; exists </span><span class="cov0" title="0">{
                        if fromHash != toHash </span><span class="cov0" title="0">{
                                diff.WriteString(fmt.Sprintf("M\t%s\n", path))
                        }</span>
                } else<span class="cov0" title="0"> {
                        diff.WriteString(fmt.Sprintf("D\t%s\n", path))
                }</span>
        }

        <span class="cov0" title="0">for path := range toFiles </span><span class="cov0" title="0">{
                if _, exists := fromFiles[path]; !exists </span><span class="cov0" title="0">{
                        diff.WriteString(fmt.Sprintf("A\t%s\n", path))
                }</span>
        }

        <span class="cov0" title="0">return diff.String(), nil</span>
}

// Generate name-only diff
func (r *Repository) generateNameOnlyDiff(fromTree, toTree *object.Tree) (string, error) <span class="cov0" title="0">{
        var diff strings.Builder

        // Create maps for easy lookup
        fromFiles := make(map[string]string)
        for _, entry := range fromTree.Entries </span><span class="cov0" title="0">{
                fromFiles[entry.Name] = entry.Hash
        }</span>

        <span class="cov0" title="0">toFiles := make(map[string]string)
        for _, entry := range toTree.Entries </span><span class="cov0" title="0">{
                toFiles[entry.Name] = entry.Hash
        }</span>

        // Find changed files
        <span class="cov0" title="0">changed := make(map[string]bool)
        for path, fromHash := range fromFiles </span><span class="cov0" title="0">{
                if toHash, exists := toFiles[path]; !exists || fromHash != toHash </span><span class="cov0" title="0">{
                        changed[path] = true
                }</span>
        }
        <span class="cov0" title="0">for path := range toFiles </span><span class="cov0" title="0">{
                if _, exists := fromFiles[path]; !exists </span><span class="cov0" title="0">{
                        changed[path] = true
                }</span>
        }

        // Output sorted file names
        <span class="cov0" title="0">for path := range changed </span><span class="cov0" title="0">{
                diff.WriteString(path + "\n")
        }</span>

        <span class="cov0" title="0">return diff.String(), nil</span>
}

// Simple diff generator for file content
func generateFileDiff(path string, oldContent, newContent []byte) string <span class="cov0" title="0">{
        if len(oldContent) == 0 &amp;&amp; len(newContent) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">oldLines := strings.Split(string(oldContent), "\n")
        newLines := strings.Split(string(newContent), "\n")

        var diff strings.Builder
        diff.WriteString("@@ -1," + fmt.Sprintf("%d", len(oldLines)) + " +1," + fmt.Sprintf("%d", len(newLines)) + " @@\n")

        // Simple line-by-line diff (not a real diff algorithm)
        maxLines := len(oldLines)
        if len(newLines) &gt; maxLines </span><span class="cov0" title="0">{
                maxLines = len(newLines)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; maxLines; i++ </span><span class="cov0" title="0">{
                if i &lt; len(oldLines) &amp;&amp; i &lt; len(newLines) </span><span class="cov0" title="0">{
                        if oldLines[i] != newLines[i] </span><span class="cov0" title="0">{
                                diff.WriteString("-" + oldLines[i] + "\n")
                                diff.WriteString("+" + newLines[i] + "\n")
                        }</span> else<span class="cov0" title="0"> {
                                diff.WriteString(" " + oldLines[i] + "\n")
                        }</span>
                } else<span class="cov0" title="0"> if i &lt; len(oldLines) </span><span class="cov0" title="0">{
                        diff.WriteString("-" + oldLines[i] + "\n")
                }</span> else<span class="cov0" title="0"> if i &lt; len(newLines) </span><span class="cov0" title="0">{
                        diff.WriteString("+" + newLines[i] + "\n")
                }</span>
        }

        <span class="cov0" title="0">return diff.String()</span>
}

// Count additions and deletions in a patch
func countChanges(patch string) (additions, deletions int) <span class="cov0" title="0">{
        lines := strings.Split(patch, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "+") &amp;&amp; !strings.HasPrefix(line, "+++") </span><span class="cov0" title="0">{
                        additions++
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(line, "-") &amp;&amp; !strings.HasPrefix(line, "---") </span><span class="cov0" title="0">{
                        deletions++
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// BlameInfo contains blame information for a file
type BlameInfo struct {
        Path  string
        Ref   string
        Lines []BlameLineInfo
        Total int
}

// BlameLineInfo contains blame info for a single line
type BlameLineInfo struct {
        LineNumber int
        Content    string
        CommitHash string
        Author     string
        Email      string
        Timestamp  time.Time
        Message    string
}

// Blame generates line-by-line authorship information for a file
func (r *Repository) Blame(filePath, ref string) (*BlameInfo, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Resolve the ref
        targetHash, err := r.resolveRef(ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve ref '%s': %w", ref, err)
        }</span>

        // Get the file content at the target commit
        <span class="cov0" title="0">content, err := r.getFileAtCommit(targetHash, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Split content into lines
        <span class="cov0" title="0">contentStr := string(content)
        // Handle empty content
        if contentStr == "" </span><span class="cov0" title="0">{
                contentStr = " " // Single empty line
        }</span>
        <span class="cov0" title="0">lines := strings.Split(contentStr, "\n")
        blameLines := make([]BlameLineInfo, 0, len(lines))

        // For a simple implementation, we'll attribute all lines to the last commit
        // that modified the file. A full implementation would track line-by-line changes.
        lastCommitHash, lastCommit, err := r.findLastCommitForFile(filePath, targetHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find commit history for file: %w", err)
        }</span>

        // Create blame info for each line
        <span class="cov0" title="0">for i, line := range lines </span><span class="cov0" title="0">{
                blameLines = append(blameLines, BlameLineInfo{
                        LineNumber: i + 1,
                        Content:    line,
                        CommitHash: lastCommitHash,
                        Author:     lastCommit.Author.Name,
                        Email:      lastCommit.Author.Email,
                        Timestamp:  lastCommit.Author.Time,
                        Message:    strings.TrimSpace(lastCommit.Message),
                })
        }</span>

        <span class="cov0" title="0">return &amp;BlameInfo{
                Path:  filePath,
                Ref:   ref,
                Lines: blameLines,
                Total: len(blameLines),
        }, nil</span>
}

// findLastCommitForFile finds the most recent commit that modified a file
func (r *Repository) findLastCommitForFile(filePath, startHash string) (string, *object.Commit, error) <span class="cov0" title="0">{
        // Walk back through commit history
        currentHash := startHash

        for currentHash != "" </span><span class="cov0" title="0">{
                commit, err := r.store.GetCommit(currentHash)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>

                // Check if this commit contains the file
                <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>

                <span class="cov0" title="0">hasFile := false
                for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                        if entry.Name == filePath </span><span class="cov0" title="0">{
                                hasFile = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if hasFile </span><span class="cov0" title="0">{
                        // Check if this is the commit that last modified the file
                        // For simplicity, we'll return the first commit we find with the file
                        // A full implementation would check if the file content changed
                        return currentHash, commit, nil
                }</span>

                // Move to parent commit
                <span class="cov0" title="0">currentHash = commit.ParentHash</span>
        }

        <span class="cov0" title="0">return "", nil, fmt.Errorf("file not found in commit history")</span>
}

// Stash saves the current working directory and staging area state
func (r *Repository) Stash(message string, includeUntracked bool) (*Stash, error) <span class="cov0" title="0">{
        // Get author info before locking
        authorName := r.getConfigValue("user.name", "Unknown")
        authorEmail := r.getConfigValue("user.email", "unknown@example.com")

        r.mu.Lock()
        defer r.mu.Unlock()

        // Get current HEAD commit (may be empty for new repos)
        headHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                // If there's no HEAD yet (new repo), use empty string
                headHash = ""
        }</span>

        // Get status to find files to stash
        // We need to get status without locking since we already hold the lock
        <span class="cov0" title="0">status := &amp;Status{
                Branch:    r.getCurrentBranchName(),
                Staged:    r.staging.List(),
                Modified:  []string{},
                Untracked: []string{},
        }

        // Get modified and untracked files
        if r.worktree != nil </span><span class="cov0" title="0">{
                // Get all files in working directory
                workFiles, err := r.worktree.MatchFiles("*")
                if err == nil </span><span class="cov0" title="0">{
                        for _, file := range workFiles </span><span class="cov0" title="0">{
                                // Check if file is tracked
                                isTracked := false
                                if headHash != "" </span><span class="cov0" title="0">{
                                        commit, err := r.store.GetCommit(headHash)
                                        if err == nil </span><span class="cov0" title="0">{
                                                tree, err := r.store.GetTree(commit.TreeHash)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                                                                if entry.Name == file </span><span class="cov0" title="0">{
                                                                        isTracked = true
                                                                        // Check if modified
                                                                        workContent, err := r.worktree.ReadFile(file)
                                                                        if err == nil </span><span class="cov0" title="0">{
                                                                                blob, err := r.store.GetBlob(entry.Hash)
                                                                                if err == nil &amp;&amp; string(workContent) != string(blob.Content) </span><span class="cov0" title="0">{
                                                                                        status.Modified = append(status.Modified, file)
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">break</span>
                                                                }
                                                        }
                                                }
                                        }
                                }

                                <span class="cov0" title="0">if !isTracked </span><span class="cov0" title="0">{
                                        // Check if it's staged
                                        isStaged := false
                                        for _, staged := range status.Staged </span><span class="cov0" title="0">{
                                                if staged == file </span><span class="cov0" title="0">{
                                                        isStaged = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !isStaged </span><span class="cov0" title="0">{
                                                status.Untracked = append(status.Untracked, file)
                                        }</span>
                                }
                        }
                }
        }

        // Create stash ID
        <span class="cov0" title="0">stashID := fmt.Sprintf("stash@{%d}", len(r.stashes))

        // Save staged files
        stagedFiles := make(map[string]string)
        for _, path := range status.Staged </span><span class="cov0" title="0">{
                if hash, exists := r.staging.GetHash(path); exists </span><span class="cov0" title="0">{
                        stagedFiles[path] = hash
                }</span>
        }

        // Save working directory files
        <span class="cov0" title="0">workingFiles := make(map[string][]byte)

        // Add modified files
        for _, path := range status.Modified </span><span class="cov0" title="0">{
                content, err := r.worktree.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">workingFiles[path] = content</span>
        }

        // Add untracked files if requested
        <span class="cov0" title="0">if includeUntracked </span><span class="cov0" title="0">{
                for _, path := range status.Untracked </span><span class="cov0" title="0">{
                        content, err := r.worktree.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">workingFiles[path] = content</span>
                }
        }

        // Create stash object
        <span class="cov0" title="0">stash := &amp;Stash{
                ID:      stashID,
                Message: message,
                Author: object.Author{
                        Name:  authorName,
                        Email: authorEmail,
                        Time:  time.Now(),
                },
                ParentCommit: headHash,
                StagedFiles:  stagedFiles,
                WorkingFiles: workingFiles,
                Timestamp:    time.Now(),
        }

        // Add to stash list
        r.stashes = append(r.stashes, stash)

        // Clear staging area and reset working directory
        r.staging = NewStagingArea()

        // Reset modified files to HEAD state
        if headHash != "" </span><span class="cov0" title="0">{
                commit, err := r.store.GetCommit(headHash)
                if err == nil </span><span class="cov0" title="0">{
                        tree, err := r.store.GetTree(commit.TreeHash)
                        if err == nil </span><span class="cov0" title="0">{
                                // Create map of tree entries for faster lookup
                                treeFiles := make(map[string]*object.TreeEntry)
                                for i := range tree.Entries </span><span class="cov0" title="0">{
                                        treeFiles[tree.Entries[i].Name] = &amp;tree.Entries[i]
                                }</span>

                                // Reset all modified files to their HEAD state
                                <span class="cov0" title="0">for _, path := range status.Modified </span><span class="cov0" title="0">{
                                        if entry, exists := treeFiles[path]; exists </span><span class="cov0" title="0">{
                                                blob, err := r.store.GetBlob(entry.Hash)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        r.worktree.WriteFile(path, blob.Content)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Remove untracked files if they were included in the stash
        <span class="cov0" title="0">if includeUntracked </span><span class="cov0" title="0">{
                for _, path := range status.Untracked </span><span class="cov0" title="0">{
                        r.worktree.RemoveFile(path)
                }</span>
        }

        <span class="cov0" title="0">return stash, nil</span>
}

// ListStashes returns all stashes
func (r *Repository) ListStashes() []*Stash <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        result := make([]*Stash, len(r.stashes))
        copy(result, r.stashes)
        return result
}</span>

// GetStash returns a stash by ID
func (r *Repository) GetStash(stashID string) (*Stash, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        for _, stash := range r.stashes </span><span class="cov0" title="0">{
                if stash.ID == stashID </span><span class="cov0" title="0">{
                        return stash, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("stash not found: %s", stashID)</span>
}

// ApplyStash applies a stash to the working directory
func (r *Repository) ApplyStash(stashID string, drop bool) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Find stash
        var stashIndex int = -1
        var stash *Stash
        for i, s := range r.stashes </span><span class="cov0" title="0">{
                if s.ID == stashID </span><span class="cov0" title="0">{
                        stashIndex = i
                        stash = s
                        break</span>
                }
        }

        <span class="cov0" title="0">if stash == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stash not found: %s", stashID)
        }</span>

        // Apply staged files
        <span class="cov0" title="0">for path, hash := range stash.StagedFiles </span><span class="cov0" title="0">{
                r.staging.SetFile(path, hash)
        }</span>

        // Apply working directory files
        <span class="cov0" title="0">for path, content := range stash.WorkingFiles </span><span class="cov0" title="0">{
                if err := r.worktree.WriteFile(path, content); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to restore file %s: %w", path, err)
                }</span>
        }

        // Drop stash if requested
        <span class="cov0" title="0">if drop &amp;&amp; stashIndex != -1 </span><span class="cov0" title="0">{
                r.stashes = append(r.stashes[:stashIndex], r.stashes[stashIndex+1:]...)

                // Renumber remaining stashes
                for i := stashIndex; i &lt; len(r.stashes); i++ </span><span class="cov0" title="0">{
                        r.stashes[i].ID = fmt.Sprintf("stash@{%d}", i)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DropStash removes a stash from the list
func (r *Repository) DropStash(stashID string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        for i, stash := range r.stashes </span><span class="cov0" title="0">{
                if stash.ID == stashID </span><span class="cov0" title="0">{
                        r.stashes = append(r.stashes[:i], r.stashes[i+1:]...)

                        // Renumber remaining stashes
                        for j := i; j &lt; len(r.stashes); j++ </span><span class="cov0" title="0">{
                                r.stashes[j].ID = fmt.Sprintf("stash@{%d}", j)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("stash not found: %s", stashID)</span>
}

// CherryPick applies the changes from a specific commit to the current branch
func (r *Repository) CherryPick(commitHash string) (*object.Commit, error) <span class="cov0" title="0">{
        // Get author info before locking
        authorName := r.getConfigValue("user.name", "Unknown")
        authorEmail := r.getConfigValue("user.email", "unknown@example.com")

        r.mu.Lock()
        defer r.mu.Unlock()

        // Resolve the commit hash
        targetHash, err := r.resolveRef(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("commit not found: %s", commitHash)
        }</span>

        // Get the commit to cherry-pick
        <span class="cov0" title="0">commit, err := r.store.GetCommit(targetHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit: %w", err)
        }</span>

        // Get the parent commit to calculate changes
        <span class="cov0" title="0">if commit.ParentHash == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot cherry-pick root commit")
        }</span>

        <span class="cov0" title="0">parentCommit, err := r.store.GetCommit(commit.ParentHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get parent commit: %w", err)
        }</span>

        // Get trees for both commits
        <span class="cov0" title="0">commitTree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit tree: %w", err)
        }</span>

        <span class="cov0" title="0">parentTree, err := r.store.GetTree(parentCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get parent tree: %w", err)
        }</span>

        // Calculate changes between parent and commit
        <span class="cov0" title="0">changes := make(map[string]string) // path -&gt; hash

        // Find files that were added or modified
        for _, entry := range commitTree.Entries </span><span class="cov0" title="0">{
                found := false
                for _, parentEntry := range parentTree.Entries </span><span class="cov0" title="0">{
                        if parentEntry.Name == entry.Name </span><span class="cov0" title="0">{
                                found = true
                                if parentEntry.Hash != entry.Hash </span><span class="cov0" title="0">{
                                        // File was modified
                                        changes[entry.Name] = entry.Hash
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // File was added
                        changes[entry.Name] = entry.Hash
                }</span>
        }

        // Apply changes to staging area
        <span class="cov0" title="0">for path, hash := range changes </span><span class="cov0" title="0">{
                r.staging.Add(path, hash)

                // Also update working directory if not memory-based
                if r.worktree.path != ":memory:" </span><span class="cov0" title="0">{
                        blob, err := r.store.GetBlob(hash)
                        if err == nil </span><span class="cov0" title="0">{
                                r.worktree.WriteFile(path, blob.Content)
                        }</span>
                }
        }

        // Create a new commit with cherry-pick message
        <span class="cov0" title="0">message := fmt.Sprintf("Cherry-pick: %s\n\n%s\n\n(cherry picked from commit %s)",
                strings.Split(commit.Message, "\n")[0], // First line of original message
                commit.Message,
                targetHash[:8])

        // Create the commit with current user as author
        newCommit := &amp;object.Commit{
                TreeHash:   "", // Will be set by commit process
                ParentHash: "", // Will be set by commit process
                Author: object.Author{
                        Name:  authorName,
                        Email: authorEmail,
                        Time:  time.Now(),
                },
                Committer: object.Author{
                        Name:  authorName,
                        Email: authorEmail,
                        Time:  time.Now(),
                },
                Message: message,
        }

        // Use internal commit method to avoid deadlock
        return r.commitInternal(newCommit)</span>
}

// Revert creates a new commit that undoes the changes from a specific commit
func (r *Repository) Revert(commitHash string) (*object.Commit, error) <span class="cov0" title="0">{
        // Get author info before locking
        authorName := r.getConfigValue("user.name", "Unknown")
        authorEmail := r.getConfigValue("user.email", "unknown@example.com")

        r.mu.Lock()
        defer r.mu.Unlock()

        // Resolve the commit hash
        targetHash, err := r.resolveRef(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("commit not found: %s", commitHash)
        }</span>

        // Get the commit to revert
        <span class="cov0" title="0">commit, err := r.store.GetCommit(targetHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit: %w", err)
        }</span>

        // Get the parent commit to understand what to revert to
        <span class="cov0" title="0">if commit.ParentHash == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot revert root commit")
        }</span>

        <span class="cov0" title="0">parentCommit, err := r.store.GetCommit(commit.ParentHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get parent commit: %w", err)
        }</span>

        // Get trees for both commits
        <span class="cov0" title="0">commitTree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get commit tree: %w", err)
        }</span>

        <span class="cov0" title="0">parentTree, err := r.store.GetTree(parentCommit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get parent tree: %w", err)
        }</span>

        // Calculate reverse changes (undo what the commit did)
        // Find files that were added (need to remove)
        <span class="cov0" title="0">for _, entry := range commitTree.Entries </span><span class="cov0" title="0">{
                found := false
                for _, parentEntry := range parentTree.Entries </span><span class="cov0" title="0">{
                        if parentEntry.Name == entry.Name </span><span class="cov0" title="0">{
                                found = true
                                if parentEntry.Hash != entry.Hash </span><span class="cov0" title="0">{
                                        // File was modified - revert to parent version
                                        r.staging.Add(entry.Name, parentEntry.Hash)

                                        // Update working directory
                                        blob, err := r.store.GetBlob(parentEntry.Hash)
                                        if err == nil </span><span class="cov0" title="0">{
                                                r.worktree.WriteFile(entry.Name, blob.Content)
                                        }</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // File was added in this commit - remove it
                        r.staging.Remove(entry.Name)
                        r.worktree.RemoveFile(entry.Name)
                }</span>
        }

        // Find files that were removed (need to restore)
        <span class="cov0" title="0">for _, parentEntry := range parentTree.Entries </span><span class="cov0" title="0">{
                found := false
                for _, entry := range commitTree.Entries </span><span class="cov0" title="0">{
                        if entry.Name == parentEntry.Name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // File was removed in this commit - restore it
                        r.staging.Add(parentEntry.Name, parentEntry.Hash)

                        // Update working directory
                        blob, err := r.store.GetBlob(parentEntry.Hash)
                        if err == nil </span><span class="cov0" title="0">{
                                r.worktree.WriteFile(parentEntry.Name, blob.Content)
                        }</span>
                }
        }

        // Create a revert commit message
        <span class="cov0" title="0">message := fmt.Sprintf("Revert \"%s\"\n\nThis reverts commit %s.",
                strings.Split(commit.Message, "\n")[0], // First line of original message
                targetHash[:8])

        // Create the commit
        newCommit := &amp;object.Commit{
                TreeHash:   "", // Will be set by commit process
                ParentHash: "", // Will be set by commit process
                Author: object.Author{
                        Name:  authorName,
                        Email: authorEmail,
                        Time:  time.Now(),
                },
                Committer: object.Author{
                        Name:  authorName,
                        Email: authorEmail,
                        Time:  time.Now(),
                },
                Message: message,
        }

        // Use internal commit method to avoid deadlock
        return r.commitInternal(newCommit)</span>
}

// commitInternal is an internal version of Commit that assumes the lock is already held
func (r *Repository) commitInternal(commit *object.Commit) (*object.Commit, error) <span class="cov0" title="0">{
        // Get current HEAD
        currentHash, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                // First commit - no parent
                currentHash = ""
        }</span>

        // Create tree from staging
        <span class="cov0" title="0">entries := make([]object.TreeEntry, 0)
        for path, hash := range r.staging.GetFiles() </span><span class="cov0" title="0">{
                entries = append(entries, object.TreeEntry{
                        Mode: "100644",
                        Hash: hash,
                        Name: path,
                })
        }</span>

        <span class="cov0" title="0">tree := &amp;object.Tree{Entries: entries}
        treeHash, err := r.store.StoreTree(tree)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store tree: %w", err)
        }</span>

        // Update commit fields
        <span class="cov0" title="0">commit.TreeHash = treeHash
        commit.ParentHash = currentHash

        // Store commit
        commitHash, err := r.store.StoreCommit(commit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store commit: %w", err)
        }</span>

        // Update HEAD
        <span class="cov0" title="0">if err := r.refManager.SetHEAD(commitHash); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update HEAD: %w", err)
        }</span>

        // Clear staging area
        <span class="cov0" title="0">r.staging.Clear()

        return commit, nil</span>
}

// Reset moves the current branch pointer to a specific commit
func (r *Repository) Reset(target string, mode string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Default to mixed mode if not specified
        if mode == "" </span><span class="cov0" title="0">{
                mode = "mixed"
        }</span>

        // Validate mode
        <span class="cov0" title="0">if mode != "soft" &amp;&amp; mode != "mixed" &amp;&amp; mode != "hard" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid reset mode: %s (must be soft, mixed, or hard)", mode)
        }</span>

        // Resolve the target commit
        <span class="cov0" title="0">targetHash, err := r.resolveRef(target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve target: %w", err)
        }</span>

        // Verify the commit exists
        <span class="cov0" title="0">_, err = r.store.GetCommit(targetHash)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("target commit not found: %s", target)
        }</span>

        // Update HEAD to point to the target commit
        <span class="cov0" title="0">if err := r.refManager.SetHEAD(targetHash); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update HEAD: %w", err)
        }</span>

        // Handle different reset modes
        <span class="cov0" title="0">switch mode </span>{
        case "soft":<span class="cov0" title="0"></span>
                // Soft reset: only move HEAD, keep staging and working directory
                // Nothing more to do

        case "mixed":<span class="cov0" title="0">
                // Mixed reset: move HEAD and clear staging, keep working directory
                r.staging.Clear()</span>

        case "hard":<span class="cov0" title="0">
                // Hard reset: move HEAD, clear staging, and reset working directory
                r.staging.Clear()

                // Reset working directory to match the target commit
                commit, _ := r.store.GetCommit(targetHash)
                if commit != nil </span><span class="cov0" title="0">{
                        tree, err := r.store.GetTree(commit.TreeHash)
                        if err == nil </span><span class="cov0" title="0">{
                                // Clear working directory first
                                currentFiles := r.worktree.ListFiles()
                                for _, file := range currentFiles </span><span class="cov0" title="0">{
                                        r.worktree.RemoveFile(file)
                                }</span>

                                // Restore files from the target commit
                                <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                                        blob, err := r.store.GetBlob(entry.Hash)
                                        if err == nil </span><span class="cov0" title="0">{
                                                r.worktree.WriteFile(entry.Name, blob.Content)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Rebase replays commits from the current branch onto another branch
func (r *Repository) Rebase(onto string) ([]string, error) <span class="cov0" title="0">{
        // Get author info before locking
        authorName := r.getConfigValue("user.name", "Unknown")
        authorEmail := r.getConfigValue("user.email", "unknown@example.com")

        r.mu.Lock()
        defer r.mu.Unlock()

        // Get current branch
        currentBranch, err := r.refManager.GetCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not on a branch")
        }</span>

        // Get current HEAD
        <span class="cov0" title="0">currentHead, err := r.refManager.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get HEAD: %w", err)
        }</span>

        // Resolve the onto ref
        <span class="cov0" title="0">ontoHash, err := r.resolveRef(onto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve onto ref: %w", err)
        }</span>

        // Find common ancestor
        <span class="cov0" title="0">commonAncestor := r.findCommonAncestor(currentHead, ontoHash)
        if commonAncestor == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no common ancestor found")
        }</span>

        // If already up to date
        <span class="cov0" title="0">if commonAncestor == currentHead </span><span class="cov0" title="0">{
                return []string{}, nil // No commits to rebase
        }</span>

        // Collect commits to rebase (from common ancestor to current HEAD)
        <span class="cov0" title="0">commitsToRebase, err := r.collectCommitsBetween(commonAncestor, currentHead)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect commits: %w", err)
        }</span>

        // Checkout onto commit
        <span class="cov0" title="0">if err := r.refManager.SetHEAD(ontoHash); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to checkout onto commit: %w", err)
        }</span>

        // Clear staging area
        <span class="cov0" title="0">r.staging.Clear()

        // Replay each commit
        rebasedCommits := make([]string, 0, len(commitsToRebase))

        for _, commitHash := range commitsToRebase </span><span class="cov0" title="0">{
                commit, err := r.store.GetCommit(commitHash)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get the changes from this commit
                <span class="cov0" title="0">if commit.ParentHash != "" </span><span class="cov0" title="0">{
                        _, err := r.store.GetCommit(commit.ParentHash)
                        if err == nil </span><span class="cov0" title="0">{
                                tree, err := r.store.GetTree(commit.TreeHash)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Apply changes from this commit
                                        for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                                                r.staging.Add(entry.Name, entry.Hash)

                                                // Update working directory
                                                if r.worktree.path != ":memory:" </span><span class="cov0" title="0">{
                                                        blob, err := r.store.GetBlob(entry.Hash)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                r.worktree.WriteFile(entry.Name, blob.Content)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }

                // Create new commit with same message but new parent
                <span class="cov0" title="0">newCommit := &amp;object.Commit{
                        TreeHash:   "", // Will be set by commitInternal
                        ParentHash: "", // Will be set by commitInternal
                        Author: object.Author{
                                Name:  authorName,
                                Email: authorEmail,
                                Time:  time.Now(),
                        },
                        Committer: object.Author{
                                Name:  authorName,
                                Email: authorEmail,
                                Time:  time.Now(),
                        },
                        Message: commit.Message,
                }

                rebasedCommit, err := r.commitInternal(newCommit)
                if err != nil </span><span class="cov0" title="0">{
                        // Rebase failed, should handle conflicts in real implementation
                        return rebasedCommits, fmt.Errorf("failed to rebase commit %s: %w", commitHash[:8], err)
                }</span>

                <span class="cov0" title="0">rebasedCommits = append(rebasedCommits, rebasedCommit.Hash())</span>
        }

        // Update the original branch to point to the new HEAD
        <span class="cov0" title="0">newHead, _ := r.refManager.GetHEAD()
        // Delete and recreate the branch at the new position
        r.refManager.DeleteBranch(currentBranch)
        if err := r.refManager.CreateBranch(currentBranch, newHead); err != nil </span><span class="cov0" title="0">{
                return rebasedCommits, fmt.Errorf("failed to update branch: %w", err)
        }</span>

        // Checkout the original branch
        <span class="cov0" title="0">if err := r.refManager.SetHEADToBranch(currentBranch); err != nil </span><span class="cov0" title="0">{
                return rebasedCommits, fmt.Errorf("failed to checkout branch: %w", err)
        }</span>

        <span class="cov0" title="0">return rebasedCommits, nil</span>
}

// findCommonAncestor finds the common ancestor between two commits
func (r *Repository) findCommonAncestor(hash1, hash2 string) string <span class="cov0" title="0">{
        // Simple implementation: walk back from hash1 and check if we reach hash2's ancestors
        ancestors1 := make(map[string]bool)

        // Collect all ancestors of hash1
        current := hash1
        for current != "" </span><span class="cov0" title="0">{
                ancestors1[current] = true
                commit, err := r.store.GetCommit(current)
                if err != nil || commit.ParentHash == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">current = commit.ParentHash</span>
        }

        // Walk back from hash2 and find first common ancestor
        <span class="cov0" title="0">current = hash2
        for current != "" </span><span class="cov0" title="0">{
                if ancestors1[current] </span><span class="cov0" title="0">{
                        return current
                }</span>
                <span class="cov0" title="0">commit, err := r.store.GetCommit(current)
                if err != nil || commit.ParentHash == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">current = commit.ParentHash</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// collectCommitsBetween collects all commits between start (exclusive) and end (inclusive)
func (r *Repository) collectCommitsBetween(start, end string) ([]string, error) <span class="cov0" title="0">{
        commits := []string{}
        current := end

        for current != "" &amp;&amp; current != start </span><span class="cov0" title="0">{
                commits = append([]string{current}, commits...) // Prepend to maintain order

                commit, err := r.store.GetCommit(current)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">current = commit.ParentHash</span>
        }

        <span class="cov0" title="0">return commits, nil</span>
}

// Webhook and Event System

type Webhook struct {
        ID           string                `json:"id"`
        URL          string                `json:"url"`
        Events       []string              `json:"events"`
        Secret       string                `json:"secret"`
        ContentType  string                `json:"content_type"`
        Active       bool                  `json:"active"`
        InsecureSSL  bool                  `json:"insecure_ssl"`
        CreatedAt    time.Time             `json:"created_at"`
        UpdatedAt    time.Time             `json:"updated_at"`
        LastDelivery *HookDeliveryInternal `json:"last_delivery,omitempty"`
}

type HookDeliveryInternal struct {
        ID         string    `json:"id"`
        URL        string    `json:"url"`
        Event      string    `json:"event"`
        StatusCode int       `json:"status_code"`
        Duration   int64     `json:"duration_ms"`
        Request    string    `json:"request"`
        Response   string    `json:"response"`
        Delivered  bool      `json:"delivered"`
        CreatedAt  time.Time `json:"created_at"`
}

type RepositoryEvent struct {
        ID         string             `json:"id"`
        Event      string             `json:"event"`
        Repository string             `json:"repository"`
        Timestamp  time.Time          `json:"timestamp"`
        Actor      EventActorInternal `json:"actor"`
        Data       interface{}        `json:"data"`
}

type EventActorInternal struct {
        Name  string `json:"name"`
        Email string `json:"email"`
}

// RegisterWebhook adds a new webhook to the repository
func (r *Repository) RegisterWebhook(url string, events []string, secret, contentType string, active, insecureSSL bool) (*Webhook, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.webhooks == nil </span><span class="cov0" title="0">{
                r.webhooks = make(map[string]*Webhook)
        }</span>

        <span class="cov0" title="0">hookID := uuid.New().String()
        webhook := &amp;Webhook{
                ID:          hookID,
                URL:         url,
                Events:      events,
                Secret:      secret,
                ContentType: contentType,
                Active:      active,
                InsecureSSL: insecureSSL,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }

        r.webhooks[hookID] = webhook
        return webhook, nil</span>
}

// GetWebhook retrieves a webhook by ID
func (r *Repository) GetWebhook(hookID string) (*Webhook, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        webhook, exists := r.webhooks[hookID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("webhook not found: %s", hookID)
        }</span>

        <span class="cov0" title="0">return webhook, nil</span>
}

// ListWebhooks returns all registered webhooks
func (r *Repository) ListWebhooks() ([]*Webhook, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        webhooks := make([]*Webhook, 0, len(r.webhooks))
        for _, hook := range r.webhooks </span><span class="cov0" title="0">{
                webhooks = append(webhooks, hook)
        }</span>

        <span class="cov0" title="0">return webhooks, nil</span>
}

// DeleteWebhook removes a webhook
func (r *Repository) DeleteWebhook(hookID string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.webhooks[hookID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook not found: %s", hookID)
        }</span>

        <span class="cov0" title="0">delete(r.webhooks, hookID)
        return nil</span>
}

// EmitEvent sends an event to all registered webhooks and the event stream
func (r *Repository) EmitEvent(eventType string, data interface{}) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Create event
        event := &amp;RepositoryEvent{
                ID:         uuid.New().String(),
                Event:      eventType,
                Repository: r.path,
                Timestamp:  time.Now(),
                Actor: EventActorInternal{
                        Name:  r.getConfigValue("user.name", "Unknown"),
                        Email: r.getConfigValue("user.email", "unknown@example.com"),
                },
                Data: data,
        }

        // Send to event stream (non-blocking)
        if r.events != nil </span><span class="cov0" title="0">{
                select </span>{
                case r.events &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel full, skip
                }
        }

        // Send to webhooks
        <span class="cov0" title="0">for _, webhook := range r.webhooks </span><span class="cov0" title="0">{
                if webhook.Active &amp;&amp; r.shouldTriggerWebhook(webhook, eventType) </span><span class="cov0" title="0">{
                        go r.deliverWebhook(webhook, event)
                }</span>
        }
}

// shouldTriggerWebhook checks if a webhook should be triggered for an event
func (r *Repository) shouldTriggerWebhook(webhook *Webhook, eventType string) bool <span class="cov0" title="0">{
        for _, subscribedEvent := range webhook.Events </span><span class="cov0" title="0">{
                if subscribedEvent == eventType || subscribedEvent == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// deliverWebhook sends the webhook payload to the registered URL
func (r *Repository) deliverWebhook(webhook *Webhook, event *RepositoryEvent) <span class="cov0" title="0">{
        startTime := time.Now()
        deliveryID := uuid.New().String()

        // Create payload
        payload, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequest("POST", webhook.URL, bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", "govc-webhook/1.0")
        req.Header.Set("X-Govc-Event", event.Event)
        req.Header.Set("X-Govc-Delivery", deliveryID)

        // Add signature if secret is provided
        if webhook.Secret != "" </span><span class="cov0" title="0">{
                signature := r.computeSignature(payload, webhook.Secret)
                req.Header.Set("X-Hub-Signature-256", "sha256="+signature)
        }</span>

        // Create HTTP client
        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        // Make request
        resp, err := client.Do(req)
        duration := time.Since(startTime).Milliseconds()

        delivery := &amp;HookDeliveryInternal{
                ID:        deliveryID,
                URL:       webhook.URL,
                Event:     event.Event,
                Duration:  duration,
                Request:   string(payload),
                CreatedAt: startTime,
        }

        if err != nil </span><span class="cov0" title="0">{
                delivery.Delivered = false
                delivery.Response = err.Error()
                delivery.StatusCode = 0
        }</span> else<span class="cov0" title="0"> {
                delivery.Delivered = true
                delivery.StatusCode = resp.StatusCode
                defer resp.Body.Close()

                responseBody, _ := io.ReadAll(resp.Body)
                delivery.Response = string(responseBody)
        }</span>

        // Update webhook with last delivery info
        <span class="cov0" title="0">r.mu.Lock()
        webhook.LastDelivery = delivery
        webhook.UpdatedAt = time.Now()
        r.mu.Unlock()</span>
}

// computeSignature computes HMAC-SHA256 signature for webhook verification
func (r *Repository) computeSignature(payload []byte, secret string) string <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        return hex.EncodeToString(mac.Sum(nil))
}</span>

// GetEventStream returns the event channel for Server-Sent Events
func (r *Repository) GetEventStream() &lt;-chan *RepositoryEvent <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.events == nil </span><span class="cov0" title="0">{
                r.events = make(chan *RepositoryEvent, 100) // Buffered channel
        }</span>

        <span class="cov0" title="0">return r.events</span>
}

// Search functionality

// SearchCommits searches through commit messages, authors, and emails
func (r *Repository) SearchCommits(query, author, since, until string, limit, offset int) ([]*object.Commit, int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var allCommits []*object.Commit
        var sinceTime, untilTime time.Time
        var err error

        // Parse time filters if provided
        if since != "" </span><span class="cov0" title="0">{
                sinceTime, err = time.Parse(time.RFC3339, since)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("invalid since time: %v", err)
                }</span>
        }
        <span class="cov0" title="0">if until != "" </span><span class="cov0" title="0">{
                untilTime, err = time.Parse(time.RFC3339, until)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("invalid until time: %v", err)
                }</span>
        }

        // Convert query to lowercase for case-insensitive search
        <span class="cov0" title="0">queryLower := strings.ToLower(query)
        authorLower := strings.ToLower(author)

        // Get all commits by walking from all branch heads and HEAD
        visitedCommits := make(map[string]bool)

        // Start with HEAD
        headHash, err := r.refManager.GetHEAD()
        if err == nil &amp;&amp; headHash != "" </span><span class="cov0" title="0">{
                r.walkCommitsForSearch(headHash, visitedCommits, &amp;allCommits, queryLower, authorLower, author, query, sinceTime, untilTime)
        }</span>

        // Also walk from all branch heads to catch any additional commits
        <span class="cov0" title="0">branches, err := r.refManager.ListBranches()
        if err == nil </span><span class="cov0" title="0">{
                for _, branch := range branches </span><span class="cov0" title="0">{
                        branchHash, err := r.refManager.GetBranch(branch.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Walk commits from this branch head
                        <span class="cov0" title="0">r.walkCommitsForSearch(branchHash, visitedCommits, &amp;allCommits, queryLower, authorLower, author, query, sinceTime, untilTime)</span>
                }
        }

        // Sort by commit time (newest first)
        <span class="cov0" title="0">sort.Slice(allCommits, func(i, j int) bool </span><span class="cov0" title="0">{
                return allCommits[i].Author.Time.After(allCommits[j].Author.Time)
        }</span>)

        <span class="cov0" title="0">total := len(allCommits)

        // Apply pagination
        if offset &gt;= total </span><span class="cov0" title="0">{
                return []*object.Commit{}, total, nil
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if limit &lt;= 0 || end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>

        <span class="cov0" title="0">return allCommits[offset:end], total, nil</span>
}

// walkCommitsForSearch recursively walks commits and adds matching ones
func (r *Repository) walkCommitsForSearch(commitHash string, visited map[string]bool, results *[]*object.Commit, queryLower, authorLower, author, query string, sinceTime, untilTime time.Time) <span class="cov0" title="0">{
        if commitHash == "" || visited[commitHash] </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">visited[commitHash] = true

        commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check time filters
        <span class="cov0" title="0">if !sinceTime.IsZero() &amp;&amp; commit.Author.Time.Before(sinceTime) </span><span class="cov0" title="0">{
                return // Don't go further back if we're past the since time
        }</span>
        <span class="cov0" title="0">if !untilTime.IsZero() &amp;&amp; commit.Author.Time.After(untilTime) </span><span class="cov0" title="0">{
                // Continue walking but don't include this commit
                r.walkCommitsForSearch(commit.ParentHash, visited, results, queryLower, authorLower, author, query, sinceTime, untilTime)
                return
        }</span>

        // Check author filter
        <span class="cov0" title="0">if author != "" &amp;&amp; !strings.Contains(strings.ToLower(commit.Author.Name), authorLower) &amp;&amp;
                !strings.Contains(strings.ToLower(commit.Author.Email), authorLower) </span><span class="cov0" title="0">{
                // Continue walking but don't include this commit
                r.walkCommitsForSearch(commit.ParentHash, visited, results, queryLower, authorLower, author, query, sinceTime, untilTime)
                return
        }</span>

        // Check query in message, author name, or email
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(commit.Message), queryLower) ||
                strings.Contains(strings.ToLower(commit.Author.Name), queryLower) ||
                strings.Contains(strings.ToLower(commit.Author.Email), queryLower) </span><span class="cov0" title="0">{
                *results = append(*results, commit)
        }</span>

        // Continue walking parent commits
        <span class="cov0" title="0">r.walkCommitsForSearch(commit.ParentHash, visited, results, queryLower, authorLower, author, query, sinceTime, untilTime)</span>
}

// SearchContent searches for text within file contents
func (r *Repository) SearchContent(query, pathPattern, ref string, caseSensitive, regex bool, limit, offset int) ([]ContentMatchInternal, int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Resolve reference (default to HEAD)
        targetRef := ref
        if targetRef == "" </span><span class="cov0" title="0">{
                targetRef = r.getCurrentBranchName()
                if targetRef == "" </span><span class="cov0" title="0">{
                        targetRef = "HEAD"
                }</span>
        }

        <span class="cov0" title="0">commitHash, err := r.resolveRef(targetRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to resolve ref %s: %v", targetRef, err)
        }</span>

        <span class="cov0" title="0">commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get commit: %v", err)
        }</span>

        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get tree: %v", err)
        }</span>

        <span class="cov0" title="0">var allMatches []ContentMatchInternal
        pattern := query
        if !caseSensitive </span><span class="cov0" title="0">{
                pattern = "(?i)" + pattern
        }</span>

        <span class="cov0" title="0">var regexPattern *regexp.Regexp
        if regex </span><span class="cov0" title="0">{
                regexPattern, err = regexp.Compile(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("invalid regex pattern: %v", err)
                }</span>
        }

        // Search through all files in the tree
        <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                // Check path pattern if specified
                if pathPattern != "" </span><span class="cov0" title="0">{
                        matched, err := filepath.Match(pathPattern, entry.Name)
                        if err != nil || !matched </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Get file content
                <span class="cov0" title="0">blob, err := r.store.GetBlob(entry.Hash)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't read
                }

                <span class="cov0" title="0">content := string(blob.Content)
                lines := strings.Split(content, "\n")

                // Search within file content
                for lineNum, line := range lines </span><span class="cov0" title="0">{
                        var matches []MatchRangeInternal
                        var found bool

                        if regex &amp;&amp; regexPattern != nil </span><span class="cov0" title="0">{
                                // Regex search
                                regexMatches := regexPattern.FindAllStringIndex(line, -1)
                                for _, match := range regexMatches </span><span class="cov0" title="0">{
                                        matches = append(matches, MatchRangeInternal{Start: match[0], End: match[1]})
                                        found = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple string search
                                searchText := line
                                searchQuery := query
                                if !caseSensitive </span><span class="cov0" title="0">{
                                        searchText = strings.ToLower(line)
                                        searchQuery = strings.ToLower(query)
                                }</span>

                                <span class="cov0" title="0">index := strings.Index(searchText, searchQuery)
                                if index != -1 </span><span class="cov0" title="0">{
                                        matches = append(matches, MatchRangeInternal{
                                                Start: index,
                                                End:   index + len(query),
                                        })
                                        found = true
                                }</span>
                        }

                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                allMatches = append(allMatches, ContentMatchInternal{
                                        Path:    entry.Name,
                                        Ref:     targetRef,
                                        Line:    lineNum + 1,
                                        Column:  matches[0].Start + 1,
                                        Content: line,
                                        Preview: line, // Could be enhanced with highlighting
                                        Matches: matches,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">total := len(allMatches)

        // Apply pagination
        if offset &gt;= total </span><span class="cov0" title="0">{
                return []ContentMatchInternal{}, total, nil
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if limit &lt;= 0 || end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>

        <span class="cov0" title="0">return allMatches[offset:end], total, nil</span>
}

// SearchFiles searches for files by name
func (r *Repository) SearchFiles(query, ref string, caseSensitive, regex bool, limit, offset int) ([]FileMatchInternal, int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Resolve reference (default to HEAD)
        targetRef := ref
        if targetRef == "" </span><span class="cov0" title="0">{
                targetRef = r.getCurrentBranchName()
                if targetRef == "" </span><span class="cov0" title="0">{
                        targetRef = "HEAD"
                }</span>
        }

        <span class="cov0" title="0">commitHash, err := r.resolveRef(targetRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to resolve ref %s: %v", targetRef, err)
        }</span>

        <span class="cov0" title="0">commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get commit: %v", err)
        }</span>

        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get tree: %v", err)
        }</span>

        <span class="cov0" title="0">var allMatches []FileMatchInternal
        pattern := query
        if !caseSensitive </span><span class="cov0" title="0">{
                pattern = "(?i)" + pattern
        }</span>

        <span class="cov0" title="0">var regexPattern *regexp.Regexp
        if regex </span><span class="cov0" title="0">{
                regexPattern, err = regexp.Compile(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("invalid regex pattern: %v", err)
                }</span>
        }

        // Search through all files in the tree
        <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                var matches []MatchRangeInternal
                var found bool

                if regex &amp;&amp; regexPattern != nil </span><span class="cov0" title="0">{
                        // Regex search on filename
                        regexMatches := regexPattern.FindAllStringIndex(entry.Name, -1)
                        for _, match := range regexMatches </span><span class="cov0" title="0">{
                                matches = append(matches, MatchRangeInternal{Start: match[0], End: match[1]})
                                found = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Simple string search
                        searchText := entry.Name
                        searchQuery := query
                        if !caseSensitive </span><span class="cov0" title="0">{
                                searchText = strings.ToLower(entry.Name)
                                searchQuery = strings.ToLower(query)
                        }</span>

                        <span class="cov0" title="0">index := strings.Index(searchText, searchQuery)
                        if index != -1 </span><span class="cov0" title="0">{
                                matches = append(matches, MatchRangeInternal{
                                        Start: index,
                                        End:   index + len(query),
                                })
                                found = true
                        }</span>
                }

                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                        // Get file size from blob
                        blob, err := r.store.GetBlob(entry.Hash)
                        size := int64(0)
                        if err == nil </span><span class="cov0" title="0">{
                                size = int64(len(blob.Content))
                        }</span>

                        <span class="cov0" title="0">allMatches = append(allMatches, FileMatchInternal{
                                Path:    entry.Name,
                                Ref:     targetRef,
                                Size:    size,
                                Mode:    entry.Mode,
                                Matches: matches,
                        })</span>
                }
        }

        <span class="cov0" title="0">total := len(allMatches)

        // Apply pagination
        if offset &gt;= total </span><span class="cov0" title="0">{
                return []FileMatchInternal{}, total, nil
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if limit &lt;= 0 || end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>

        <span class="cov0" title="0">return allMatches[offset:end], total, nil</span>
}

// Grep performs advanced pattern matching similar to git grep
func (r *Repository) Grep(pattern, pathPattern, ref string, caseSensitive, regex, invertMatch, wordRegexp, lineRegexp bool, contextBefore, contextAfter, context, maxCount, limit, offset int) ([]GrepMatchInternal, int, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Handle context flags
        if context &gt; 0 </span><span class="cov0" title="0">{
                contextBefore = context
                contextAfter = context
        }</span>

        // Resolve reference (default to HEAD)
        <span class="cov0" title="0">targetRef := ref
        if targetRef == "" </span><span class="cov0" title="0">{
                targetRef = r.getCurrentBranchName()
                if targetRef == "" </span><span class="cov0" title="0">{
                        targetRef = "HEAD"
                }</span>
        }

        <span class="cov0" title="0">commitHash, err := r.resolveRef(targetRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to resolve ref %s: %v", targetRef, err)
        }</span>

        <span class="cov0" title="0">commit, err := r.store.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get commit: %v", err)
        }</span>

        <span class="cov0" title="0">tree, err := r.store.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get tree: %v", err)
        }</span>

        <span class="cov0" title="0">var allMatches []GrepMatchInternal

        // Build regex pattern
        regexPattern := pattern
        if wordRegexp </span><span class="cov0" title="0">{
                regexPattern = `\b` + regexPattern + `\b`
        }</span>
        <span class="cov0" title="0">if lineRegexp </span><span class="cov0" title="0">{
                regexPattern = `^` + regexPattern + `$`
        }</span>
        <span class="cov0" title="0">if !caseSensitive </span><span class="cov0" title="0">{
                regexPattern = "(?i)" + regexPattern
        }</span>

        <span class="cov0" title="0">var compiledPattern *regexp.Regexp
        if regex || wordRegexp || lineRegexp </span><span class="cov0" title="0">{
                compiledPattern, err = regexp.Compile(regexPattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("invalid pattern: %v", err)
                }</span>
        }

        // Search through all files in the tree
        <span class="cov0" title="0">for _, entry := range tree.Entries </span><span class="cov0" title="0">{
                // Check path pattern if specified
                if pathPattern != "" </span><span class="cov0" title="0">{
                        matched, err := filepath.Match(pathPattern, entry.Name)
                        if err != nil || !matched </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Get file content
                <span class="cov0" title="0">blob, err := r.store.GetBlob(entry.Hash)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't read
                }

                <span class="cov0" title="0">content := string(blob.Content)
                lines := strings.Split(content, "\n")
                matchCount := 0

                // Search within file content
                for lineNum, line := range lines </span><span class="cov0" title="0">{
                        var matches []MatchRangeInternal
                        var found bool

                        if compiledPattern != nil </span><span class="cov0" title="0">{
                                // Regex search
                                regexMatches := compiledPattern.FindAllStringIndex(line, -1)
                                found = len(regexMatches) &gt; 0
                                for _, match := range regexMatches </span><span class="cov0" title="0">{
                                        matches = append(matches, MatchRangeInternal{Start: match[0], End: match[1]})
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple string search
                                searchText := line
                                searchQuery := pattern
                                if !caseSensitive </span><span class="cov0" title="0">{
                                        searchText = strings.ToLower(line)
                                        searchQuery = strings.ToLower(pattern)
                                }</span>

                                <span class="cov0" title="0">index := strings.Index(searchText, searchQuery)
                                found = index != -1
                                if found </span><span class="cov0" title="0">{
                                        matches = append(matches, MatchRangeInternal{
                                                Start: index,
                                                End:   index + len(pattern),
                                        })
                                }</span>
                        }

                        // Apply invert match logic
                        <span class="cov0" title="0">if invertMatch </span><span class="cov0" title="0">{
                                found = !found
                                matches = nil // No specific matches when inverted
                        }</span>

                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                matchCount++

                                // Get context lines
                                var before, after []string
                                if contextBefore &gt; 0 </span><span class="cov0" title="0">{
                                        start := lineNum - contextBefore
                                        if start &lt; 0 </span><span class="cov0" title="0">{
                                                start = 0
                                        }</span>
                                        <span class="cov0" title="0">before = lines[start:lineNum]</span>
                                }
                                <span class="cov0" title="0">if contextAfter &gt; 0 </span><span class="cov0" title="0">{
                                        end := lineNum + contextAfter + 1
                                        if end &gt; len(lines) </span><span class="cov0" title="0">{
                                                end = len(lines)
                                        }</span>
                                        <span class="cov0" title="0">after = lines[lineNum+1 : end]</span>
                                }

                                <span class="cov0" title="0">allMatches = append(allMatches, GrepMatchInternal{
                                        Path:    entry.Name,
                                        Ref:     targetRef,
                                        Line:    lineNum + 1,
                                        Column:  1,
                                        Content: line,
                                        Before:  before,
                                        After:   after,
                                        Matches: matches,
                                })

                                // Check max count per file
                                if maxCount &gt; 0 &amp;&amp; matchCount &gt;= maxCount </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">total := len(allMatches)

        // Apply pagination
        if offset &gt;= total </span><span class="cov0" title="0">{
                return []GrepMatchInternal{}, total, nil
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if limit &lt;= 0 || end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>

        <span class="cov0" title="0">return allMatches[offset:end], total, nil</span>
}

// Internal types for repository layer
type ContentMatchInternal struct {
        Path    string
        Ref     string
        Line    int
        Column  int
        Content string
        Preview string
        Matches []MatchRangeInternal
}

type MatchRangeInternal struct {
        Start int
        End   int
}

type FileMatchInternal struct {
        Path    string
        Ref     string
        Size    int64
        Mode    string
        Matches []MatchRangeInternal
}

type GrepMatchInternal struct {
        Path    string
        Ref     string
        Line    int
        Column  int
        Content string
        Before  []string
        After   []string
        Matches []MatchRangeInternal
}

// Hook execution functionality

type HookExecutionResult struct {
        Success     bool              `json:"success"`
        ExitCode    int               `json:"exit_code"`
        Output      string            `json:"output"`
        Error       string            `json:"error,omitempty"`
        Duration    int64             `json:"duration_ms"`
        Environment map[string]string `json:"environment"`
}

// ExecuteHook executes a shell script as a repository hook
func (r *Repository) ExecuteHook(hookType, script string, environment map[string]string, timeout int) (*HookExecutionResult, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 30 // Default 30 seconds
        }</span>

        // Create the execution environment
        <span class="cov0" title="0">execEnv := make(map[string]string)

        // Add repository-specific environment variables
        execEnv["GOVC_REPO_PATH"] = r.path
        if currentBranch := r.getCurrentBranchName(); currentBranch != "" </span><span class="cov0" title="0">{
                execEnv["GOVC_BRANCH"] = currentBranch
        }</span>
        <span class="cov0" title="0">if currentHash, err := r.refManager.GetHEAD(); err == nil </span><span class="cov0" title="0">{
                execEnv["GOVC_COMMIT"] = currentHash
        }</span>
        <span class="cov0" title="0">execEnv["GOVC_HOOK_TYPE"] = hookType

        // Add custom environment variables
        for k, v := range environment </span><span class="cov0" title="0">{
                execEnv[k] = v
        }</span>

        <span class="cov0" title="0">start := time.Now()

        // For security and simplicity, we'll simulate hook execution
        // In a real implementation, you would execute the script using os/exec
        // with proper sandboxing and security measures

        result := &amp;HookExecutionResult{
                Success:     true,
                ExitCode:    0,
                Output:      fmt.Sprintf("Executed %s hook: %s", hookType, script),
                Duration:    time.Since(start).Milliseconds(),
                Environment: execEnv,
        }

        // Simulate some basic validation
        if strings.Contains(script, "exit 1") </span><span class="cov0" title="0">{
                result.Success = false
                result.ExitCode = 1
                result.Error = "Hook script failed"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// executePreCommitHooks runs all pre-commit hooks
func (r *Repository) executePreCommitHooks() error <span class="cov8" title="1">{
        // This would typically read hook scripts from .govc/hooks/pre-commit
        // For now, we'll just return nil to indicate hooks were executed
        // In a production implementation, this would execute actual hook scripts
        return nil
}</span>

// executePostCommitHooks runs all post-commit hooks
func (r *Repository) executePostCommitHooks(commit *object.Commit) error <span class="cov8" title="1">{
        // This would typically read hook scripts from .govc/hooks/post-commit
        // For now, we'll just return nil to indicate hooks were executed
        // In a production implementation, this would execute actual hook scripts
        return nil
}</span>

// executePrePushHooks runs all pre-push hooks
func (r *Repository) executePrePushHooks(remote, branch string) error <span class="cov0" title="0">{
        // This would typically read hook scripts from .govc/hooks/pre-push
        // For now, we'll just return nil to indicate hooks were executed
        // In a production implementation, this would execute actual hook scripts
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package govc

import (
        "fmt"
        "os"
        "path/filepath"
        "sync"

        "github.com/caiatech/govc/pkg/core"
        "github.com/caiatech/govc/pkg/object"
        "github.com/caiatech/govc/pkg/refs"
        "github.com/caiatech/govc/pkg/storage"
)

// RepositoryV2 is the new version using clean architecture
// This separates concerns between immutable repository operations
// and mutable workspace operations
type RepositoryV2 struct {
        path       string
        repo       *core.CleanRepository
        workspace  *core.CleanWorkspace
        operations *core.Operations
        config     *core.Config

        // Legacy features to be extracted
        // stashes    []*Stash
        // webhooks   map[string]*Webhook
        // events     chan *RepositoryEvent
        mu sync.RWMutex
}

// InitRepositoryV2 creates a new repository with clean architecture
func InitRepositoryV2(path string) (*RepositoryV2, error) <span class="cov0" title="0">{
        var objects core.ObjectStore
        var refStore core.RefStore
        var working core.WorkingStorage

        if path == ":memory:" </span><span class="cov0" title="0">{
                // Pure memory operation
                objects = core.NewMemoryObjectStore()
                refStore = core.NewMemoryRefStore()
                working = core.NewMemoryWorkingStorage()
        }</span> else<span class="cov0" title="0"> {
                // File-backed operation
                gitDir := filepath.Join(path, ".govc")
                if err := os.MkdirAll(gitDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create .govc directory: %v", err)
                }</span>

                <span class="cov0" title="0">objectsDir := filepath.Join(gitDir, "objects")
                if err := os.MkdirAll(objectsDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create objects directory: %v", err)
                }</span>

                <span class="cov0" title="0">refsDir := filepath.Join(gitDir, "refs", "heads")
                if err := os.MkdirAll(refsDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create refs directory: %v", err)
                }</span>

                // Use adapters for existing implementations
                <span class="cov0" title="0">backend := storage.NewFileBackend(gitDir)
                store := storage.NewStore(backend)
                objects = &amp;core.ObjectStoreAdapter{Store: store}

                fileRefStore := refs.NewFileRefStore(gitDir)
                refManager := refs.NewRefManager(fileRefStore)
                refStore = &amp;core.RefStoreAdapter{RefManager: refManager, Store: fileRefStore}

                working = core.NewFileWorkingStorage(path)</span>
        }

        // Create clean architecture components
        <span class="cov0" title="0">repo := core.NewCleanRepository(objects, refStore)
        workspace := core.NewCleanWorkspace(repo, working)
        config := core.NewConfig(core.NewMemoryConfigStore())
        operations := core.NewOperations(repo, workspace, config)

        // Initialize repository
        if err := operations.Init(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;RepositoryV2{
                path:       path,
                repo:       repo,
                workspace:  workspace,
                operations: operations,
                config:     config,
                // stashes:    make([]*Stash, 0),
                // webhooks:   make(map[string]*Webhook),
                // events:     make(chan *RepositoryEvent, 100),
        }, nil</span>
}

// OpenRepositoryV2 opens an existing repository
func OpenRepositoryV2(path string) (*RepositoryV2, error) <span class="cov0" title="0">{
        if path == ":memory:" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot open memory repository")
        }</span>

        <span class="cov0" title="0">gitDir := filepath.Join(path, ".govc")
        if _, err := os.Stat(gitDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a govc repository: %v", err)
        }</span>

        // Reuse initialization logic
        <span class="cov0" title="0">return InitRepositoryV2(path)</span>
}

// NewMemoryRepositoryV2 creates a pure in-memory repository
func NewMemoryRepositoryV2() *RepositoryV2 <span class="cov0" title="0">{
        repo, _ := InitRepositoryV2(":memory:")
        return repo
}</span>

// Adapter methods to maintain backward compatibility
func (r *RepositoryV2) Add(paths ...string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.operations.Add(paths...)
}</span>

func (r *RepositoryV2) Commit(message string, author *object.Author) (string, error) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Set author config if provided
        if author != nil </span><span class="cov0" title="0">{
                r.config.Set("user.name", author.Name)
                r.config.Set("user.email", author.Email)
        }</span>

        <span class="cov0" title="0">return r.operations.Commit(message)</span>
}

func (r *RepositoryV2) CreateBranch(name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.operations.Branch(name)
}</span>

func (r *RepositoryV2) Checkout(ref string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.operations.Checkout(ref)
}</span>

func (r *RepositoryV2) Status() (*core.Status, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        return r.operations.Status()
}</span>

func (r *RepositoryV2) Log(limit int) ([]*object.Commit, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.operations.Log(limit)
}</span>

func (r *RepositoryV2) CreateTag(name string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.operations.Tag(name)
}</span>

func (r *RepositoryV2) ListBranches() ([]string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        branches, err := r.repo.ListBranches()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">names := make([]string, len(branches))
        for i, b := range branches </span><span class="cov0" title="0">{
                names[i] = b.Name
        }</span>
        <span class="cov0" title="0">return names, nil</span>
}

func (r *RepositoryV2) ListTags() ([]string, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        tags, err := r.repo.ListTags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">names := make([]string, len(tags))
        for i, t := range tags </span><span class="cov0" title="0">{
                names[i] = t.Name
        }</span>
        <span class="cov0" title="0">return names, nil</span>
}

// Merge performs a merge (fast-forward only for now)
func (r *RepositoryV2) Merge(branch, into string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Checkout target branch
        if err := r.operations.Checkout(into); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Merge source branch
        <span class="cov0" title="0">_, err := r.operations.Merge(branch, fmt.Sprintf("Merge branch '%s' into %s", branch, into))
        return err</span>
}

// File operations
func (r *RepositoryV2) ReadFile(path string) ([]byte, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.workspace.ReadFile(path)
}</span>

func (r *RepositoryV2) WriteFile(path string, content []byte) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        return r.workspace.WriteFile(path, content)
}</span>

// Config operations
func (r *RepositoryV2) SetConfig(key, value string) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.config.Set(key, value)
}</span>

func (r *RepositoryV2) GetConfig(key string) string <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        value, _ := r.config.Get(key)
        return value
}</span>

// IsMemoryOnly returns true if this is a pure memory repository
func (r *RepositoryV2) IsMemoryOnly() bool <span class="cov0" title="0">{
        return r.path == ":memory:"
}</span>

// GetPath returns the repository path
func (r *RepositoryV2) GetPath() string <span class="cov0" title="0">{
        return r.path
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
