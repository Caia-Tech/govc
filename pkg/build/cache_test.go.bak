package build_test

import (
	"fmt"
	"sync"
	"testing"
	"time"

	"github.com/Caia-Tech/govc/pkg/build"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMemoryCache(t *testing.T) {
	t.Run("BasicOperations", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Create test result
		result := &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Name: "app", Content: []byte("binary")},
			},
		}
		
		// Create cache key
		key := build.CacheKey{
			Plugin:    "test",
			FilesHash: "hash1",
		}
		
		// Put and get
		err := cache.Put(key, result)
		require.NoError(t, err)
		
		cached, hit := cache.Get(key)
		assert.True(t, hit)
		assert.NotNil(t, cached)
		assert.Equal(t, result.Success, cached.Success)
		assert.Len(t, cached.Artifacts, 1)
		
		// Miss
		missKey := build.CacheKey{Plugin: "nonexistent", FilesHash: "hash2"}
		_, hit = cache.Get(missKey)
		assert.False(t, hit)
	})

	t.Run("CacheExpiration", func(t *testing.T) {
		// Short TTL for testing
		cache := build.NewMemoryCacheWithOptions(10, 1024*1024, 100*time.Millisecond)
		
		key := "expiring-key"
		result := &build.BuildResult{Success: true}
		
		err := cache.Put(key, result)
		require.NoError(t, err)
		
		// Should hit immediately
		_, hit := cache.Get(key)
		assert.True(t, hit)
		
		// Wait for expiration
		time.Sleep(150 * time.Millisecond)
		
		// Should miss after expiration
		_, hit = cache.Get(key)
		assert.False(t, hit)
	})

	t.Run("LRUEviction", func(t *testing.T) {
		// Small cache with only 3 entries
		cache := build.NewMemoryCacheWithOptions(3, 1024*1024, 1*time.Hour)
		
		// Add 3 entries
		for i := 1; i <= 3; i++ {
			key := fmt.Sprintf("key-%d", i)
			result := &build.BuildResult{
				Success: true,
				Artifacts: []build.BuildArtifact{
					{Name: fmt.Sprintf("app%d", i)},
				},
			}
			cache.Put(key, result)
		}
		
		// All 3 should be present
		for i := 1; i <= 3; i++ {
			_, hit := cache.Get(fmt.Sprintf("key-%d", i))
			assert.True(t, hit, "key-%d should be present", i)
		}
		
		// Access key-1 and key-2 to make them more recently used
		cache.Get("key-1")
		cache.Get("key-2")
		
		// Add 4th entry - should evict key-3 (least recently used)
		cache.Put("key-4", &build.BuildResult{Success: true})
		
		// key-3 should be evicted
		_, hit := cache.Get("key-3")
		assert.False(t, hit, "key-3 should be evicted")
		
		// Others should still be present
		_, hit = cache.Get("key-1")
		assert.True(t, hit)
		_, hit = cache.Get("key-2")
		assert.True(t, hit)
		_, hit = cache.Get("key-4")
		assert.True(t, hit)
	})

	t.Run("SizeBasedEviction", func(t *testing.T) {
		// 1KB max size
		cache := build.NewMemoryCacheWithOptions(100, 1024, 1*time.Hour)
		
		// Add entries that consume space
		largeContent := make([]byte, 500) // 500 bytes
		
		// First entry - 500 bytes
		cache.Put("key-1", &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Name: "large1", Content: largeContent},
			},
		})
		
		// Second entry - 500 bytes (total 1000 bytes, still under 1KB)
		cache.Put("key-2", &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Name: "large2", Content: largeContent},
			},
		})
		
		// Both should be present
		_, hit1 := cache.Get("key-1")
		_, hit2 := cache.Get("key-2")
		assert.True(t, hit1)
		assert.True(t, hit2)
		
		// Third entry - would exceed size limit, should trigger eviction
		cache.Put("key-3", &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Name: "large3", Content: largeContent},
			},
		})
		
		// One of the first entries should be evicted
		_, hit1 = cache.Get("key-1")
		_, hit2 = cache.Get("key-2")
		_, hit3 := cache.Get("key-3")
		
		assert.True(t, hit3, "New entry should be present")
		assert.True(t, hit1 || hit2, "At least one old entry should remain")
		assert.False(t, hit1 && hit2, "Not both old entries should remain")
	})

	t.Run("ClearCache", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Add multiple entries
		for i := 0; i < 5; i++ {
			key := fmt.Sprintf("key-%d", i)
			cache.Put(key, &build.BuildResult{Success: true})
		}
		
		// Verify entries exist
		stats := cache.Stats()
		assert.Equal(t, 5, stats.Entries)
		
		// Clear cache
		cache.Clear()
		
		// Verify cache is empty
		stats = cache.Stats()
		assert.Equal(t, 0, stats.Entries)
		
		// All entries should miss
		for i := 0; i < 5; i++ {
			_, hit := cache.Get(fmt.Sprintf("key-%d", i))
			assert.False(t, hit)
		}
	})

	t.Run("CacheStats", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Initial stats
		stats := cache.Stats()
		assert.Equal(t, int64(0), stats.Hits)
		assert.Equal(t, int64(0), stats.Misses)
		assert.Equal(t, 0, stats.Entries)
		
		// Add entry
		cache.Put("key1", &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Content: make([]byte, 100)},
			},
		})
		
		// Hit
		cache.Get("key1")
		stats = cache.Stats()
		assert.Equal(t, int64(1), stats.Hits)
		assert.Equal(t, int64(0), stats.Misses)
		
		// Miss
		cache.Get("key2")
		stats = cache.Stats()
		assert.Equal(t, int64(1), stats.Hits)
		assert.Equal(t, int64(1), stats.Misses)
		
		// Hit rate
		assert.Equal(t, 0.5, stats.HitRate())
		
		// Size should include the content
		assert.Greater(t, stats.Size, int64(100))
	})

	t.Run("ConcurrentAccess", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Concurrent writes
		var wg sync.WaitGroup
		for i := 0; i < 100; i++ {
			wg.Add(1)
			go func(n int) {
				defer wg.Done()
				key := fmt.Sprintf("key-%d", n)
				result := &build.BuildResult{
					Success: true,
					Artifacts: []build.BuildArtifact{
						{Name: fmt.Sprintf("app%d", n)},
					},
				}
				cache.Put(key, result)
			}(i)
		}
		wg.Wait()
		
		// Concurrent reads
		hitCount := 0
		var mu sync.Mutex
		
		for i := 0; i < 100; i++ {
			wg.Add(1)
			go func(n int) {
				defer wg.Done()
				key := fmt.Sprintf("key-%d", n)
				if _, hit := cache.Get(key); hit {
					mu.Lock()
					hitCount++
					mu.Unlock()
				}
			}(i)
		}
		wg.Wait()
		
		assert.Equal(t, 100, hitCount, "All keys should hit")
		
		// Concurrent mixed operations
		for i := 0; i < 50; i++ {
			wg.Add(3)
			
			// Writer
			go func(n int) {
				defer wg.Done()
				cache.Put(fmt.Sprintf("new-%d", n), &build.BuildResult{Success: true})
			}(i)
			
			// Reader
			go func(n int) {
				defer wg.Done()
				cache.Get(fmt.Sprintf("key-%d", n))
			}(i)
			
			// Stats reader
			go func() {
				defer wg.Done()
				_ = cache.Stats()
			}()
		}
		wg.Wait()
		
		// Cache should still be consistent
		stats := cache.Stats()
		assert.GreaterOrEqual(t, stats.Entries, 100)
	})

	t.Run("InvalidateEntry", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Add entries
		cache.Put("key1", &build.BuildResult{Success: true})
		cache.Put("key2", &build.BuildResult{Success: true})
		cache.Put("key3", &build.BuildResult{Success: true})
		
		// Invalidate specific entry
		cache.Invalidate("key2")
		
		// key2 should miss, others should hit
		_, hit := cache.Get("key1")
		assert.True(t, hit)
		
		_, hit = cache.Get("key2")
		assert.False(t, hit)
		
		_, hit = cache.Get("key3")
		assert.True(t, hit)
	})

	t.Run("InvalidatePattern", func(t *testing.T) {
		cache := build.NewMemoryCache()
		
		// Add entries with patterns
		cache.Put("test-key-1", &build.BuildResult{Success: true})
		cache.Put("test-key-2", &build.BuildResult{Success: true})
		cache.Put("prod-key-1", &build.BuildResult{Success: true})
		cache.Put("prod-key-2", &build.BuildResult{Success: true})
		
		// Invalidate all test keys
		cache.InvalidatePattern("test-*")
		
		// Test keys should miss
		_, hit := cache.Get("test-key-1")
		assert.False(t, hit)
		_, hit = cache.Get("test-key-2")
		assert.False(t, hit)
		
		// Prod keys should hit
		_, hit = cache.Get("prod-key-1")
		assert.True(t, hit)
		_, hit = cache.Get("prod-key-2")
		assert.True(t, hit)
	})
}

func TestCacheKeyBuilder(t *testing.T) {
	t.Run("SimpleKey", func(t *testing.T) {
		builder := build.NewCacheKeyBuilder("go")
		builder.WithFile("main.go", []byte("package main"))
		
		key := builder.Build()
		assert.NotEmpty(t, key)
		
		// Same inputs should produce same key
		builder2 := build.NewCacheKeyBuilder("go")
		builder2.WithFile("main.go", []byte("package main"))
		
		key2 := builder2.Build()
		assert.Equal(t, key, key2)
	})

	t.Run("OrderIndependence", func(t *testing.T) {
		// First order
		builder1 := build.NewCacheKeyBuilder("go")
		builder1.WithFile("a.go", []byte("package a"))
		builder1.WithFile("b.go", []byte("package b"))
		builder1.WithConfig("target", "linux")
		builder1.WithConfig("mode", "release")
		key1 := builder1.Build()
		
		// Different order
		builder2 := build.NewCacheKeyBuilder("go")
		builder2.WithConfig("mode", "release")
		builder2.WithFile("b.go", []byte("package b"))
		builder2.WithConfig("target", "linux")
		builder2.WithFile("a.go", []byte("package a"))
		key2 := builder2.Build()
		
		// Keys should be the same regardless of order
		assert.Equal(t, key1, key2)
	})

	t.Run("DifferentContent", func(t *testing.T) {
		builder1 := build.NewCacheKeyBuilder("go")
		builder1.WithFile("main.go", []byte("package main"))
		key1 := builder1.Build()
		
		builder2 := build.NewCacheKeyBuilder("go")
		builder2.WithFile("main.go", []byte("package main // changed"))
		key2 := builder2.Build()
		
		// Different content should produce different keys
		assert.NotEqual(t, key1, key2)
	})

	t.Run("WithEnvironment", func(t *testing.T) {
		builder1 := build.NewCacheKeyBuilder("go")
		builder1.WithFile("main.go", []byte("package main"))
		builder1.WithEnvironment(map[string]string{
			"GOOS":   "linux",
			"GOARCH": "amd64",
		})
		key1 := builder1.Build()
		
		builder2 := build.NewCacheKeyBuilder("go")
		builder2.WithFile("main.go", []byte("package main"))
		builder2.WithEnvironment(map[string]string{
			"GOOS":   "darwin",
			"GOARCH": "amd64",
		})
		key2 := builder2.Build()
		
		// Different environment should produce different keys
		assert.NotEqual(t, key1, key2)
	})

	t.Run("ComplexKey", func(t *testing.T) {
		builder := build.NewCacheKeyBuilder("javascript")
		
		// Add multiple files
		builder.WithFile("package.json", []byte(`{"name": "app"}`))
		builder.WithFile("index.js", []byte("console.log('hello')"))
		builder.WithFile("lib.js", []byte("module.exports = {}"))
		
		// Add configuration
		builder.WithConfig("target", "production")
		builder.WithConfig("minify", "true")
		builder.WithConfig("sourcemaps", "false")
		
		// Add environment
		builder.WithEnvironment(map[string]string{
			"NODE_ENV": "production",
			"CI":       "true",
		})
		
		// Add dependencies
		builder.WithDependency("react", "18.2.0")
		builder.WithDependency("webpack", "5.88.0")
		
		key := builder.Build()
		assert.NotEmpty(t, key)
		
		// Key should be deterministic
		key2 := builder.Build()
		assert.Equal(t, key, key2)
	})

	t.Run("EmptyBuilder", func(t *testing.T) {
		builder := build.NewCacheKeyBuilder("test")
		key := builder.Build()
		
		// Should still produce a valid key
		assert.NotEmpty(t, key)
		assert.Contains(t, key, "test")
	})
}

func BenchmarkCache(b *testing.B) {
	b.Run("Put", func(b *testing.B) {
		cache := build.NewMemoryCache()
		result := &build.BuildResult{
			Success: true,
			Artifacts: []build.BuildArtifact{
				{Name: "app", Content: make([]byte, 1024)},
			},
		}
		
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			key := fmt.Sprintf("key-%d", i)
			cache.Put(key, result)
		}
	})

	b.Run("Get", func(b *testing.B) {
		cache := build.NewMemoryCache()
		
		// Populate cache
		for i := 0; i < 1000; i++ {
			key := fmt.Sprintf("key-%d", i)
			cache.Put(key, &build.BuildResult{Success: true})
		}
		
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			key := fmt.Sprintf("key-%d", i%1000)
			cache.Get(key)
		}
	})

	b.Run("ConcurrentGet", func(b *testing.B) {
		cache := build.NewMemoryCache()
		
		// Populate cache
		for i := 0; i < 100; i++ {
			key := fmt.Sprintf("key-%d", i)
			cache.Put(key, &build.BuildResult{Success: true})
		}
		
		b.ResetTimer()
		b.RunParallel(func(pb *testing.PB) {
			i := 0
			for pb.Next() {
				key := fmt.Sprintf("key-%d", i%100)
				cache.Get(key)
				i++
			}
		})
	})

	b.Run("KeyBuilder", func(b *testing.B) {
		content := []byte("package main\nfunc main() {}")
		
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			builder := build.NewCacheKeyBuilder("go")
			builder.WithFile("main.go", content)
			builder.WithConfig("target", "linux")
			builder.Build()
		}
	})

	b.Run("LargeCache", func(b *testing.B) {
		cache := build.NewMemoryCacheWithOptions(10000, 100*1024*1024, 1*time.Hour)
		
		// Populate with many entries
		for i := 0; i < 10000; i++ {
			key := fmt.Sprintf("key-%d", i)
			cache.Put(key, &build.BuildResult{
				Success: true,
				Artifacts: []build.BuildArtifact{
					{Content: make([]byte, 1024)}, // 1KB each
				},
			})
		}
		
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			key := fmt.Sprintf("key-%d", i%10000)
			cache.Get(key)
		}
	})
}