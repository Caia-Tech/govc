package memory

import (
	"context"
	"testing"
	"time"

	"github.com/caiatech/govc/datastore"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMemoryStore_EdgeCases(t *testing.T) {
	config := datastore.Config{
		Type: datastore.TypeMemory,
	}
	
	store := New(config)
	err := store.Initialize(config)
	require.NoError(t, err)
	defer store.Close()

	t.Run("EmptyOperations", func(t *testing.T) {
		// Empty batch operations
		err := store.PutObjects(map[string][]byte{})
		assert.NoError(t, err)
		
		err = store.DeleteObjects([]string{})
		assert.NoError(t, err)
		
		result, err := store.GetObjects([]string{})
		assert.NoError(t, err)
		assert.Empty(t, result)
		
		// Empty prefix operations
		hashes, err := store.ListObjects("", 0)
		assert.NoError(t, err)
		// Go slices can be nil or empty - both are valid
		if hashes != nil {
			assert.Empty(t, hashes)
		}
		
		err = store.IterateObjects("nonexistent-", func(hash string, data []byte) error {
			t.Fatal("Should not be called")
			return nil
		})
		assert.NoError(t, err)
	})

	t.Run("NilAndEmptyData", func(t *testing.T) {
		// Empty data
		err := store.PutObject("empty", []byte{})
		assert.NoError(t, err)
		
		data, err := store.GetObject("empty")
		assert.NoError(t, err)
		assert.Empty(t, data)
		
		size, err := store.GetObjectSize("empty")
		assert.NoError(t, err)
		assert.Equal(t, int64(0), size)
		
		// Nil data in batch
		err = store.PutObjects(map[string][]byte{
			"nil-test": nil,
		})
		assert.NoError(t, err)
		
		data, err = store.GetObject("nil-test")
		assert.NoError(t, err)
		// Memory store converts nil to empty slice
		assert.Equal(t, []byte{}, data)
	})

	t.Run("ErrorConditions", func(t *testing.T) {
		// Non-existent object
		_, err := store.GetObject("does-not-exist")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		_, err = store.GetObjectSize("does-not-exist")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Delete non-existent
		err = store.DeleteObject("does-not-exist")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Has non-existent
		exists, err := store.HasObject("does-not-exist")
		assert.NoError(t, err)
		assert.False(t, exists)
	})

	t.Run("LargeData", func(t *testing.T) {
		// Large object
		largeData := make([]byte, 1024*1024) // 1MB
		for i := range largeData {
			largeData[i] = byte(i % 256)
		}
		
		err := store.PutObject("large", largeData)
		assert.NoError(t, err)
		
		retrieved, err := store.GetObject("large")
		assert.NoError(t, err)
		assert.Equal(t, largeData, retrieved)
		
		size, err := store.GetObjectSize("large")
		assert.NoError(t, err)
		assert.Equal(t, int64(len(largeData)), size)
	})
}

func TestMemoryStore_MetadataEdgeCases(t *testing.T) {
	config := datastore.Config{Type: datastore.TypeMemory}
	store := New(config)
	err := store.Initialize(config)
	require.NoError(t, err)
	defer store.Close()

	t.Run("RepositoryEdgeCases", func(t *testing.T) {
		// Repository with all fields
		repo := &datastore.Repository{
			ID:          uuid.New().String(),
			Name:        "test-repo",
			Description: "A test repository with special chars: !@#$%^&*()",
			Path:        "/path/with/unicode/ÊµãËØï",
			IsPrivate:   true,
			Metadata: map[string]interface{}{
				"nested": map[string]interface{}{
					"key": "value",
					"number": 42,
					"bool": true,
				},
				"array": []interface{}{"a", "b", "c"},
				"null": nil,
			},
			Size:        9999999999, // Large number
			CommitCount: -1,         // Negative number
			BranchCount: 0,          // Zero
			CreatedAt:   time.Now(),
			UpdatedAt:   time.Now().Add(time.Hour),
		}
		
		err := store.SaveRepository(repo)
		assert.NoError(t, err)
		
		retrieved, err := store.GetRepository(repo.ID)
		assert.NoError(t, err)
		assert.Equal(t, repo.Name, retrieved.Name)
		assert.Equal(t, repo.Description, retrieved.Description)
		assert.Equal(t, repo.Path, retrieved.Path)
		assert.Equal(t, repo.Size, retrieved.Size)
		assert.Equal(t, repo.CommitCount, retrieved.CommitCount)
		
		// Non-existent repository
		_, err = store.GetRepository("non-existent")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Delete non-existent
		err = store.DeleteRepository("non-existent")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
	})

	t.Run("UserEdgeCases", func(t *testing.T) {
		now := time.Now()
		user := &datastore.User{
			ID:       uuid.New().String(),
			Username: "test@user+with-special.chars_123",
			Email:    "test+user@example.co.uk",
			FullName: "Test User with √ú√±√Æ√ß√∂d√©",
			IsActive: false,
			IsAdmin:  true,
			Metadata: map[string]interface{}{
				"preferences": map[string]interface{}{
					"theme": "dark",
					"language": "en-US",
				},
			},
			CreatedAt:   now,
			UpdatedAt:   now.Add(time.Minute),
			LastLoginAt: &now,
		}
		
		err := store.SaveUser(user)
		assert.NoError(t, err)
		
		retrieved, err := store.GetUser(user.ID)
		assert.NoError(t, err)
		assert.Equal(t, user.Username, retrieved.Username)
		assert.Equal(t, user.Email, retrieved.Email)
		assert.Equal(t, user.FullName, retrieved.FullName)
		assert.NotNil(t, retrieved.LastLoginAt)
		
		// Get by username
		byUsername, err := store.GetUserByUsername(user.Username)
		assert.NoError(t, err)
		assert.Equal(t, user.ID, byUsername.ID)
		
		// Non-existent user
		_, err = store.GetUser("non-existent")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		_, err = store.GetUserByUsername("non-existent")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
	})

	t.Run("ConfigurationEdgeCases", func(t *testing.T) {
		// Various value types
		configs := map[string]string{
			"empty":      "",
			"spaces":     "   leading and trailing spaces   ",
			"newlines":   "line1\nline2\nline3",
			"unicode":    "ÊµãËØïÈÖçÁΩÆÂÄº with √©mojis üöÄ",
			"json-like":  `{"key": "value", "number": 123}`,
			"large":      string(make([]byte, 10000)), // Large value
		}
		
		for key, value := range configs {
			err := store.SetConfig(key, value)
			assert.NoError(t, err, "Failed to set config %s", key)
			
			retrieved, err := store.GetConfig(key)
			assert.NoError(t, err, "Failed to get config %s", key)
			assert.Equal(t, value, retrieved, "Config value mismatch for %s", key)
		}
		
		// Get all config
		allConfig, err := store.GetAllConfig()
		assert.NoError(t, err)
		assert.GreaterOrEqual(t, len(allConfig), len(configs))
		
		// Delete configs
		for key := range configs {
			err := store.DeleteConfig(key)
			assert.NoError(t, err, "Failed to delete config %s", key)
			
			_, err = store.GetConfig(key)
			assert.ErrorIs(t, err, datastore.ErrNotFound, "Config %s should not exist after deletion", key)
		}
		
		// Delete non-existent
		err = store.DeleteConfig("non-existent")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
	})
}

func TestMemoryStore_Transactions(t *testing.T) {
	config := datastore.Config{Type: datastore.TypeMemory}
	store := New(config)
	err := store.Initialize(config)
	require.NoError(t, err)
	defer store.Close()

	ctx := context.Background()

	t.Run("TransactionIsolation", func(t *testing.T) {
		// Start transaction
		tx, err := store.BeginTx(ctx, nil)
		require.NoError(t, err)
		
		// Write in transaction
		err = tx.PutObject("tx-test", []byte("transaction data"))
		assert.NoError(t, err)
		
		// Should be visible in transaction
		data, err := tx.GetObject("tx-test")
		assert.NoError(t, err)
		assert.Equal(t, []byte("transaction data"), data)
		
		// Should not be visible outside transaction
		_, err = store.GetObject("tx-test")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Commit
		err = tx.Commit()
		assert.NoError(t, err)
		
		// Now should be visible outside
		data, err = store.GetObject("tx-test")
		assert.NoError(t, err)
		assert.Equal(t, []byte("transaction data"), data)
	})

	t.Run("TransactionRollback", func(t *testing.T) {
		// Create initial data
		err := store.PutObject("rollback-test", []byte("initial"))
		require.NoError(t, err)
		
		// Start transaction
		tx, err := store.BeginTx(ctx, nil)
		require.NoError(t, err)
		
		// Modify in transaction
		err = tx.PutObject("rollback-test", []byte("modified"))
		assert.NoError(t, err)
		
		// Delete in transaction
		err = tx.DeleteObject("rollback-test")
		assert.NoError(t, err)
		
		// Should not exist in transaction
		_, err = tx.GetObject("rollback-test")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Rollback
		err = tx.Rollback()
		assert.NoError(t, err)
		
		// Should be back to initial state
		data, err := store.GetObject("rollback-test")
		assert.NoError(t, err)
		assert.Equal(t, []byte("initial"), data)
	})

	t.Run("MultipleTransactions", func(t *testing.T) {
		// Start multiple transactions
		tx1, err := store.BeginTx(ctx, nil)
		require.NoError(t, err)
		
		tx2, err := store.BeginTx(ctx, nil)
		require.NoError(t, err)
		
		// Write different data in each transaction
		err = tx1.PutObject("multi-tx1", []byte("data1"))
		assert.NoError(t, err)
		
		err = tx2.PutObject("multi-tx2", []byte("data2"))
		assert.NoError(t, err)
		
		// Each should see only their own data
		data1, err := tx1.GetObject("multi-tx1")
		assert.NoError(t, err)
		assert.Equal(t, []byte("data1"), data1)
		
		_, err = tx1.GetObject("multi-tx2")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		data2, err := tx2.GetObject("multi-tx2")
		assert.NoError(t, err)
		assert.Equal(t, []byte("data2"), data2)
		
		_, err = tx2.GetObject("multi-tx1")
		assert.ErrorIs(t, err, datastore.ErrNotFound)
		
		// Commit both
		err = tx1.Commit()
		assert.NoError(t, err)
		
		err = tx2.Commit()
		assert.NoError(t, err)
		
		// Now both should be visible
		data1, err = store.GetObject("multi-tx1")
		assert.NoError(t, err)
		assert.Equal(t, []byte("data1"), data1)
		
		data2, err = store.GetObject("multi-tx2")
		assert.NoError(t, err)
		assert.Equal(t, []byte("data2"), data2)
	})
}

func TestMemoryStore_Lifecycle(t *testing.T) {
	t.Run("InitializeAndClose", func(t *testing.T) {
		config := datastore.Config{Type: datastore.TypeMemory}
		store := New(config)
		
		// Initialize
		err := store.Initialize(config)
		assert.NoError(t, err)
		
		// Should be functional
		err = store.PutObject("test", []byte("data"))
		assert.NoError(t, err)
		
		// Close
		err = store.Close()
		assert.NoError(t, err)
		
		// Close again should be safe
		err = store.Close()
		assert.Error(t, err) // Already closed
	})

	t.Run("HealthCheck", func(t *testing.T) {
		config := datastore.Config{Type: datastore.TypeMemory}
		store := New(config)
		err := store.Initialize(config)
		require.NoError(t, err)
		defer store.Close()
		
		ctx := context.Background()
		
		// Healthy store
		err = store.HealthCheck(ctx)
		assert.NoError(t, err)
		
		// Health check with timeout
		timeoutCtx, cancel := context.WithTimeout(ctx, time.Millisecond)
		defer cancel()
		
		err = store.HealthCheck(timeoutCtx)
		assert.NoError(t, err) // Memory store is fast
		
		// Health check after close
		store.Close()
		err = store.HealthCheck(ctx)
		assert.Error(t, err)
	})

	t.Run("Info", func(t *testing.T) {
		config := datastore.Config{Type: datastore.TypeMemory}
		store := New(config)
		err := store.Initialize(config)
		require.NoError(t, err)
		defer store.Close()
		
		info := store.Info()
		assert.Equal(t, datastore.TypeMemory, info["type"])
		assert.Contains(t, info, "uptime")
		assert.Contains(t, info, "objects")
		// Check for either "memory_usage" or "memory_used"
		hasMemoryUsage := info["memory_usage"] != nil || info["memory_used"] != nil
		assert.True(t, hasMemoryUsage, "Info should contain memory usage information")
		
		// Add some data and check info updates
		store.PutObject("info-test", []byte("test"))
		
		newInfo := store.Info()
		// Handle different possible types for objects count
		if objCount, ok := newInfo["objects"].(int64); ok {
			assert.GreaterOrEqual(t, objCount, int64(1))
		} else if objCount, ok := newInfo["objects"].(int); ok {
			assert.GreaterOrEqual(t, int64(objCount), int64(1))
		}
		
		// Check memory usage increased
		if memUsed, ok := newInfo["memory_used"]; ok {
			if memUsedInt64, ok := memUsed.(int64); ok {
				assert.GreaterOrEqual(t, memUsedInt64, int64(0))
			} else if memUsedInt, ok := memUsed.(int); ok {
				assert.GreaterOrEqual(t, int64(memUsedInt), int64(0))
			}
		}
	})
}

func TestMemoryStore_Metrics(t *testing.T) {
	config := datastore.Config{Type: datastore.TypeMemory}
	store := New(config)
	err := store.Initialize(config)
	require.NoError(t, err)
	defer store.Close()

	// Initial metrics
	metrics := store.GetMetrics()
	assert.GreaterOrEqual(t, metrics.Reads, int64(0))
	assert.GreaterOrEqual(t, metrics.Writes, int64(0))
	assert.GreaterOrEqual(t, metrics.Deletes, int64(0))
	
	initialReads := metrics.Reads
	initialWrites := metrics.Writes
	initialDeletes := metrics.Deletes
	
	// Perform operations
	err = store.PutObject("metrics-test", []byte("data"))
	assert.NoError(t, err)
	
	_, err = store.GetObject("metrics-test")
	assert.NoError(t, err)
	
	err = store.DeleteObject("metrics-test")
	assert.NoError(t, err)
	
	// Check metrics increased
	newMetrics := store.GetMetrics()
	assert.Greater(t, newMetrics.Writes, initialWrites)
	assert.Greater(t, newMetrics.Reads, initialReads)
	assert.Greater(t, newMetrics.Deletes, initialDeletes)
	
	// Batch operations should increase metrics accordingly
	initialMetrics := store.GetMetrics()
	
	objects := map[string][]byte{
		"batch1": []byte("data1"),
		"batch2": []byte("data2"),
		"batch3": []byte("data3"),
	}
	
	err = store.PutObjects(objects)
	assert.NoError(t, err)
	
	batchMetrics := store.GetMetrics()
	assert.Equal(t, initialMetrics.Writes+3, batchMetrics.Writes)
}