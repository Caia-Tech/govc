package datastore

import (
	"bytes"
	"crypto/rand"
	"fmt"
	"math"
	"strings"
	"testing"
	"unicode/utf8"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// FuzzTestSuite runs property-based and fuzzing tests
func FuzzTestSuite(t *testing.T, store DataStore) {
	t.Run("PropertyBasedTests", func(t *testing.T) {
		runPropertyBasedTests(t, store)
	})
	
	t.Run("CorruptionResilienceTests", func(t *testing.T) {
		runCorruptionResilienceTests(t, store)
	})
	
	t.Run("BoundaryValueTests", func(t *testing.T) {
		runBoundaryValueTests(t, store)
	})
	
	t.Run("UnicodeAndEncodingTests", func(t *testing.T) {
		runUnicodeAndEncodingTests(t, store)
	})
}

// runPropertyBasedTests tests invariants that should hold for any input
func runPropertyBasedTests(t *testing.T, store DataStore) {
	// Property: Put then Get should return the same data
	t.Run("PutGetInvariant", func(t *testing.T) {
		for i := 0; i < 100; i++ {
			hash := generateRandomHash()
			originalData := generateRandomData(1 + rand.Intn(10000))
			
			// Put data
			err := store.PutObject(hash, originalData)
			require.NoError(t, err, "Put should succeed for valid data")
			
			// Get data
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err, "Get should succeed after Put")
			
			// Data should be identical
			assert.Equal(t, originalData, retrievedData, 
				"Retrieved data should match original for hash %s", hash)
		}
	})
	
	// Property: HasObject should be consistent with GetObject
	t.Run("HasObjectConsistency", func(t *testing.T) {
		for i := 0; i < 50; i++ {
			hash := generateRandomHash()
			data := generateRandomData(1 + rand.Intn(1000))
			
			// Initially should not exist
			exists, err := store.HasObject(hash)
			require.NoError(t, err)
			assert.False(t, exists, "Object should not exist initially")
			
			// After put, should exist
			err = store.PutObject(hash, data)
			require.NoError(t, err)
			
			exists, err = store.HasObject(hash)
			require.NoError(t, err)
			assert.True(t, exists, "Object should exist after Put")
			
			// GetObject should succeed
			_, err = store.GetObject(hash)
			assert.NoError(t, err, "GetObject should succeed when HasObject returns true")
		}
	})
	
	// Property: Delete should remove objects
	t.Run("DeleteRemovesObject", func(t *testing.T) {
		for i := 0; i < 30; i++ {
			hash := generateRandomHash()
			data := generateRandomData(100)
			
			// Put object
			err := store.PutObject(hash, data)
			require.NoError(t, err)
			
			// Verify exists
			exists, err := store.HasObject(hash)
			require.NoError(t, err)
			require.True(t, exists)
			
			// Delete object
			err = store.DeleteObject(hash)
			require.NoError(t, err)
			
			// Should no longer exist
			exists, err = store.HasObject(hash)
			require.NoError(t, err)
			assert.False(t, exists, "Object should not exist after Delete")
			
			// GetObject should fail
			_, err = store.GetObject(hash)
			assert.ErrorIs(t, err, ErrNotFound, "GetObject should return ErrNotFound after Delete")
		}
	})
	
	// Property: Object size should be accurate
	t.Run("ObjectSizeAccuracy", func(t *testing.T) {
		for i := 0; i < 50; i++ {
			hash := generateRandomHash()
			expectedSize := rand.Intn(5000)
			data := generateRandomData(expectedSize)
			
			err := store.PutObject(hash, data)
			require.NoError(t, err)
			
			actualSize, err := store.GetObjectSize(hash)
			require.NoError(t, err)
			
			assert.Equal(t, int64(expectedSize), actualSize, 
				"Object size should match data length for hash %s", hash)
		}
	})
}

// runCorruptionResilienceTests tests handling of corrupted or malformed data
func runCorruptionResilienceTests(t *testing.T, store DataStore) {
	t.Run("InvalidHashes", func(t *testing.T) {
		invalidHashes := []string{
			"", // Empty hash
			strings.Repeat("a", 10000), // Extremely long hash
			"hash\x00with\x01nulls", // Hash with null bytes
			"hash\nwith\nnewlines", // Hash with newlines
			"hash\twith\ttabs", // Hash with tabs
			"../../../etc/passwd", // Path traversal attempt
			"CON", "PRN", "AUX", "NUL", // Windows reserved names
			strings.Repeat("🚀", 100), // Unicode in hash
		}
		
		data := []byte("test data")
		
		for _, hash := range invalidHashes {
			// Store should handle invalid hashes gracefully
			err := store.PutObject(hash, data)
			// Don't assert specific error, just that it doesn't crash
			t.Logf("PutObject with hash %q returned: %v", hash, err)
			
			_, err = store.GetObject(hash)
			t.Logf("GetObject with hash %q returned: %v", hash, err)
			
			_, err = store.HasObject(hash)
			t.Logf("HasObject with hash %q returned: %v", hash, err)
		}
	})
	
	t.Run("ExtremeDataSizes", func(t *testing.T) {
		testSizes := []int{
			0,                    // Empty data
			1,                    // Single byte
			math.MaxUint8,        // 255 bytes
			math.MaxUint16,       // 65KB
			1024 * 1024,         // 1MB
			10 * 1024 * 1024,    // 10MB (if supported)
		}
		
		for _, size := range testSizes {
			t.Run(fmt.Sprintf("Size%d", size), func(t *testing.T) {
				hash := fmt.Sprintf("extreme-size-%d", size)
				
				// For very large sizes, we might expect errors
				data := make([]byte, size)
				if size > 0 {
					// Fill with pattern to detect corruption
					for i := range data {
						data[i] = byte(i % 256)
					}
				}
				
				err := store.PutObject(hash, data)
				if err != nil {
					t.Logf("PutObject failed for size %d: %v", size, err)
					return // Skip if store doesn't support this size
				}
				
				retrievedData, err := store.GetObject(hash)
				require.NoError(t, err, "GetObject should succeed if PutObject succeeded")
				
				assert.Equal(t, data, retrievedData, 
					"Data integrity should be maintained for size %d", size)
			})
		}
	})
	
	t.Run("MalformedBinaryData", func(t *testing.T) {
		malformedData := [][]byte{
			{0x00},                           // Null byte
			{0xFF},                           // Max byte
			{0x00, 0xFF, 0x00, 0xFF},        // Alternating pattern
			bytes.Repeat([]byte{0x00}, 1000), // Many nulls
			bytes.Repeat([]byte{0xFF}, 1000), // Many max bytes
		}
		
		for i, data := range malformedData {
			hash := fmt.Sprintf("malformed-%d", i)
			
			err := store.PutObject(hash, data)
			require.NoError(t, err, "Should handle malformed binary data")
			
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err)
			
			assert.Equal(t, data, retrievedData, 
				"Malformed binary data should be preserved")
		}
	})
}

// runBoundaryValueTests tests edge cases and boundary conditions
func runBoundaryValueTests(t *testing.T, store DataStore) {
	t.Run("NumericBoundaries", func(t *testing.T) {
		// Test with hashes that look like numbers
		numericHashes := []string{
			"0", "1", "-1",
			fmt.Sprintf("%d", math.MaxInt64),
			fmt.Sprintf("%d", math.MinInt64),
			"3.14159", "-3.14159",
			"1e10", "1e-10",
			"0x1234", "0b1010",
		}
		
		for _, hash := range numericHashes {
			data := []byte(fmt.Sprintf("data for %s", hash))
			
			err := store.PutObject(hash, data)
			require.NoError(t, err, "Should handle numeric-looking hash: %s", hash)
			
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err)
			assert.Equal(t, data, retrievedData)
		}
	})
	
	t.Run("SpecialCharacters", func(t *testing.T) {
		specialChars := []string{
			"!@#$%^&*()",
			"<>?:|{}[]",
			"~`+=_-",
			"\"'\\",
			" ", "  ", "\t", "\n", "\r\n",
		}
		
		for i, chars := range specialChars {
			hash := fmt.Sprintf("special-%d-%s", i, chars)
			data := []byte("test data")
			
			err := store.PutObject(hash, data)
			// Some stores might reject certain special characters
			if err != nil {
				t.Logf("Store rejected hash with special chars %q: %v", chars, err)
				continue
			}
			
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err)
			assert.Equal(t, data, retrievedData)
		}
	})
}

// runUnicodeAndEncodingTests tests Unicode and encoding edge cases
func runUnicodeAndEncodingTests(t *testing.T, store DataStore) {
	t.Run("UnicodeData", func(t *testing.T) {
		unicodeStrings := []string{
			"Hello, 世界",
			"Здравствуй мир",
			"مرحبا بالعالم",
			"שלום עולם",
			"こんにちは世界",
			"🚀🌟💻🔥⚡",
			"नमस्ते दुनिया",
			"Γεια σου κόσμε",
		}
		
		for i, str := range unicodeStrings {
			hash := fmt.Sprintf("unicode-test-%d", i)
			data := []byte(str)
			
			err := store.PutObject(hash, data)
			require.NoError(t, err, "Should handle Unicode data: %s", str)
			
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err)
			assert.Equal(t, data, retrievedData, "Unicode data should be preserved")
			
			// Verify it's still valid UTF-8
			assert.True(t, utf8.Valid(retrievedData), 
				"Retrieved data should still be valid UTF-8")
		}
	})
	
	t.Run("InvalidUTF8", func(t *testing.T) {
		invalidUTF8 := [][]byte{
			{0xff, 0xfe, 0xfd}, // Invalid UTF-8 sequence
			{0x80, 0x80},       // Invalid continuation bytes
			{0xc0, 0x80},       // Overlong encoding
			{0xed, 0xa0, 0x80}, // Surrogate pair
		}
		
		for i, data := range invalidUTF8 {
			hash := fmt.Sprintf("invalid-utf8-%d", i)
			
			err := store.PutObject(hash, data)
			require.NoError(t, err, "Should handle invalid UTF-8 as binary data")
			
			retrievedData, err := store.GetObject(hash)
			require.NoError(t, err)
			assert.Equal(t, data, retrievedData, 
				"Invalid UTF-8 should be preserved as-is")
		}
	})
	
	t.Run("EncodingNormalization", func(t *testing.T) {
		// Test different Unicode normalizations of the same logical string
		// "é" can be represented as:
		// 1. Single character: é (U+00E9)
		// 2. Composed form: e + ́ (U+0065 + U+0301)
		
		single := []byte{0xc3, 0xa9}      // é as single char
		composed := []byte{0x65, 0xcc, 0x81} // e + combining acute
		
		err := store.PutObject("single", single)
		require.NoError(t, err)
		
		err = store.PutObject("composed", composed)
		require.NoError(t, err)
		
		singleRetrieved, err := store.GetObject("single")
		require.NoError(t, err)
		
		composedRetrieved, err := store.GetObject("composed")
		require.NoError(t, err)
		
		// Data should be preserved exactly (no normalization)
		assert.Equal(t, single, singleRetrieved)
		assert.Equal(t, composed, composedRetrieved)
		assert.NotEqual(t, singleRetrieved, composedRetrieved, 
			"Different Unicode representations should remain distinct")
	})
}

// generateRandomHash creates a random hash for testing
func generateRandomHash() string {
	const hashChars = "abcdef0123456789"
	hash := make([]byte, 40) // SHA-1 length
	for i := range hash {
		hash[i] = hashChars[rand.Intn(len(hashChars))]
	}
	return string(hash)
}

// generateRandomData creates random binary data
func generateRandomData(size int) []byte {
	data := make([]byte, size)
	rand.Read(data)
	return data
}