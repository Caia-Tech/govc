package search

import (
	"fmt"
)

// Query Engine Integration Methods for Repository

// Query executes a query using the integrated query engine
func (r *Repository) Query(req *QueryRequest) (*QueryResult, error) {
	if r.queryEngine == nil {
		return nil, fmt.Errorf("query engine not initialized")
	}
	return r.queryEngine.Query(req)
}

// FindFiles finds files by path pattern
func (r *Repository) FindFiles(pattern string) ([]*FileEntry, error) {
	req := &QueryRequest{
		Type:  QueryByPattern,
		Query: pattern,
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Files, nil
}

// FindFileByPath finds a specific file by exact path
func (r *Repository) FindFileByPath(path string) (*FileEntry, error) {
	req := &QueryRequest{
		Type:  QueryByPath,
		Query: path,
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	if len(result.Files) == 0 {
		return nil, fmt.Errorf("file not found: %s", path)
	}
	
	return result.Files[0], nil
}

// SearchFileContent searches for text within file contents
func (r *Repository) SearchFileContent(searchText string) ([]*FileEntry, error) {
	req := &QueryRequest{
		Type:  QueryByContent,
		Query: searchText,
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Files, nil
}

// FindCommitsByAuthor finds commits by a specific author
func (r *Repository) FindCommitsByAuthor(author string) ([]*CommitEntry, error) {
	req := &QueryRequest{
		Type:  QueryByAuthor,
		Query: author,
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Commits, nil
}

// SearchCommitMessages searches for text within commit messages
func (r *Repository) SearchCommitMessages(searchText string) ([]*CommitEntry, error) {
	req := &QueryRequest{
		Type:  QueryByCommit,
		Query: searchText,
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Commits, nil
}

// FindCommitsByDateRange finds commits within a date range
func (r *Repository) FindCommitsByDateRange(startDate, endDate string) ([]*CommitEntry, error) {
	req := &QueryRequest{
		Type: QueryByDate,
		Filters: map[string]interface{}{
			"start_date": startDate,
			"end_date":   endDate,
		},
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Commits, nil
}

// FindByHash finds files or commits by hash
func (r *Repository) FindByHash(hash string) (*QueryResult, error) {
	req := &QueryRequest{
		Type:  QueryByHash,
		Query: hash,
	}
	
	return r.Query(req)
}

// GetRecentCommits gets the most recent N commits
func (r *Repository) GetRecentCommits(limit int) ([]*CommitEntry, error) {
	req := &QueryRequest{
		Type:      QueryByDate,
		Limit:     limit,
		SortBy:    "date",
		SortOrder: "desc",
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Commits, nil
}

// GetLargestFiles gets files sorted by size (largest first)
func (r *Repository) GetLargestFiles(limit int) ([]*FileEntry, error) {
	req := &QueryRequest{
		Type:      QueryByPattern,
		Query:     "*", // Match all files
		Limit:     limit,
		SortBy:    "size",
		SortOrder: "desc",
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Files, nil
}

// GetRecentlyModifiedFiles gets files sorted by modification time
func (r *Repository) GetRecentlyModifiedFiles(limit int) ([]*FileEntry, error) {
	req := &QueryRequest{
		Type:      QueryByPattern,
		Query:     "*", // Match all files
		Limit:     limit,
		SortBy:    "modified",
		SortOrder: "desc",
	}
	
	result, err := r.Query(req)
	if err != nil {
		return nil, err
	}
	
	return result.Files, nil
}

// Advanced Query Methods

// ComplexSearch performs a complex search with multiple criteria
func (r *Repository) ComplexSearch(searchReq ComplexSearchRequest) (*QueryResult, error) {
	req := &QueryRequest{
		Type:      searchReq.Type,
		Query:     searchReq.Query,
		Filters:   searchReq.Filters,
		Limit:     searchReq.Limit,
		Offset:    searchReq.Offset,
		SortBy:    searchReq.SortBy,
		SortOrder: searchReq.SortOrder,
	}
	
	return r.Query(req)
}

// ComplexSearchRequest represents a complex search request
type ComplexSearchRequest struct {
	Type      QueryType                `json:"type"`
	Query     string                   `json:"query"`
	Filters   map[string]interface{}   `json:"filters"`
	Limit     int                      `json:"limit"`
	Offset    int                      `json:"offset"`
	SortBy    string                   `json:"sort_by"`
	SortOrder string                   `json:"sort_order"`
}

// GetQueryEngineStats returns query engine performance statistics
func (r *Repository) GetQueryEngineStats() QueryEngineStats {
	if r.queryEngine == nil {
		return QueryEngineStats{}
	}
	return r.queryEngine.GetQueryStats()
}

// RebuildIndexes forces a rebuild of all query indexes
func (r *Repository) RebuildIndexes() {
	if r.queryEngine != nil {
		r.queryEngine.rebuildAllIndexes()
	}
}

// Query Builder Methods for fluent interface

// QueryBuilder provides a fluent interface for building queries
type QueryBuilder struct {
	repo *Repository
	req  *QueryRequest
}

// NewQueryBuilder creates a new query builder
func (r *Repository) NewQueryBuilder() *QueryBuilder {
	return &QueryBuilder{
		repo: r,
		req: &QueryRequest{
			Filters: make(map[string]interface{}),
		},
	}
}

// Files sets the query to search for files
func (qb *QueryBuilder) Files() *QueryBuilder {
	qb.req.Type = QueryByPattern
	return qb
}

// Commits sets the query to search for commits
func (qb *QueryBuilder) Commits() *QueryBuilder {
	qb.req.Type = QueryByCommit
	return qb
}

// Content sets the query to search file contents
func (qb *QueryBuilder) Content() *QueryBuilder {
	qb.req.Type = QueryByContent
	return qb
}

// Path sets the query to search by specific path
func (qb *QueryBuilder) Path() *QueryBuilder {
	qb.req.Type = QueryByPath
	return qb
}

// Author sets the query to search by author
func (qb *QueryBuilder) Author() *QueryBuilder {
	qb.req.Type = QueryByAuthor
	return qb
}

// Hash sets the query to search by hash
func (qb *QueryBuilder) Hash() *QueryBuilder {
	qb.req.Type = QueryByHash
	return qb
}

// WithQuery sets the search query string
func (qb *QueryBuilder) WithQuery(query string) *QueryBuilder {
	qb.req.Query = query
	return qb
}

// WithPattern sets the search pattern (alias for WithQuery for file searches)
func (qb *QueryBuilder) WithPattern(pattern string) *QueryBuilder {
	qb.req.Query = pattern
	return qb
}

// WithLimit sets the maximum number of results
func (qb *QueryBuilder) WithLimit(limit int) *QueryBuilder {
	qb.req.Limit = limit
	return qb
}

// WithOffset sets the result offset for pagination
func (qb *QueryBuilder) WithOffset(offset int) *QueryBuilder {
	qb.req.Offset = offset
	return qb
}

// SortBy sets the sort field and order
func (qb *QueryBuilder) SortBy(field string, order string) *QueryBuilder {
	qb.req.SortBy = field
	qb.req.SortOrder = order
	return qb
}

// SortByDate sorts by date (newest first)
func (qb *QueryBuilder) SortByDate() *QueryBuilder {
	qb.req.SortBy = "date"
	qb.req.SortOrder = "desc"
	return qb
}

// SortBySize sorts by size (largest first)
func (qb *QueryBuilder) SortBySize() *QueryBuilder {
	qb.req.SortBy = "size"
	qb.req.SortOrder = "desc"
	return qb
}

// SortByPath sorts by path alphabetically
func (qb *QueryBuilder) SortByPath() *QueryBuilder {
	qb.req.SortBy = "path"
	qb.req.SortOrder = "asc"
	return qb
}

// WithDateRange sets a date range filter
func (qb *QueryBuilder) WithDateRange(startDate, endDate string) *QueryBuilder {
	qb.req.Filters["start_date"] = startDate
	qb.req.Filters["end_date"] = endDate
	return qb
}

// WithFilter adds a custom filter
func (qb *QueryBuilder) WithFilter(key string, value interface{}) *QueryBuilder {
	qb.req.Filters[key] = value
	return qb
}

// Execute executes the query and returns results
func (qb *QueryBuilder) Execute() (*QueryResult, error) {
	return qb.repo.Query(qb.req)
}

// ExecuteFiles executes the query and returns only files
func (qb *QueryBuilder) ExecuteFiles() ([]*FileEntry, error) {
	result, err := qb.Execute()
	if err != nil {
		return nil, err
	}
	return result.Files, nil
}

// ExecuteCommits executes the query and returns only commits
func (qb *QueryBuilder) ExecuteCommits() ([]*CommitEntry, error) {
	result, err := qb.Execute()
	if err != nil {
		return nil, err
	}
	return result.Commits, nil
}

// Convenience methods for common queries

// FindJSONFiles finds all JSON files
func (r *Repository) FindJSONFiles() ([]*FileEntry, error) {
	return r.NewQueryBuilder().Files().WithPattern("*.json").ExecuteFiles()
}

// FindConfigFiles finds configuration files
func (r *Repository) FindConfigFiles() ([]*FileEntry, error) {
	return r.NewQueryBuilder().Files().WithPattern("*.{json,yaml,yml,toml,ini,conf,config}").ExecuteFiles()
}

// FindLargeFiles finds files larger than a specific size
func (r *Repository) FindLargeFiles(minSizeBytes int64) ([]*FileEntry, error) {
	files, err := r.NewQueryBuilder().Files().WithPattern("*").SortBySize().ExecuteFiles()
	if err != nil {
		return nil, err
	}
	
	// Filter by size
	var largeFiles []*FileEntry
	for _, file := range files {
		if file.Size >= minSizeBytes {
			largeFiles = append(largeFiles, file)
		}
	}
	
	return largeFiles, nil
}

// FindCommitsToday finds commits from today
func (r *Repository) FindCommitsToday() ([]*CommitEntry, error) {
	today := fmt.Sprintf("%sT00:00:00Z", getCurrentDate())
	tomorrow := fmt.Sprintf("%sT23:59:59Z", getCurrentDate())
	
	return r.NewQueryBuilder().Commits().WithDateRange(today, tomorrow).ExecuteCommits()
}

// getCurrentDate returns current date in YYYY-MM-DD format
func getCurrentDate() string {
	// Simple date implementation - in production would use time.Now().Format()
	return "2024-08-09" // For now, return fixed date
}