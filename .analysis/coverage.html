
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Caia-Tech/govc/auth/apikey.go (62.6%)</option>
				
				<option value="file1">github.com/Caia-Tech/govc/auth/jwt.go (54.5%)</option>
				
				<option value="file2">github.com/Caia-Tech/govc/auth/middleware.go (74.5%)</option>
				
				<option value="file3">github.com/Caia-Tech/govc/auth/rbac.go (59.2%)</option>
				
				<option value="file4">github.com/Caia-Tech/govc/config/config.go (74.0%)</option>
				
				<option value="file5">github.com/Caia-Tech/govc/logging/logger.go (85.9%)</option>
				
				<option value="file6">github.com/Caia-Tech/govc/metrics/prometheus.go (100.0%)</option>
				
				<option value="file7">github.com/Caia-Tech/govc/pkg/core/adapters.go (60.9%)</option>
				
				<option value="file8">github.com/Caia-Tech/govc/pkg/core/config.go (40.0%)</option>
				
				<option value="file9">github.com/Caia-Tech/govc/pkg/core/interfaces.go (0.0%)</option>
				
				<option value="file10">github.com/Caia-Tech/govc/pkg/core/migration.go (0.0%)</option>
				
				<option value="file11">github.com/Caia-Tech/govc/pkg/core/operations.go (44.2%)</option>
				
				<option value="file12">github.com/Caia-Tech/govc/pkg/core/repository.go (65.4%)</option>
				
				<option value="file13">github.com/Caia-Tech/govc/pkg/core/stash.go (79.1%)</option>
				
				<option value="file14">github.com/Caia-Tech/govc/pkg/core/webhooks.go (93.0%)</option>
				
				<option value="file15">github.com/Caia-Tech/govc/pkg/core/workspace.go (82.8%)</option>
				
				<option value="file16">github.com/Caia-Tech/govc/pkg/object/object.go (54.4%)</option>
				
				<option value="file17">github.com/Caia-Tech/govc/pkg/refs/refs.go (60.5%)</option>
				
				<option value="file18">github.com/Caia-Tech/govc/pkg/storage/hybrid.go (0.0%)</option>
				
				<option value="file19">github.com/Caia-Tech/govc/pkg/storage/interfaces.go (100.0%)</option>
				
				<option value="file20">github.com/Caia-Tech/govc/pkg/storage/memory.go (95.2%)</option>
				
				<option value="file21">github.com/Caia-Tech/govc/pkg/storage/refs_adapter.go (50.0%)</option>
				
				<option value="file22">github.com/Caia-Tech/govc/pkg/storage/refs_store_adapter.go (81.5%)</option>
				
				<option value="file23">github.com/Caia-Tech/govc/pkg/storage/storage.go (60.4%)</option>
				
				<option value="file24">github.com/Caia-Tech/govc/pkg/storage/store_adapter.go (70.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "fmt"
        "strings"
        "sync"
        "time"
)

// APIKey represents an API key for authentication
type APIKey struct {
        ID          string                  `json:"id"`
        Name        string                  `json:"name"`
        HashedKey   string                  `json:"-"` // Never expose the actual key
        UserID      string                  `json:"user_id"`
        Permissions []Permission            `json:"permissions"`
        RepoPerms   map[string][]Permission `json:"repo_permissions"`
        Active      bool                    `json:"active"`
        LastUsed    *time.Time              `json:"last_used,omitempty"`
        CreatedAt   time.Time               `json:"created_at"`
        ExpiresAt   *time.Time              `json:"expires_at,omitempty"`
}

// APIKeyManager manages API keys
type APIKeyManager struct {
        keys map[string]*APIKey // keyed by hashed key
        rbac *RBAC
        mu   sync.RWMutex
}

// NewAPIKeyManager creates a new API key manager
func NewAPIKeyManager(rbac *RBAC) *APIKeyManager <span class="cov3" title="17">{
        return &amp;APIKeyManager{
                keys: make(map[string]*APIKey),
                rbac: rbac,
        }
}</span>

// GenerateAPIKey creates a new API key for a user
func (m *APIKeyManager) GenerateAPIKey(userID, name string, permissions []Permission, repoPerms map[string][]Permission, expiresAt *time.Time) (string, *APIKey, error) <span class="cov6" title="119">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Verify user exists
        if _, err := m.rbac.GetUser(userID); err != nil </span><span class="cov1" title="1">{
                return "", nil, fmt.Errorf("user not found: %w", err)
        }</span>

        // Generate a secure random key
        <span class="cov6" title="118">keyBytes := make([]byte, 32) // 256 bits
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to generate random key: %w", err)
        }</span>

        // Create the key string with a prefix for identification
        <span class="cov6" title="118">keyString := "govc_" + base64.URLEncoding.EncodeToString(keyBytes)

        // Hash the key for storage
        hash := sha256.Sum256([]byte(keyString))
        hashedKey := hex.EncodeToString(hash[:])

        // Generate unique ID
        id := generateAPIKeyID()

        // Create API key record
        apiKey := &amp;APIKey{
                ID:          id,
                Name:        name,
                HashedKey:   hashedKey,
                UserID:      userID,
                Permissions: permissions,
                RepoPerms:   repoPerms,
                Active:      true,
                CreatedAt:   time.Now(),
                ExpiresAt:   expiresAt,
        }

        // Store the API key
        m.keys[hashedKey] = apiKey

        return keyString, apiKey, nil</span>
}

// ValidateAPIKey validates an API key and returns the associated API key record
func (m *APIKeyManager) ValidateAPIKey(keyString string) (*APIKey, error) <span class="cov3" title="10">{
        // Validate key format
        if !strings.HasPrefix(keyString, "govc_") </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("invalid API key format")
        }</span>

        // Hash the provided key
        <span class="cov3" title="7">hash := sha256.Sum256([]byte(keyString))
        hashedKey := hex.EncodeToString(hash[:])

        m.mu.RLock()
        defer m.mu.RUnlock()

        apiKey, exists := m.keys[hashedKey]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("API key not found")
        }</span>

        // Check if key is active
        <span class="cov2" title="6">if !apiKey.Active </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("API key is deactivated")
        }</span>

        // Check if key has expired
        <span class="cov2" title="3">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key has expired")
        }</span>

        // Update last used timestamp (in a separate goroutine to avoid holding the lock)
        <span class="cov2" title="3">go func() </span><span class="cov2" title="3">{
                m.mu.Lock()
                defer m.mu.Unlock()
                now := time.Now()
                apiKey.LastUsed = &amp;now
        }</span>()

        // Return a copy to prevent external modification
        <span class="cov2" title="3">apiKeyCopy := *apiKey
        apiKeyCopy.Permissions = make([]Permission, len(apiKey.Permissions))
        copy(apiKeyCopy.Permissions, apiKey.Permissions)

        if apiKey.RepoPerms != nil </span><span class="cov0" title="0">{
                apiKeyCopy.RepoPerms = make(map[string][]Permission)
                for repo, perms := range apiKey.RepoPerms </span><span class="cov0" title="0">{
                        apiKeyCopy.RepoPerms[repo] = make([]Permission, len(perms))
                        copy(apiKeyCopy.RepoPerms[repo], perms)
                }</span>
        }

        <span class="cov2" title="3">return &amp;apiKeyCopy, nil</span>
}

// GetAPIKey retrieves an API key by ID
func (m *APIKeyManager) GetAPIKey(keyID string) (*APIKey, error) <span class="cov5" title="103">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, apiKey := range m.keys </span><span class="cov10" title="5228">{
                if apiKey.ID == keyID </span><span class="cov5" title="101">{
                        // Return a copy
                        apiKeyCopy := *apiKey
                        apiKeyCopy.Permissions = make([]Permission, len(apiKey.Permissions))
                        copy(apiKeyCopy.Permissions, apiKey.Permissions)

                        if apiKey.RepoPerms != nil </span><span class="cov0" title="0">{
                                apiKeyCopy.RepoPerms = make(map[string][]Permission)
                                for repo, perms := range apiKey.RepoPerms </span><span class="cov0" title="0">{
                                        apiKeyCopy.RepoPerms[repo] = make([]Permission, len(perms))
                                        copy(apiKeyCopy.RepoPerms[repo], perms)
                                }</span>
                        }

                        <span class="cov5" title="101">return &amp;apiKeyCopy, nil</span>
                }
        }

        <span class="cov1" title="2">return nil, fmt.Errorf("API key not found")</span>
}

// ListAPIKeys returns all API keys for a user
func (m *APIKeyManager) ListAPIKeys(userID string) ([]*APIKey, error) <span class="cov2" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var userKeys []*APIKey
        for _, apiKey := range m.keys </span><span class="cov3" title="9">{
                if apiKey.UserID == userID </span><span class="cov2" title="3">{
                        // Return a copy
                        apiKeyCopy := *apiKey
                        apiKeyCopy.Permissions = make([]Permission, len(apiKey.Permissions))
                        copy(apiKeyCopy.Permissions, apiKey.Permissions)

                        if apiKey.RepoPerms != nil </span><span class="cov0" title="0">{
                                apiKeyCopy.RepoPerms = make(map[string][]Permission)
                                for repo, perms := range apiKey.RepoPerms </span><span class="cov0" title="0">{
                                        apiKeyCopy.RepoPerms[repo] = make([]Permission, len(perms))
                                        copy(apiKeyCopy.RepoPerms[repo], perms)
                                }</span>
                        }

                        <span class="cov2" title="3">userKeys = append(userKeys, &amp;apiKeyCopy)</span>
                }
        }

        <span class="cov2" title="3">return userKeys, nil</span>
}

// RevokeAPIKey deactivates an API key
func (m *APIKeyManager) RevokeAPIKey(keyID string) error <span class="cov2" title="5">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, apiKey := range m.keys </span><span class="cov3" title="7">{
                if apiKey.ID == keyID </span><span class="cov2" title="4">{
                        apiKey.Active = false
                        return nil
                }</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("API key not found")</span>
}

// DeleteAPIKey permanently removes an API key
func (m *APIKeyManager) DeleteAPIKey(keyID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for hashedKey, apiKey := range m.keys </span><span class="cov0" title="0">{
                if apiKey.ID == keyID </span><span class="cov0" title="0">{
                        delete(m.keys, hashedKey)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("API key not found")</span>
}

// HasPermission checks if an API key has a specific permission
func (m *APIKeyManager) HasPermission(apiKey *APIKey, permission Permission) bool <span class="cov0" title="0">{
        // Check direct permissions
        for _, perm := range apiKey.Permissions </span><span class="cov0" title="0">{
                if perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Check for admin permissions
                <span class="cov0" title="0">if perm == PermissionSystemAdmin ||
                        (strings.HasPrefix(string(permission), "repo:") &amp;&amp; perm == PermissionRepoAdmin) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// HasRepositoryPermission checks if an API key has permission for a specific repository
func (m *APIKeyManager) HasRepositoryPermission(apiKey *APIKey, repoID string, permission Permission) bool <span class="cov0" title="0">{
        // Check global permissions first
        if m.HasPermission(apiKey, permission) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check repository-specific permissions
        <span class="cov0" title="0">if apiKey.RepoPerms != nil </span><span class="cov0" title="0">{
                if repoPerms, exists := apiKey.RepoPerms[repoID]; exists </span><span class="cov0" title="0">{
                        for _, perm := range repoPerms </span><span class="cov0" title="0">{
                                if perm == permission || perm == PermissionRepoAdmin </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

// UpdateAPIKeyPermissions updates the permissions for an API key
func (m *APIKeyManager) UpdateAPIKeyPermissions(keyID string, permissions []Permission, repoPerms map[string][]Permission) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, apiKey := range m.keys </span><span class="cov0" title="0">{
                if apiKey.ID == keyID </span><span class="cov0" title="0">{
                        apiKey.Permissions = permissions
                        apiKey.RepoPerms = repoPerms
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("API key not found")</span>
}

// CleanupExpiredKeys removes expired API keys
func (m *APIKeyManager) CleanupExpiredKeys() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        now := time.Now()
        var removed int

        for hashedKey, apiKey := range m.keys </span><span class="cov0" title="0">{
                if apiKey.ExpiresAt != nil &amp;&amp; now.After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                        delete(m.keys, hashedKey)
                        removed++
                }</span>
        }

        <span class="cov0" title="0">return removed</span>
}

// GetKeyStats returns statistics about API keys
func (m *APIKeyManager) GetKeyStats() map[string]int <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := map[string]int{
                "total":    0,
                "active":   0,
                "inactive": 0,
                "expired":  0,
        }

        now := time.Now()
        for _, apiKey := range m.keys </span><span class="cov2" title="3">{
                stats["total"]++

                if apiKey.ExpiresAt != nil &amp;&amp; now.After(*apiKey.ExpiresAt) </span><span class="cov1" title="1">{
                        stats["expired"]++
                }</span> else<span class="cov1" title="2"> if apiKey.Active </span><span class="cov1" title="1">{
                        stats["active"]++
                }</span> else<span class="cov1" title="1"> {
                        stats["inactive"]++
                }</span>
        }

        <span class="cov1" title="1">return stats</span>
}

// generateAPIKeyID generates a unique ID for an API key
func generateAPIKeyID() string <span class="cov6" title="118">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// APIKeyInfo represents public information about an API key
type APIKeyInfo struct {
        ID          string                  `json:"id"`
        Name        string                  `json:"name"`
        UserID      string                  `json:"user_id"`
        Permissions []Permission            `json:"permissions"`
        RepoPerms   map[string][]Permission `json:"repo_permissions"`
        Active      bool                    `json:"active"`
        LastUsed    *time.Time              `json:"last_used,omitempty"`
        CreatedAt   time.Time               `json:"created_at"`
        ExpiresAt   *time.Time              `json:"expires_at,omitempty"`
}

// ToInfo converts an APIKey to APIKeyInfo (removes sensitive data)
func (k *APIKey) ToInfo() *APIKeyInfo <span class="cov1" title="1">{
        info := &amp;APIKeyInfo{
                ID:          k.ID,
                Name:        k.Name,
                UserID:      k.UserID,
                Permissions: make([]Permission, len(k.Permissions)),
                Active:      k.Active,
                LastUsed:    k.LastUsed,
                CreatedAt:   k.CreatedAt,
                ExpiresAt:   k.ExpiresAt,
        }

        copy(info.Permissions, k.Permissions)

        if k.RepoPerms != nil </span><span class="cov1" title="1">{
                info.RepoPerms = make(map[string][]Permission)
                for repo, perms := range k.RepoPerms </span><span class="cov1" title="1">{
                        info.RepoPerms[repo] = make([]Permission, len(perms))
                        copy(info.RepoPerms[repo], perms)
                }</span>
        }

        <span class="cov1" title="1">return info</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// CachedToken represents a cached token validation result
type CachedToken struct {
        Claims    *Claims
        ExpiresAt time.Time
}

// JWTAuth handles JWT token generation and validation
type JWTAuth struct {
        Secret     string
        Issuer     string
        TTL        time.Duration
        tokenCache map[string]*CachedToken
        cacheMu    sync.RWMutex
        cacheTTL   time.Duration
}

// Claims represents the JWT claims
type Claims struct {
        UserID      string   `json:"user_id"`
        Username    string   `json:"username"`
        Email       string   `json:"email"`
        Permissions []string `json:"permissions"`
        jwt.RegisteredClaims
}

// NewJWTAuth creates a new JWT authentication handler
func NewJWTAuth(secret, issuer string, ttl time.Duration) *JWTAuth <span class="cov9" title="18">{
        if secret == "" </span><span class="cov0" title="0">{
                // Generate a random secret if none provided (for development)
                secret = generateRandomSecret()
        }</span>

        <span class="cov9" title="18">if ttl == 0 </span><span class="cov0" title="0">{
                ttl = 24 * time.Hour // Default 24 hours
        }</span>

        <span class="cov9" title="18">return &amp;JWTAuth{
                Secret:     secret,
                Issuer:     issuer,
                TTL:        ttl,
                tokenCache: make(map[string]*CachedToken),
                cacheTTL:   5 * time.Minute, // Cache tokens for 5 minutes
        }</span>
}

// GenerateToken creates a new JWT token for a user
func (j *JWTAuth) GenerateToken(userID, username, email string, permissions []string) (string, error) <span class="cov9" title="17">{
        now := time.Now()

        claims := Claims{
                UserID:      userID,
                Username:    username,
                Email:       email,
                Permissions: permissions,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    j.Issuer,
                        Subject:   userID,
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(j.TTL)),
                        NotBefore: jwt.NewNumericDate(now),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(j.Secret))
}</span>

// ValidateToken validates a JWT token and returns the claims with caching
func (j *JWTAuth) ValidateToken(tokenString string) (*Claims, error) <span class="cov10" title="22">{
        // Check cache first
        j.cacheMu.RLock()
        if cached, exists := j.tokenCache[tokenString]; exists </span><span class="cov4" title="3">{
                if time.Now().Before(cached.ExpiresAt) </span><span class="cov4" title="3">{
                        j.cacheMu.RUnlock()
                        return cached.Claims, nil
                }</span>
                // Cache entry expired, will be cleaned up later
        }
        <span class="cov9" title="19">j.cacheMu.RUnlock()

        // Parse and validate token
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="12">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="12">return []byte(j.Secret), nil</span>
        })

        <span class="cov9" title="19">if err != nil </span><span class="cov7" title="10">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov7" title="9">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>

        <span class="cov7" title="9">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        // Cache the result
        <span class="cov7" title="9">j.cacheMu.Lock()
        j.tokenCache[tokenString] = &amp;CachedToken{
                Claims:    claims,
                ExpiresAt: time.Now().Add(j.cacheTTL),
        }
        // Clean up expired entries periodically
        if len(j.tokenCache) &gt; 100 </span><span class="cov0" title="0">{ // Arbitrary threshold
                j.cleanupExpiredTokens()
        }</span>
        <span class="cov7" title="9">j.cacheMu.Unlock()

        return claims, nil</span>
}

// cleanupExpiredTokens removes expired entries from the cache
// Must be called with write lock held
func (j *JWTAuth) cleanupExpiredTokens() <span class="cov0" title="0">{
        now := time.Now()
        for token, cached := range j.tokenCache </span><span class="cov0" title="0">{
                if now.After(cached.ExpiresAt) </span><span class="cov0" title="0">{
                        delete(j.tokenCache, token)
                }</span>
        }
}

// RefreshToken generates a new token with the same claims but extended expiration
func (j *JWTAuth) RefreshToken(tokenString string) (string, error) <span class="cov4" title="3">{
        claims, err := j.ValidateToken(tokenString)
        if err != nil </span><span class="cov3" title="2">{
                return "", fmt.Errorf("cannot refresh invalid token: %w", err)
        }</span>

        // Generate new token with same claims but extended expiration
        <span class="cov1" title="1">return j.GenerateToken(claims.UserID, claims.Username, claims.Email, claims.Permissions)</span>
}

// ExtractUserID extracts user ID from token without full validation (for logging/metrics)
func (j *JWTAuth) ExtractUserID(tokenString string) string <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(j.Secret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok </span><span class="cov0" title="0">{
                return claims.UserID
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// generateRandomSecret generates a cryptographically secure random secret
func generateRandomSecret() string <span class="cov0" title="0">{
        bytes := make([]byte, 32) // 256 bits
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to a default secret (not recommended for production)
                return "default-development-secret-change-in-production"
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes)</span>
}

// TokenInfo represents information about a token
type TokenInfo struct {
        UserID      string    `json:"user_id"`
        Username    string    `json:"username"`
        Email       string    `json:"email"`
        Permissions []string  `json:"permissions"`
        IssuedAt    time.Time `json:"issued_at"`
        ExpiresAt   time.Time `json:"expires_at"`
        Valid       bool      `json:"valid"`
}

// GetTokenInfo returns detailed information about a token
func (j *JWTAuth) GetTokenInfo(tokenString string) *TokenInfo <span class="cov0" title="0">{
        claims, err := j.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;TokenInfo{Valid: false}
        }</span>

        <span class="cov0" title="0">return &amp;TokenInfo{
                UserID:      claims.UserID,
                Username:    claims.Username,
                Email:       claims.Email,
                Permissions: claims.Permissions,
                IssuedAt:    claims.IssuedAt.Time,
                ExpiresAt:   claims.ExpiresAt.Time,
                Valid:       true,
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

// AuthenticatedUser represents an authenticated user context
type AuthenticatedUser struct {
        ID          string                  `json:"id"`
        Username    string                  `json:"username"`
        Email       string                  `json:"email"`
        Permissions []Permission            `json:"permissions"`
        RepoPerms   map[string][]Permission `json:"repo_permissions"`
        AuthMethod  string                  `json:"auth_method"` // "jwt" or "apikey"
        TokenInfo   interface{}             `json:"token_info,omitempty"`
}

// AuthMiddleware provides authentication middleware
type AuthMiddleware struct {
        jwtAuth   *JWTAuth
        apiKeyMgr *APIKeyManager
        rbac      *RBAC
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(jwtAuth *JWTAuth, apiKeyMgr *APIKeyManager, rbac *RBAC) *AuthMiddleware <span class="cov7" title="9">{
        return &amp;AuthMiddleware{
                jwtAuth:   jwtAuth,
                apiKeyMgr: apiKeyMgr,
                rbac:      rbac,
        }
}</span>

// AuthRequired middleware that requires authentication
func (m *AuthMiddleware) AuthRequired() gin.HandlerFunc <span class="cov7" title="8">{
        return func(c *gin.Context) </span><span class="cov9" title="18">{
                user, err := m.authenticateRequest(c)
                if err != nil </span><span class="cov7" title="8">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                // Store user in context
                <span class="cov7" title="10">c.Set("user", user)
                c.Next()</span>
        }
}

// RequirePermission middleware that requires a specific permission
func (m *AuthMiddleware) RequirePermission(permission Permission) gin.HandlerFunc <span class="cov3" title="2">{
        return func(c *gin.Context) </span><span class="cov5" title="4">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov5" title="4">authUser, ok := user.(*AuthenticatedUser)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Invalid user context",
                                "code":  "INTERNAL_ERROR",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov5" title="4">if !m.hasPermission(authUser, permission) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "code":  "FORBIDDEN",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov4" title="3">c.Next()</span>
        }
}

// RequireRepositoryPermission middleware that requires permission for a specific repository
func (m *AuthMiddleware) RequireRepositoryPermission(permission Permission) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov3" title="2">{
                user, exists := c.Get("user")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov3" title="2">authUser, ok := user.(*AuthenticatedUser)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Invalid user context",
                                "code":  "INTERNAL_ERROR",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov3" title="2">repoID := c.Param("repo_id")
                if repoID == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "Repository ID required",
                                "code":  "MISSING_REPO_ID",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov3" title="2">if !m.hasRepositoryPermission(authUser, repoID, permission) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient repository permissions",
                                "code":  "FORBIDDEN",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov3" title="2">c.Next()</span>
        }
}

// OptionalAuth middleware that attempts authentication but doesn't require it
func (m *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                user, _ := m.authenticateRequest(c)
                if user != nil </span><span class="cov1" title="1">{
                        c.Set("user", user)
                }</span>
                <span class="cov4" title="3">c.Next()</span>
        }
}

// authenticateRequest attempts to authenticate a request using JWT or API key
func (m *AuthMiddleware) authenticateRequest(c *gin.Context) (*AuthenticatedUser, error) <span class="cov10" title="21">{
        // Try JWT authentication first
        if authHeader := c.GetHeader("Authorization"); authHeader != "" </span><span class="cov8" title="14">{
                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="12">{
                        token := strings.TrimPrefix(authHeader, "Bearer ")
                        return m.authenticateJWT(token)
                }</span>
        }

        // Try API key authentication
        <span class="cov7" title="9">if apiKey := c.GetHeader("X-API-Key"); apiKey != "" </span><span class="cov4" title="3">{
                return m.authenticateAPIKey(apiKey)
        }</span>

        // Try API key from query parameter (less secure, for webhooks etc.)
        <span class="cov6" title="6">if apiKey := c.Query("api_key"); apiKey != "" </span><span class="cov1" title="1">{
                return m.authenticateAPIKey(apiKey)
        }</span>

        <span class="cov5" title="5">return nil, ErrNoAuthProvided</span>
}

// authenticateJWT authenticates using JWT token
func (m *AuthMiddleware) authenticateJWT(token string) (*AuthenticatedUser, error) <span class="cov8" title="12">{
        claims, err := m.jwtAuth.ValidateToken(token)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        // Get user permissions from RBAC
        <span class="cov7" title="9">permissions, err := m.rbac.GetUserPermissions(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get user for repository permissions
        <span class="cov7" title="9">user, err := m.rbac.GetUser(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="9">return &amp;AuthenticatedUser{
                ID:          claims.UserID,
                Username:    claims.Username,
                Email:       claims.Email,
                Permissions: permissions,
                RepoPerms:   user.RepoPerms,
                AuthMethod:  "jwt",
                TokenInfo:   claims,
        }, nil</span>
}

// authenticateAPIKey authenticates using API key
func (m *AuthMiddleware) authenticateAPIKey(keyString string) (*AuthenticatedUser, error) <span class="cov5" title="4">{
        apiKey, err := m.apiKeyMgr.ValidateAPIKey(keyString)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        // Get user info
        <span class="cov3" title="2">user, err := m.rbac.GetUser(apiKey.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Combine user permissions with API key permissions
        <span class="cov3" title="2">userPermissions, _ := m.rbac.GetUserPermissions(apiKey.UserID)

        // API key permissions are a subset of user permissions
        effectivePermissions := m.intersectPermissions(userPermissions, apiKey.Permissions)

        return &amp;AuthenticatedUser{
                ID:          apiKey.UserID,
                Username:    user.Username,
                Email:       user.Email,
                Permissions: effectivePermissions,
                RepoPerms:   apiKey.RepoPerms,
                AuthMethod:  "apikey",
                TokenInfo:   apiKey,
        }, nil</span>
}

// hasPermission checks if a user has a specific permission
func (m *AuthMiddleware) hasPermission(user *AuthenticatedUser, permission Permission) bool <span class="cov6" title="6">{
        for _, perm := range user.Permissions </span><span class="cov9" title="18">{
                if perm == permission </span><span class="cov5" title="4">{
                        return true
                }</span>
                // Check for admin permissions
                <span class="cov8" title="14">if perm == PermissionSystemAdmin ||
                        (strings.HasPrefix(string(permission), "repo:") &amp;&amp; perm == PermissionRepoAdmin) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// hasRepositoryPermission checks if a user has permission for a specific repository
func (m *AuthMiddleware) hasRepositoryPermission(user *AuthenticatedUser, repoID string, permission Permission) bool <span class="cov3" title="2">{
        // Check global permissions first
        if m.hasPermission(user, permission) </span><span class="cov3" title="2">{
                return true
        }</span>

        // Check repository-specific permissions
        <span class="cov0" title="0">if user.RepoPerms != nil </span><span class="cov0" title="0">{
                if repoPerms, exists := user.RepoPerms[repoID]; exists </span><span class="cov0" title="0">{
                        for _, perm := range repoPerms </span><span class="cov0" title="0">{
                                if perm == permission || perm == PermissionRepoAdmin </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false</span>
}

// intersectPermissions returns permissions that exist in both slices
func (m *AuthMiddleware) intersectPermissions(userPerms, keyPerms []Permission) []Permission <span class="cov3" title="2">{
        permMap := make(map[Permission]bool)
        for _, perm := range userPerms </span><span class="cov7" title="8">{
                permMap[perm] = true
        }</span>

        <span class="cov3" title="2">var result []Permission
        for _, perm := range keyPerms </span><span class="cov3" title="2">{
                if permMap[perm] </span><span class="cov3" title="2">{
                        result = append(result, perm)
                }</span>
        }

        <span class="cov3" title="2">return result</span>
}

// GetCurrentUser returns the current authenticated user from gin context
func GetCurrentUser(c *gin.Context) (*AuthenticatedUser, bool) <span class="cov6" title="7">{
        user, exists := c.Get("user")
        if !exists </span><span class="cov3" title="2">{
                return nil, false
        }</span>

        <span class="cov5" title="5">authUser, ok := user.(*AuthenticatedUser)
        return authUser, ok</span>
}

// Custom errors
var (
        ErrNoAuthProvided = fmt.Errorf("no authentication provided")
        ErrInvalidToken   = fmt.Errorf("invalid token")
        ErrExpiredToken   = fmt.Errorf("token expired")
        ErrInvalidAPIKey  = fmt.Errorf("invalid API key")
)
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "fmt"
        "strings"
        "sync"
        "time"
)

// Permission represents a specific permission
type Permission string

const (
        // Repository permissions
        PermissionRepoRead   Permission = "repo:read"
        PermissionRepoWrite  Permission = "repo:write"
        PermissionRepoDelete Permission = "repo:delete"
        PermissionRepoAdmin  Permission = "repo:admin"

        // System permissions
        PermissionSystemRead  Permission = "system:read"
        PermissionSystemWrite Permission = "system:write"
        PermissionSystemAdmin Permission = "system:admin"

        // User management permissions
        PermissionUserRead   Permission = "user:read"
        PermissionUserWrite  Permission = "user:write"
        PermissionUserDelete Permission = "user:delete"

        // Webhook permissions
        PermissionWebhookRead   Permission = "webhook:read"
        PermissionWebhookWrite  Permission = "webhook:write"
        PermissionWebhookDelete Permission = "webhook:delete"
)

// Role represents a collection of permissions
type Role struct {
        Name        string       `json:"name"`
        Description string       `json:"description"`
        Permissions []Permission `json:"permissions"`
}

// User represents a user in the system
type User struct {
        ID          string                  `json:"id"`
        Username    string                  `json:"username"`
        Email       string                  `json:"email"`
        Roles       []string                `json:"roles"`
        Permissions []Permission            `json:"permissions"`      // Direct permissions
        RepoPerms   map[string][]Permission `json:"repo_permissions"` // Repository-specific permissions
        Active      bool                    `json:"active"`
        CreatedAt   string                  `json:"created_at"`
        UpdatedAt   string                  `json:"updated_at"`
}

// RBAC manages role-based access control
type RBAC struct {
        roles map[string]*Role
        users map[string]*User
        mu    sync.RWMutex
}

// NewRBAC creates a new RBAC manager with default roles
func NewRBAC() *RBAC <span class="cov6" title="26">{
        rbac := &amp;RBAC{
                roles: make(map[string]*Role),
                users: make(map[string]*User),
        }

        // Define default roles
        rbac.defineDefaultRoles()

        return rbac
}</span>

// defineDefaultRoles sets up the default role hierarchy
func (r *RBAC) defineDefaultRoles() <span class="cov6" title="26">{
        // Admin role - full system access
        r.roles["admin"] = &amp;Role{
                Name:        "admin",
                Description: "Full system administrator",
                Permissions: []Permission{
                        PermissionSystemAdmin,
                        PermissionRepoAdmin,
                        PermissionUserRead,
                        PermissionUserWrite,
                        PermissionUserDelete,
                        PermissionWebhookRead,
                        PermissionWebhookWrite,
                        PermissionWebhookDelete,
                },
        }

        // Developer role - can read/write repositories
        r.roles["developer"] = &amp;Role{
                Name:        "developer",
                Description: "Can read and write repositories",
                Permissions: []Permission{
                        PermissionRepoRead,
                        PermissionRepoWrite,
                        PermissionWebhookRead,
                        PermissionWebhookWrite,
                },
        }

        // Reader role - read-only access
        r.roles["reader"] = &amp;Role{
                Name:        "reader",
                Description: "Read-only access to repositories",
                Permissions: []Permission{
                        PermissionRepoRead,
                },
        }

        // Guest role - minimal access
        r.roles["guest"] = &amp;Role{
                Name:        "guest",
                Description: "Minimal system access",
                Permissions: []Permission{
                        PermissionSystemRead,
                },
        }
}</span>

// CreateRole creates a new role
func (r *RBAC) CreateRole(name, description string, permissions []Permission) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.roles[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("role '%s' already exists", name)
        }</span>

        <span class="cov0" title="0">r.roles[name] = &amp;Role{
                Name:        name,
                Description: description,
                Permissions: permissions,
        }

        return nil</span>
}

// GetRole retrieves a role by name
func (r *RBAC) GetRole(name string) (*Role, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        role, exists := r.roles[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("role '%s' not found", name)
        }</span>

        // Return a copy to prevent external modification
        <span class="cov0" title="0">roleCopy := *role
        roleCopy.Permissions = make([]Permission, len(role.Permissions))
        copy(roleCopy.Permissions, role.Permissions)

        return &amp;roleCopy, nil</span>
}

// ListRoles returns all available roles
func (r *RBAC) ListRoles() []*Role <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        roles := make([]*Role, 0, len(r.roles))
        for _, role := range r.roles </span><span class="cov3" title="4">{
                roleCopy := *role
                roleCopy.Permissions = make([]Permission, len(role.Permissions))
                copy(roleCopy.Permissions, role.Permissions)
                roles = append(roles, &amp;roleCopy)
        }</span>

        <span class="cov1" title="1">return roles</span>
}

// CreateUser creates a new user
func (r *RBAC) CreateUser(id, username, email string, roles []string) error <span class="cov9" title="146">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.users[id]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("user '%s' already exists", id)
        }</span>

        // Validate roles exist
        <span class="cov9" title="145">for _, roleName := range roles </span><span class="cov9" title="146">{
                if _, exists := r.roles[roleName]; !exists </span><span class="cov1" title="1">{
                        return fmt.Errorf("role '%s' does not exist", roleName)
                }</span>
        }

        <span class="cov9" title="144">r.users[id] = &amp;User{
                ID:        id,
                Username:  username,
                Email:     email,
                Roles:     roles,
                RepoPerms: make(map[string][]Permission),
                Active:    true,
                CreatedAt: fmt.Sprintf("%d", time.Now().Unix()),
                UpdatedAt: fmt.Sprintf("%d", time.Now().Unix()),
        }

        return nil</span>
}

// GetUser retrieves a user by ID
func (r *RBAC) GetUser(userID string) (*User, error) <span class="cov10" title="244">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("user '%s' not found", userID)
        }</span>

        // Return a copy
        <span class="cov9" title="241">userCopy := *user
        userCopy.Roles = make([]string, len(user.Roles))
        copy(userCopy.Roles, user.Roles)
        userCopy.Permissions = make([]Permission, len(user.Permissions))
        copy(userCopy.Permissions, user.Permissions)
        userCopy.RepoPerms = make(map[string][]Permission)
        for k, v := range user.RepoPerms </span><span class="cov3" title="4">{
                userCopy.RepoPerms[k] = make([]Permission, len(v))
                copy(userCopy.RepoPerms[k], v)
        }</span>

        <span class="cov9" title="241">return &amp;userCopy, nil</span>
}

// GetUserPermissions returns all permissions for a user (from roles + direct permissions)
func (r *RBAC) GetUserPermissions(userID string) ([]Permission, error) <span class="cov5" title="14">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov5" title="13">if !user.Active </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user '%s' is inactive", userID)
        }</span>

        <span class="cov5" title="13">permissionSet := make(map[Permission]bool)

        // Add permissions from roles
        for _, roleName := range user.Roles </span><span class="cov5" title="13">{
                if role, exists := r.roles[roleName]; exists </span><span class="cov5" title="13">{
                        for _, perm := range role.Permissions </span><span class="cov7" title="64">{
                                permissionSet[perm] = true
                        }</span>
                }
        }

        // Add direct permissions
        <span class="cov5" title="13">for _, perm := range user.Permissions </span><span class="cov0" title="0">{
                permissionSet[perm] = true
        }</span>

        // Convert to slice
        <span class="cov5" title="13">permissions := make([]Permission, 0, len(permissionSet))
        for perm := range permissionSet </span><span class="cov7" title="64">{
                permissions = append(permissions, perm)
        }</span>

        <span class="cov5" title="13">return permissions, nil</span>
}

// HasPermission checks if a user has a specific permission
func (r *RBAC) HasPermission(userID string, permission Permission) bool <span class="cov0" title="0">{
        permissions, err := r.GetUserPermissions(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, perm := range permissions </span><span class="cov0" title="0">{
                if perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Check for admin permissions that grant everything
                <span class="cov0" title="0">if perm == PermissionSystemAdmin ||
                        (strings.HasPrefix(string(permission), "repo:") &amp;&amp; perm == PermissionRepoAdmin) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// HasRepositoryPermission checks if a user has permission for a specific repository
func (r *RBAC) HasRepositoryPermission(userID, repoID string, permission Permission) bool <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        user, exists := r.users[userID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check global permissions first
        <span class="cov0" title="0">if r.HasPermission(userID, permission) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check repository-specific permissions
        <span class="cov0" title="0">if repoPerms, exists := user.RepoPerms[repoID]; exists </span><span class="cov0" title="0">{
                for _, perm := range repoPerms </span><span class="cov0" title="0">{
                        if perm == permission || perm == PermissionRepoAdmin </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// GrantRepositoryPermission grants a user permission to a specific repository
func (r *RBAC) GrantRepositoryPermission(userID, repoID string, permission Permission) error <span class="cov3" title="5">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov3" title="4">if user.RepoPerms == nil </span><span class="cov0" title="0">{
                user.RepoPerms = make(map[string][]Permission)
        }</span>

        // Check if permission already exists
        <span class="cov3" title="4">for _, perm := range user.RepoPerms[repoID] </span><span class="cov1" title="1">{
                if perm == permission </span><span class="cov1" title="1">{
                        return nil // Already has permission
                }</span>
        }

        <span class="cov2" title="3">user.RepoPerms[repoID] = append(user.RepoPerms[repoID], permission)
        return nil</span>
}

// RevokeRepositoryPermission removes a user's permission from a specific repository
func (r *RBAC) RevokeRepositoryPermission(userID, repoID string, permission Permission) error <span class="cov2" title="3">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov2" title="2">if user.RepoPerms == nil </span><span class="cov0" title="0">{
                return nil // No permissions to revoke
        }</span>

        <span class="cov2" title="2">perms := user.RepoPerms[repoID]
        for i, perm := range perms </span><span class="cov1" title="1">{
                if perm == permission </span><span class="cov1" title="1">{
                        // Remove the permission
                        user.RepoPerms[repoID] = append(perms[:i], perms[i+1:]...)
                        break</span>
                }
        }

        // Clean up empty permission slice
        <span class="cov2" title="2">if len(user.RepoPerms[repoID]) == 0 </span><span class="cov2" title="2">{
                delete(user.RepoPerms, repoID)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// AssignRole assigns a role to a user
func (r *RBAC) AssignRole(userID, roleName string) error <span class="cov3" title="5">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov3" title="4">if _, exists := r.roles[roleName]; !exists </span><span class="cov1" title="1">{
                return fmt.Errorf("role '%s' not found", roleName)
        }</span>

        // Check if role already assigned
        <span class="cov2" title="3">for _, role := range user.Roles </span><span class="cov2" title="3">{
                if role == roleName </span><span class="cov1" title="1">{
                        return nil // Already has role
                }</span>
        }

        <span class="cov2" title="2">user.Roles = append(user.Roles, roleName)
        return nil</span>
}

// RemoveRole removes a role from a user
func (r *RBAC) RemoveRole(userID, roleName string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov0" title="0">for i, role := range user.Roles </span><span class="cov0" title="0">{
                if role == roleName </span><span class="cov0" title="0">{
                        user.Roles = append(user.Roles[:i], user.Roles[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// DeactivateUser deactivates a user account
func (r *RBAC) DeactivateUser(userID string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov0" title="0">user.Active = false
        return nil</span>
}

// ActivateUser activates a user account
func (r *RBAC) ActivateUser(userID string) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        user, exists := r.users[userID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("user '%s' not found", userID)
        }</span>

        <span class="cov0" title="0">user.Active = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

// Config represents the complete application configuration
type Config struct {
        Server      ServerConfig      `yaml:"server"`
        Auth        AuthConfig        `yaml:"auth"`
        Pool        PoolConfig        `yaml:"pool"`
        Logging     LoggingConfig     `yaml:"logging"`
        Metrics     MetricsConfig     `yaml:"metrics"`
        Storage     StorageConfig     `yaml:"storage"`
        Development DevelopmentConfig `yaml:"development"`
        Cluster     ClusterConfig     `yaml:"cluster"`
}

// ServerConfig contains HTTP server configuration
type ServerConfig struct {
        Host           string        `yaml:"host"`
        Port           int           `yaml:"port"`
        ReadTimeout    time.Duration `yaml:"read_timeout"`
        WriteTimeout   time.Duration `yaml:"write_timeout"`
        IdleTimeout    time.Duration `yaml:"idle_timeout"`
        RequestTimeout time.Duration `yaml:"request_timeout"`
        MaxRepos       int           `yaml:"max_repos"`
        MaxRequestSize int64         `yaml:"max_request_size"`
        TrustedProxy   []string      `yaml:"trusted_proxy"`
}

// AuthConfig contains authentication configuration
type AuthConfig struct {
        Enabled bool      `yaml:"enabled"`
        JWT     JWTConfig `yaml:"jwt"`
}

// JWTConfig contains JWT-specific configuration
type JWTConfig struct {
        Secret string        `yaml:"secret"`
        Issuer string        `yaml:"issuer"`
        TTL    time.Duration `yaml:"ttl"`
}

// PoolConfig contains repository pool configuration
type PoolConfig struct {
        MaxRepositories int           `yaml:"max_repositories"`
        MaxIdleTime     time.Duration `yaml:"max_idle_time"`
        CleanupInterval time.Duration `yaml:"cleanup_interval"`
        EnableMetrics   bool          `yaml:"enable_metrics"`
}

// LoggingConfig contains logging configuration
type LoggingConfig struct {
        Level     string `yaml:"level"`
        Format    string `yaml:"format"`
        Component string `yaml:"component"`
        Output    string `yaml:"output"`
}

// MetricsConfig contains metrics configuration
type MetricsConfig struct {
        Enabled bool   `yaml:"enabled"`
        Path    string `yaml:"path"`
}

// StorageConfig contains storage configuration
type StorageConfig struct {
        Type         string        `yaml:"type"`          // memory, disk, hybrid
        DiskPath     string        `yaml:"disk_path"`     // Path for disk storage
        MaxMemoryMB  int           `yaml:"max_memory_mb"` // Max memory usage in MB
        CacheEnabled bool          `yaml:"cache_enabled"`
        CacheTTL     time.Duration `yaml:"cache_ttl"`
}

// DevelopmentConfig contains development-specific settings
type DevelopmentConfig struct {
        Debug              bool     `yaml:"debug"`
        ProfilerEnabled    bool     `yaml:"profiler_enabled"`
        CORSEnabled        bool     `yaml:"cors_enabled"`
        AllowedOrigins     []string `yaml:"allowed_origins"`
        UseNewArchitecture bool     `yaml:"use_new_architecture"`
}

// ClusterConfig contains high availability cluster configuration
type ClusterConfig struct {
        Enabled               bool          `yaml:"enabled"`
        ID                    string        `yaml:"id"`
        Name                  string        `yaml:"name"`
        ReplicationFactor     int           `yaml:"replication_factor"`
        ShardSize             int           `yaml:"shard_size"`
        ElectionTimeout       time.Duration `yaml:"election_timeout"`
        HeartbeatInterval     time.Duration `yaml:"heartbeat_interval"`
        MaxLogEntries         int           `yaml:"max_log_entries"`
        SnapshotThreshold     int           `yaml:"snapshot_threshold"`
        AutoRebalance         bool          `yaml:"auto_rebalance"`
        ConsistencyLevel      string        `yaml:"consistency_level"`
        AutoFailoverEnabled   bool          `yaml:"auto_failover_enabled"`
        FailoverTimeout       time.Duration `yaml:"failover_timeout"`
        MinHealthyNodes       int           `yaml:"min_healthy_nodes"`
        RequireQuorum         bool          `yaml:"require_quorum"`
        PreventSplitBrain     bool          `yaml:"prevent_split_brain"`
        MaxFailoversPerMinute int           `yaml:"max_failovers_per_minute"`
        CooldownPeriod        time.Duration `yaml:"cooldown_period"`
        DataDir               string        `yaml:"data_dir"`
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov10" title="17">{
        return &amp;Config{
                Server: ServerConfig{
                        Host:           "0.0.0.0",
                        Port:           8080,
                        ReadTimeout:    30 * time.Second,
                        WriteTimeout:   30 * time.Second,
                        IdleTimeout:    60 * time.Second,
                        RequestTimeout: 25 * time.Second, // Slightly less than WriteTimeout
                        MaxRepos:       1000,
                        MaxRequestSize: 10 * 1024 * 1024, // 10MB
                        TrustedProxy:   []string{},
                },
                Auth: AuthConfig{
                        Enabled: true,
                        JWT: JWTConfig{
                                Secret: "default-secret-change-in-production",
                                Issuer: "govc-server",
                                TTL:    24 * time.Hour,
                        },
                },
                Pool: PoolConfig{
                        MaxRepositories: 100,
                        MaxIdleTime:     30 * time.Minute,
                        CleanupInterval: 5 * time.Minute,
                        EnableMetrics:   true,
                },
                Logging: LoggingConfig{
                        Level:     "INFO",
                        Format:    "json",
                        Component: "govc",
                        Output:    "stdout",
                },
                Metrics: MetricsConfig{
                        Enabled: true,
                        Path:    "/metrics",
                },
                Storage: StorageConfig{
                        Type:         "memory",
                        DiskPath:     "/var/lib/govc",
                        MaxMemoryMB:  1024,
                        CacheEnabled: true,
                        CacheTTL:     1 * time.Hour,
                },
                Development: DevelopmentConfig{
                        Debug:              false,
                        ProfilerEnabled:    false,
                        CORSEnabled:        false,
                        AllowedOrigins:     []string{"http://localhost:3000"},
                        UseNewArchitecture: true, // Default to new architecture
                },
                Cluster: ClusterConfig{
                        Enabled:               false, // Disabled by default
                        ID:                    "govc-cluster-1",
                        Name:                  "GoVC Production Cluster",
                        ReplicationFactor:     3,
                        ShardSize:             1000,
                        ElectionTimeout:       150 * time.Millisecond,
                        HeartbeatInterval:     50 * time.Millisecond,
                        MaxLogEntries:         10000,
                        SnapshotThreshold:     1000,
                        AutoRebalance:         true,
                        ConsistencyLevel:      "eventual",
                        AutoFailoverEnabled:   true,
                        FailoverTimeout:       30 * time.Second,
                        MinHealthyNodes:       1,
                        RequireQuorum:         false,
                        PreventSplitBrain:     true,
                        MaxFailoversPerMinute: 5,
                        CooldownPeriod:        5 * time.Minute,
                        DataDir:               "/var/lib/govc/cluster",
                },
        }
}</span>

// LoadConfig loads configuration from file and environment variables
func LoadConfig(configFile string) (*Config, error) <span class="cov6" title="5">{
        config := DefaultConfig()

        // Load from YAML file if provided and exists
        if configFile != "" </span><span class="cov5" title="4">{
                if err := loadFromFile(config, configFile); err != nil </span><span class="cov3" title="2">{
                        // Don't fail if file doesn't exist, just use defaults
                        if !os.IsNotExist(err) </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to load config file %s: %w", configFile, err)
                        }</span>
                }
        }

        // Override with environment variables
        <span class="cov5" title="4">if err := loadFromEnv(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load environment variables: %w", err)
        }</span>

        // Validate configuration
        <span class="cov5" title="4">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov5" title="4">return config, nil</span>
}

// loadFromFile loads configuration from YAML file
func loadFromFile(config *Config, filename string) error <span class="cov5" title="4">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Expand environment variables in YAML content
        <span class="cov4" title="3">expanded := os.ExpandEnv(string(data))

        return yaml.Unmarshal([]byte(expanded), config)</span>
}

// loadFromEnv loads configuration from environment variables
func loadFromEnv(config *Config) error <span class="cov5" title="4">{
        // Server configuration
        if host := os.Getenv("GOVC_HOST"); host != "" </span><span class="cov1" title="1">{
                config.Server.Host = host
        }</span>
        <span class="cov5" title="4">if port := os.Getenv("GOVC_PORT"); port != "" </span><span class="cov1" title="1">{
                if p, err := strconv.Atoi(port); err == nil </span><span class="cov1" title="1">{
                        config.Server.Port = p
                }</span>
        }
        <span class="cov5" title="4">if timeout := os.Getenv("GOVC_READ_TIMEOUT"); timeout != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(timeout); err == nil </span><span class="cov0" title="0">{
                        config.Server.ReadTimeout = d
                }</span>
        }
        <span class="cov5" title="4">if timeout := os.Getenv("GOVC_WRITE_TIMEOUT"); timeout != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(timeout); err == nil </span><span class="cov0" title="0">{
                        config.Server.WriteTimeout = d
                }</span>
        }
        <span class="cov5" title="4">if maxRepos := os.Getenv("GOVC_MAX_REPOS"); maxRepos != "" </span><span class="cov0" title="0">{
                if m, err := strconv.Atoi(maxRepos); err == nil </span><span class="cov0" title="0">{
                        config.Server.MaxRepos = m
                }</span>
        }

        // Auth configuration
        <span class="cov5" title="4">if enabled := os.Getenv("GOVC_AUTH_ENABLED"); enabled != "" </span><span class="cov0" title="0">{
                config.Auth.Enabled = strings.ToLower(enabled) == "true"
        }</span>
        <span class="cov5" title="4">if secret := os.Getenv("GOVC_JWT_SECRET"); secret != "" </span><span class="cov3" title="2">{
                config.Auth.JWT.Secret = secret
        }</span>
        <span class="cov5" title="4">if issuer := os.Getenv("GOVC_JWT_ISSUER"); issuer != "" </span><span class="cov0" title="0">{
                config.Auth.JWT.Issuer = issuer
        }</span>
        <span class="cov5" title="4">if ttl := os.Getenv("GOVC_JWT_TTL"); ttl != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(ttl); err == nil </span><span class="cov0" title="0">{
                        config.Auth.JWT.TTL = d
                }</span>
        }

        // Pool configuration
        <span class="cov5" title="4">if maxRepos := os.Getenv("GOVC_POOL_MAX_REPOS"); maxRepos != "" </span><span class="cov1" title="1">{
                if m, err := strconv.Atoi(maxRepos); err == nil </span><span class="cov1" title="1">{
                        config.Pool.MaxRepositories = m
                }</span>
        }
        <span class="cov5" title="4">if idleTime := os.Getenv("GOVC_POOL_IDLE_TIME"); idleTime != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(idleTime); err == nil </span><span class="cov0" title="0">{
                        config.Pool.MaxIdleTime = d
                }</span>
        }
        <span class="cov5" title="4">if cleanupInterval := os.Getenv("GOVC_POOL_CLEANUP_INTERVAL"); cleanupInterval != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(cleanupInterval); err == nil </span><span class="cov0" title="0">{
                        config.Pool.CleanupInterval = d
                }</span>
        }

        // Logging configuration
        <span class="cov5" title="4">if level := os.Getenv("GOVC_LOG_LEVEL"); level != "" </span><span class="cov1" title="1">{
                config.Logging.Level = strings.ToUpper(level)
        }</span>
        <span class="cov5" title="4">if format := os.Getenv("GOVC_LOG_FORMAT"); format != "" </span><span class="cov0" title="0">{
                config.Logging.Format = strings.ToLower(format)
        }</span>
        <span class="cov5" title="4">if component := os.Getenv("GOVC_LOG_COMPONENT"); component != "" </span><span class="cov0" title="0">{
                config.Logging.Component = component
        }</span>

        // Metrics configuration
        <span class="cov5" title="4">if enabled := os.Getenv("GOVC_METRICS_ENABLED"); enabled != "" </span><span class="cov1" title="1">{
                config.Metrics.Enabled = strings.ToLower(enabled) == "true"
        }</span>
        <span class="cov5" title="4">if path := os.Getenv("GOVC_METRICS_PATH"); path != "" </span><span class="cov0" title="0">{
                config.Metrics.Path = path
        }</span>

        // Storage configuration
        <span class="cov5" title="4">if storageType := os.Getenv("GOVC_STORAGE_TYPE"); storageType != "" </span><span class="cov1" title="1">{
                config.Storage.Type = strings.ToLower(storageType)
        }</span>
        <span class="cov5" title="4">if diskPath := os.Getenv("GOVC_STORAGE_DISK_PATH"); diskPath != "" </span><span class="cov1" title="1">{
                config.Storage.DiskPath = diskPath
        }</span>
        <span class="cov5" title="4">if maxMemory := os.Getenv("GOVC_STORAGE_MAX_MEMORY_MB"); maxMemory != "" </span><span class="cov0" title="0">{
                if m, err := strconv.Atoi(maxMemory); err == nil </span><span class="cov0" title="0">{
                        config.Storage.MaxMemoryMB = m
                }</span>
        }

        // Development configuration
        <span class="cov5" title="4">if debug := os.Getenv("GOVC_DEBUG"); debug != "" </span><span class="cov1" title="1">{
                config.Development.Debug = strings.ToLower(debug) == "true"
        }</span>
        <span class="cov5" title="4">if profiler := os.Getenv("GOVC_PROFILER_ENABLED"); profiler != "" </span><span class="cov0" title="0">{
                config.Development.ProfilerEnabled = strings.ToLower(profiler) == "true"
        }</span>
        <span class="cov5" title="4">if cors := os.Getenv("GOVC_CORS_ENABLED"); cors != "" </span><span class="cov0" title="0">{
                config.Development.CORSEnabled = strings.ToLower(cors) == "true"
        }</span>

        <span class="cov5" title="4">return nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov9" title="15">{
        // Server validation
        if c.Server.Port &lt; 1 || c.Server.Port &gt; 65535 </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid server port: %d", c.Server.Port)
        }</span>
        <span class="cov9" title="13">if c.Server.ReadTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("read timeout must be positive")
        }</span>
        <span class="cov9" title="13">if c.Server.WriteTimeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("write timeout must be positive")
        }</span>
        <span class="cov9" title="13">if c.Server.MaxRepos &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max repositories must be positive")
        }</span>

        // Auth validation
        <span class="cov9" title="13">if c.Auth.Enabled </span><span class="cov8" title="11">{
                if c.Auth.JWT.Secret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT secret is required when auth is enabled")
                }</span>
                <span class="cov8" title="11">if c.Auth.JWT.Secret == "default-secret-change-in-production" </span><span class="cov1" title="1">{
                        return fmt.Errorf("JWT secret must be changed from default value in production")
                }</span>
                <span class="cov8" title="10">if len(c.Auth.JWT.Secret) &lt; 32 </span><span class="cov1" title="1">{
                        return fmt.Errorf("JWT secret must be at least 32 characters long")
                }</span>
                <span class="cov7" title="9">if c.Auth.JWT.Issuer == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT issuer is required")
                }</span>
                <span class="cov7" title="9">if c.Auth.JWT.TTL &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT TTL must be positive")
                }</span>
        }

        // Pool validation
        <span class="cov8" title="11">if c.Pool.MaxRepositories &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pool max repositories must be positive")
        }</span>
        <span class="cov8" title="11">if c.Pool.MaxIdleTime &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pool max idle time must be positive")
        }</span>
        <span class="cov8" title="11">if c.Pool.CleanupInterval &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("pool cleanup interval must be positive")
        }</span>

        // Logging validation
        <span class="cov8" title="11">validLevels := map[string]bool{
                "DEBUG": true, "INFO": true, "WARN": true, "ERROR": true, "FATAL": true,
        }
        if !validLevels[c.Logging.Level] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log level: %s", c.Logging.Level)
        }</span>
        <span class="cov8" title="10">validFormats := map[string]bool{
                "json": true, "text": true,
        }
        if !validFormats[c.Logging.Format] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log format: %s", c.Logging.Format)
        }</span>

        // Storage validation
        <span class="cov7" title="9">validStorageTypes := map[string]bool{
                "memory": true, "disk": true, "hybrid": true,
        }
        if !validStorageTypes[c.Storage.Type] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid storage type: %s", c.Storage.Type)
        }</span>
        <span class="cov7" title="8">if (c.Storage.Type == "disk" || c.Storage.Type == "hybrid") &amp;&amp; c.Storage.DiskPath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("disk path is required for disk/hybrid storage")
        }</span>
        <span class="cov7" title="7">if c.Storage.MaxMemoryMB &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max memory must be positive")
        }</span>

        <span class="cov7" title="7">return nil</span>
}

// Address returns the server address
func (c *Config) Address() string <span class="cov3" title="2">{
        return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)
}</span>

// IsDevelopment returns true if running in development mode
func (c *Config) IsDevelopment() bool <span class="cov4" title="3">{
        return c.Development.Debug
}</span>

// GetLogLevel returns the logging level as a structured enum
func (c *Config) GetLogLevel() LogLevel <span class="cov7" title="7">{
        switch c.Logging.Level </span>{
        case "DEBUG":<span class="cov1" title="1">
                return DebugLevel</span>
        case "INFO":<span class="cov1" title="1">
                return InfoLevel</span>
        case "WARN":<span class="cov3" title="2">
                return WarnLevel</span>
        case "ERROR":<span class="cov1" title="1">
                return ErrorLevel</span>
        case "FATAL":<span class="cov1" title="1">
                return FatalLevel</span>
        default:<span class="cov1" title="1">
                return InfoLevel</span>
        }
}

// LogLevel represents the severity level of a log entry
type LogLevel int

const (
        DebugLevel LogLevel = iota
        InfoLevel
        WarnLevel
        ErrorLevel
        FatalLevel
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov6" title="6">{
        switch l </span>{
        case DebugLevel:<span class="cov1" title="1">
                return "DEBUG"</span>
        case InfoLevel:<span class="cov1" title="1">
                return "INFO"</span>
        case WarnLevel:<span class="cov1" title="1">
                return "WARN"</span>
        case ErrorLevel:<span class="cov1" title="1">
                return "ERROR"</span>
        case FatalLevel:<span class="cov1" title="1">
                return "FATAL"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package logging

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// Pool for reusing log entries to reduce allocations
var logEntryPool = sync.Pool{
        New: func() interface{} <span class="cov1" title="1">{
                return &amp;LogEntry{
                        Fields: make(map[string]interface{}),
                }
        }</span>,
}

// Pool for reusing field maps
var fieldsPool = sync.Pool{
        New: func() interface{} <span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>,
}

// getLogEntry gets a log entry from the pool
func getLogEntry() *LogEntry <span class="cov8" title="29">{
        entry := logEntryPool.Get().(*LogEntry)
        // Reset the entry
        entry.Timestamp = time.Time{}
        entry.Level = 0
        entry.Message = ""
        entry.Caller = ""
        entry.RequestID = ""
        entry.UserID = ""
        entry.Component = ""
        entry.Operation = ""
        entry.Duration = nil
        entry.Error = ""
        entry.HTTPMethod = ""
        entry.HTTPPath = ""
        entry.HTTPStatus = 0
        entry.HTTPLatency = nil
        // Clear the fields map
        for k := range entry.Fields </span><span class="cov8" title="28">{
                delete(entry.Fields, k)
        }</span>
        <span class="cov8" title="29">return entry</span>
}

// putLogEntry returns a log entry to the pool
func putLogEntry(entry *LogEntry) <span class="cov8" title="29">{
        if entry != nil </span><span class="cov8" title="29">{
                logEntryPool.Put(entry)
        }</span>
}

// getFields gets a fields map from the pool
func getFields() map[string]interface{} <span class="cov0" title="0">{
        fields := fieldsPool.Get().(map[string]interface{})
        // Clear the map
        for k := range fields </span><span class="cov0" title="0">{
                delete(fields, k)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// putFields returns a fields map to the pool
func putFields(fields map[string]interface{}) <span class="cov0" title="0">{
        if fields != nil </span><span class="cov0" title="0">{
                fieldsPool.Put(fields)
        }</span>
}

// LogLevel represents the severity level of a log entry
type LogLevel int

const (
        DebugLevel LogLevel = iota
        InfoLevel
        WarnLevel
        ErrorLevel
        FatalLevel
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov9" title="39">{
        switch l </span>{
        case DebugLevel:<span class="cov5" title="7">
                return "DEBUG"</span>
        case InfoLevel:<span class="cov6" title="11">
                return "INFO"</span>
        case WarnLevel:<span class="cov5" title="8">
                return "WARN"</span>
        case ErrorLevel:<span class="cov6" title="11">
                return "ERROR"</span>
        case FatalLevel:<span class="cov1" title="1">
                return "FATAL"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// LogEntry represents a structured log entry
type LogEntry struct {
        Timestamp   time.Time              `json:"timestamp"`
        Level       LogLevel               `json:"level"`
        Message     string                 `json:"message"`
        Fields      map[string]interface{} `json:"fields,omitempty"`
        Caller      string                 `json:"caller,omitempty"`
        RequestID   string                 `json:"request_id,omitempty"`
        UserID      string                 `json:"user_id,omitempty"`
        Component   string                 `json:"component,omitempty"`
        Operation   string                 `json:"operation,omitempty"`
        Duration    *int64                 `json:"duration_ms,omitempty"`
        Error       string                 `json:"error,omitempty"`
        HTTPMethod  string                 `json:"http_method,omitempty"`
        HTTPPath    string                 `json:"http_path,omitempty"`
        HTTPStatus  int                    `json:"http_status,omitempty"`
        HTTPLatency *int64                 `json:"http_latency_ms,omitempty"`
}

// Logger represents a structured logger
type Logger struct {
        level     LogLevel
        output    io.Writer
        component string
        fields    map[string]interface{}
        mu        sync.RWMutex
}

// Config represents logger configuration
type Config struct {
        Level        LogLevel
        Output       io.Writer
        Component    string
        EnableCaller bool
        TimeFormat   string
}

// NewLogger creates a new structured logger
func NewLogger(config Config) *Logger <span class="cov7" title="16">{
        if config.Output == nil </span><span class="cov2" title="2">{
                config.Output = os.Stdout
        }</span>

        <span class="cov7" title="16">if config.TimeFormat == "" </span><span class="cov7" title="16">{
                config.TimeFormat = time.RFC3339
        }</span>

        <span class="cov7" title="16">return &amp;Logger{
                level:     config.Level,
                output:    config.Output,
                component: config.Component,
                fields:    make(map[string]interface{}),
        }</span>
}

// WithField adds a field to the logger context
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov5" title="6">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        newLogger := &amp;Logger{
                level:     l.level,
                output:    l.output,
                component: l.component,
                fields:    make(map[string]interface{}),
        }

        // Copy existing fields
        for k, v := range l.fields </span><span class="cov3" title="3">{
                newLogger.fields[k] = v
        }</span>

        // Add new field
        <span class="cov5" title="6">newLogger.fields[key] = value

        return newLogger</span>
}

// WithFields adds multiple fields to the logger context
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov5" title="8">{
        l.mu.RLock()
        defer l.mu.RUnlock()

        newLogger := &amp;Logger{
                level:     l.level,
                output:    l.output,
                component: l.component,
                fields:    make(map[string]interface{}),
        }

        // Copy existing fields
        for k, v := range l.fields </span><span class="cov1" title="1">{
                newLogger.fields[k] = v
        }</span>

        // Add new fields
        <span class="cov5" title="8">for k, v := range fields </span><span class="cov8" title="30">{
                newLogger.fields[k] = v
        }</span>

        <span class="cov5" title="8">return newLogger</span>
}

// WithComponent sets the component for this logger
func (l *Logger) WithComponent(component string) *Logger <span class="cov1" title="1">{
        return &amp;Logger{
                level:     l.level,
                output:    l.output,
                component: component,
                fields:    l.fields,
        }
}</span>

// Debug logs a debug message
func (l *Logger) Debug(message string) <span class="cov4" title="4">{
        l.log(DebugLevel, message, nil)
}</span>

// Debugf logs a formatted debug message
func (l *Logger) Debugf(format string, args ...interface{}) <span class="cov2" title="2">{
        l.log(DebugLevel, fmt.Sprintf(format, args...), nil)
}</span>

// Info logs an info message
func (l *Logger) Info(message string) <span class="cov5" title="7">{
        l.log(InfoLevel, message, nil)
}</span>

// Infof logs a formatted info message
func (l *Logger) Infof(format string, args ...interface{}) <span class="cov2" title="2">{
        l.log(InfoLevel, fmt.Sprintf(format, args...), nil)
}</span>

// Warn logs a warning message
func (l *Logger) Warn(message string) <span class="cov3" title="3">{
        l.log(WarnLevel, message, nil)
}</span>

// Warnf logs a formatted warning message
func (l *Logger) Warnf(format string, args ...interface{}) <span class="cov2" title="2">{
        l.log(WarnLevel, fmt.Sprintf(format, args...), nil)
}</span>

// Error logs an error message
func (l *Logger) Error(message string) <span class="cov4" title="4">{
        l.log(ErrorLevel, message, nil)
}</span>

// Errorf logs a formatted error message
func (l *Logger) Errorf(format string, args ...interface{}) <span class="cov2" title="2">{
        l.log(ErrorLevel, fmt.Sprintf(format, args...), nil)
}</span>

// ErrorWithErr logs an error message with an error object
func (l *Logger) ErrorWithErr(message string, err error) <span class="cov2" title="2">{
        fields := map[string]interface{}{"error": err.Error()}
        l.log(ErrorLevel, message, fields)
}</span>

// Fatal logs a fatal message and exits
func (l *Logger) Fatal(message string) <span class="cov0" title="0">{
        l.log(FatalLevel, message, nil)
        os.Exit(1)
}</span>

// Fatalf logs a formatted fatal message and exits
func (l *Logger) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.log(FatalLevel, fmt.Sprintf(format, args...), nil)
        os.Exit(1)
}</span>

// LogOperation logs the start and end of an operation with duration
func (l *Logger) LogOperation(operation string, fn func() error) error <span class="cov2" title="2">{
        start := time.Now()

        l.WithField("operation", operation).Info("Operation started")

        err := fn()
        duration := time.Since(start).Milliseconds()

        logger := l.WithFields(map[string]interface{}{
                "operation":   operation,
                "duration_ms": duration,
        })

        if err != nil </span><span class="cov1" title="1">{
                logger.WithField("error", err.Error()).Error("Operation failed")
                return err
        }</span>

        <span class="cov1" title="1">logger.Info("Operation completed")
        return nil</span>
}

// log writes a log entry using object pooling for performance
func (l *Logger) log(level LogLevel, message string, additionalFields map[string]interface{}) <span class="cov8" title="31">{
        if level &lt; l.level </span><span class="cov2" title="2">{
                return
        }</span>

        <span class="cov8" title="29">l.mu.RLock()
        defer l.mu.RUnlock()

        // Get pooled entry and configure it
        entry := getLogEntry()
        defer putLogEntry(entry)
        
        entry.Timestamp = time.Now()
        entry.Level = level
        entry.Message = message
        entry.Component = l.component

        // Add existing fields
        for k, v := range l.fields </span><span class="cov8" title="27">{
                entry.Fields[k] = v
        }</span>

        // Add additional fields
        <span class="cov8" title="29">for k, v := range additionalFields </span><span class="cov2" title="2">{
                entry.Fields[k] = v
        }</span>

        // Add caller information for errors and above
        <span class="cov8" title="29">if level &gt;= ErrorLevel </span><span class="cov5" title="9">{
                if caller := getCaller(); caller != "" </span><span class="cov5" title="9">{
                        entry.Caller = caller
                }</span>
        }

        // Format and write the log entry
        <span class="cov8" title="29">formatted := l.formatEntry(*entry)
        l.output.Write([]byte(formatted + "\n"))</span>
}

// formatEntry formats a log entry as JSON
func (l *Logger) formatEntry(entry LogEntry) string <span class="cov8" title="29">{
        // Simple JSON formatting (in production, you'd use encoding/json)
        timestamp := entry.Timestamp.Format(time.RFC3339)
        level := entry.Level.String()

        var parts []string
        parts = append(parts, fmt.Sprintf(`"timestamp":"%s"`, timestamp))
        parts = append(parts, fmt.Sprintf(`"level":"%s"`, level))
        parts = append(parts, fmt.Sprintf(`"message":"%s"`, escapeJSON(entry.Message)))

        if entry.Component != "" </span><span class="cov8" title="29">{
                parts = append(parts, fmt.Sprintf(`"component":"%s"`, entry.Component))
        }</span>

        <span class="cov8" title="29">if entry.Caller != "" </span><span class="cov5" title="9">{
                parts = append(parts, fmt.Sprintf(`"caller":"%s"`, entry.Caller))
        }</span>

        <span class="cov8" title="29">if entry.RequestID != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"request_id":"%s"`, entry.RequestID))
        }</span>

        <span class="cov8" title="29">if entry.UserID != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"user_id":"%s"`, entry.UserID))
        }</span>

        <span class="cov8" title="29">if entry.Operation != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"operation":"%s"`, entry.Operation))
        }</span>

        <span class="cov8" title="29">if entry.Duration != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"duration_ms":%d`, *entry.Duration))
        }</span>

        <span class="cov8" title="29">if entry.Error != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"error":"%s"`, escapeJSON(entry.Error)))
        }</span>

        <span class="cov8" title="29">if entry.HTTPMethod != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"http_method":"%s"`, entry.HTTPMethod))
        }</span>

        <span class="cov8" title="29">if entry.HTTPPath != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"http_path":"%s"`, entry.HTTPPath))
        }</span>

        <span class="cov8" title="29">if entry.HTTPStatus != 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"http_status":%d`, entry.HTTPStatus))
        }</span>

        <span class="cov8" title="29">if entry.HTTPLatency != nil </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf(`"http_latency_ms":%d`, *entry.HTTPLatency))
        }</span>

        // Add custom fields
        <span class="cov8" title="29">if len(entry.Fields) &gt; 0 </span><span class="cov6" title="10">{
                var fieldParts []string
                for k, v := range entry.Fields </span><span class="cov8" title="29">{
                        switch val := v.(type) </span>{
                        case string:<span class="cov7" title="17">
                                fieldParts = append(fieldParts, fmt.Sprintf(`"%s":"%s"`, k, escapeJSON(val)))</span>
                        case int, int32, int64:<span class="cov5" title="9">
                                fieldParts = append(fieldParts, fmt.Sprintf(`"%s":%v`, k, val))</span>
                        case float32, float64:<span class="cov1" title="1">
                                fieldParts = append(fieldParts, fmt.Sprintf(`"%s":%v`, k, val))</span>
                        case bool:<span class="cov1" title="1">
                                fieldParts = append(fieldParts, fmt.Sprintf(`"%s":%t`, k, val))</span>
                        default:<span class="cov1" title="1">
                                fieldParts = append(fieldParts, fmt.Sprintf(`"%s":"%v"`, k, val))</span>
                        }
                }
                <span class="cov6" title="10">if len(fieldParts) &gt; 0 </span><span class="cov6" title="10">{
                        parts = append(parts, strings.Join(fieldParts, ","))
                }</span>
        }

        <span class="cov8" title="29">return "{" + strings.Join(parts, ",") + "}"</span>
}

// getCaller returns the file and line number of the caller
func getCaller() string <span class="cov5" title="9">{
        // Skip getCaller -&gt; log -&gt; public method -&gt; actual caller
        _, file, line, ok := runtime.Caller(4)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Get just the filename, not the full path
        <span class="cov5" title="9">filename := filepath.Base(file)
        return fmt.Sprintf("%s:%d", filename, line)</span>
}

// escapeJSON escapes a string for JSON
func escapeJSON(s string) string <span class="cov10" title="53">{
        s = strings.ReplaceAll(s, `\`, `\\`)
        s = strings.ReplaceAll(s, `"`, `\"`)
        s = strings.ReplaceAll(s, "\n", `\n`)
        s = strings.ReplaceAll(s, "\r", `\r`)
        s = strings.ReplaceAll(s, "\t", `\t`)
        return s
}</span>

// Default logger instance
var defaultLogger = NewLogger(Config{
        Level:     InfoLevel,
        Component: "govc",
})

// SetDefaultLogger sets the default logger
func SetDefaultLogger(logger *Logger) <span class="cov3" title="3">{
        defaultLogger = logger
}</span>

// GetDefaultLogger returns the default logger
func GetDefaultLogger() *Logger <span class="cov3" title="3">{
        return defaultLogger
}</span>

// Package-level convenience functions
func Debug(message string) <span class="cov2" title="2">{
        defaultLogger.Debug(message)
}</span>

func Debugf(format string, args ...interface{}) <span class="cov1" title="1">{
        defaultLogger.Debugf(format, args...)
}</span>

func Info(message string) <span class="cov1" title="1">{
        defaultLogger.Info(message)
}</span>

func Infof(format string, args ...interface{}) <span class="cov1" title="1">{
        defaultLogger.Infof(format, args...)
}</span>

func Warn(message string) <span class="cov1" title="1">{
        defaultLogger.Warn(message)
}</span>

func Warnf(format string, args ...interface{}) <span class="cov1" title="1">{
        defaultLogger.Warnf(format, args...)
}</span>

func Error(message string) <span class="cov1" title="1">{
        defaultLogger.Error(message)
}</span>

func Errorf(format string, args ...interface{}) <span class="cov1" title="1">{
        defaultLogger.Errorf(format, args...)
}</span>

func ErrorWithErr(message string, err error) <span class="cov1" title="1">{
        defaultLogger.ErrorWithErr(message, err)
}</span>

func Fatal(message string) <span class="cov0" title="0">{
        defaultLogger.Fatal(message)
}</span>

func Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        defaultLogger.Fatalf(format, args...)
}</span>

// Gin middleware for request logging
func GinLogger(logger *Logger) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov3" title="3">{
                start := time.Now()
                path := c.Request.URL.Path
                method := c.Request.Method

                // Generate request ID
                requestID := generateRequestID()
                c.Set("request_id", requestID)

                // Process request
                c.Next()

                // Calculate latency
                latency := time.Since(start).Milliseconds()
                status := c.Writer.Status()

                // Get user ID if available
                userID := ""
                if user, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                        // Try to extract user ID from the auth context
                        if userData, ok := user.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if id, exists := userData["id"]; exists </span><span class="cov0" title="0">{
                                        if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                                                userID = idStr
                                        }</span>
                                }
                        }
                }

                // Log the request
                <span class="cov3" title="3">logFields := map[string]interface{}{
                        "request_id":      requestID,
                        "http_method":     method,
                        "http_path":       path,
                        "http_status":     status,
                        "http_latency_ms": latency,
                }

                if userID != "" </span><span class="cov0" title="0">{
                        logFields["user_id"] = userID
                }</span>

                <span class="cov3" title="3">logLevel := InfoLevel
                if status &gt;= 400 &amp;&amp; status &lt; 500 </span><span class="cov1" title="1">{
                        logLevel = WarnLevel
                }</span> else<span class="cov2" title="2"> if status &gt;= 500 </span><span class="cov1" title="1">{
                        logLevel = ErrorLevel
                }</span>

                <span class="cov3" title="3">logger.WithFields(logFields).log(logLevel, "HTTP request processed", nil)</span>
        }
}

// generateRequestID generates a unique request ID
func generateRequestID() string <span class="cov4" title="5">{
        return fmt.Sprintf("%d-%d", time.Now().UnixNano(), os.Getpid())
}</span>

// GetRequestID extracts request ID from gin context
func GetRequestID(c *gin.Context) string <span class="cov3" title="3">{
        if requestID, exists := c.Get("request_id"); exists </span><span class="cov2" title="2">{
                if id, ok := requestID.(string); ok </span><span class="cov1" title="1">{
                        return id
                }</span>
        }
        <span class="cov2" title="2">return ""</span>
}

// GetUserID extracts user ID from gin context
func GetUserID(c *gin.Context) string <span class="cov4" title="4">{
        if user, exists := c.Get("user"); exists </span><span class="cov3" title="3">{
                // Try to extract user ID from the auth context
                if userData, ok := user.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                        if id, exists := userData["id"]; exists </span><span class="cov1" title="1">{
                                if idStr, ok := id.(string); ok </span><span class="cov1" title="1">{
                                        return idStr
                                }</span>
                        }
                }
        }
        <span class="cov3" title="3">return ""</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package metrics

import (
        "net/http"
        "runtime"
        "strconv"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// PrometheusMetrics provides Prometheus-compatible metrics
type PrometheusMetrics struct {
        mu sync.RWMutex

        // HTTP metrics
        httpRequests map[string]int64   // method:status -&gt; count
        httpDuration map[string]float64 // method:path -&gt; total duration in seconds
        httpInFlight int64

        // Repository metrics
        repositoryCount  int64
        transactionCount int64

        // System metrics
        startTime         time.Time
        lastMetricsUpdate time.Time
}

// NewPrometheusMetrics creates a new Prometheus metrics instance
func NewPrometheusMetrics() *PrometheusMetrics <span class="cov4" title="9">{
        return &amp;PrometheusMetrics{
                httpRequests:      make(map[string]int64),
                httpDuration:      make(map[string]float64),
                startTime:         time.Now(),
                lastMetricsUpdate: time.Now(),
        }
}</span>

// RecordHTTPRequest records an HTTP request
func (p *PrometheusMetrics) RecordHTTPRequest(method, path string, status int, duration time.Duration) <span class="cov6" title="62">{
        p.mu.Lock()
        defer p.mu.Unlock()

        statusStr := strconv.Itoa(status)
        key := method + ":" + statusStr
        p.httpRequests[key]++

        pathKey := method + ":" + path
        p.httpDuration[pathKey] += duration.Seconds()

        p.lastMetricsUpdate = time.Now()
}</span>

// IncHTTPInFlight increments in-flight HTTP requests
func (p *PrometheusMetrics) IncHTTPInFlight() <span class="cov6" title="56">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.httpInFlight++
}</span>

// DecHTTPInFlight decrements in-flight HTTP requests
func (p *PrometheusMetrics) DecHTTPInFlight() <span class="cov6" title="55">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.httpInFlight--
}</span>

// SetRepositoryCount sets the current repository count
func (p *PrometheusMetrics) SetRepositoryCount(count int64) <span class="cov3" title="6">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.repositoryCount = count
        p.lastMetricsUpdate = time.Now()
}</span>

// SetTransactionCount sets the current transaction count
func (p *PrometheusMetrics) SetTransactionCount(count int64) <span class="cov3" title="5">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.transactionCount = count
        p.lastMetricsUpdate = time.Now()
}</span>

// PrometheusHandler returns a Gin handler for Prometheus metrics
func (p *PrometheusMetrics) PrometheusHandler() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                c.Header("Content-Type", "text/plain; version=0.0.4; charset=utf-8")
                c.String(http.StatusOK, p.generateMetrics())
        }</span>
}

// generateMetrics generates Prometheus-formatted metrics
func (p *PrometheusMetrics) generateMetrics() string <span class="cov4" title="12">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        var metrics []string

        // HTTP request metrics
        metrics = append(metrics, "# HELP govc_http_requests_total The total number of HTTP requests")
        metrics = append(metrics, "# TYPE govc_http_requests_total counter")
        for key, count := range p.httpRequests </span><span class="cov4" title="14">{
                parts := splitMethodStatus(key)
                if len(parts) == 2 </span><span class="cov4" title="14">{
                        method, status := parts[0], parts[1]
                        metrics = append(metrics,
                                "govc_http_requests_total{method=\""+method+"\",status=\""+status+"\"} "+strconv.FormatInt(count, 10))
                }</span>
        }

        // HTTP duration metrics
        <span class="cov4" title="12">metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_http_request_duration_seconds The total time spent on HTTP requests")
        metrics = append(metrics, "# TYPE govc_http_request_duration_seconds counter")
        for key, duration := range p.httpDuration </span><span class="cov4" title="14">{
                parts := splitMethodPath(key)
                if len(parts) == 2 </span><span class="cov4" title="14">{
                        method, path := parts[0], parts[1]
                        // Sanitize path for Prometheus labels
                        path = sanitizePrometheusLabel(path)
                        metrics = append(metrics,
                                "govc_http_request_duration_seconds{method=\""+method+"\",path=\""+path+"\"} "+formatFloat(duration))
                }</span>
        }

        // In-flight requests
        <span class="cov4" title="12">metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_http_requests_in_flight The current number of in-flight HTTP requests")
        metrics = append(metrics, "# TYPE govc_http_requests_in_flight gauge")
        metrics = append(metrics, "govc_http_requests_in_flight "+strconv.FormatInt(p.httpInFlight, 10))

        // Application metrics
        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_repositories_total The total number of repositories")
        metrics = append(metrics, "# TYPE govc_repositories_total gauge")
        metrics = append(metrics, "govc_repositories_total "+strconv.FormatInt(p.repositoryCount, 10))

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_transactions_active The number of active transactions")
        metrics = append(metrics, "# TYPE govc_transactions_active gauge")
        metrics = append(metrics, "govc_transactions_active "+strconv.FormatInt(p.transactionCount, 10))

        // System uptime
        uptime := time.Since(p.startTime).Seconds()
        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_uptime_seconds The uptime of the govc server in seconds")
        metrics = append(metrics, "# TYPE govc_uptime_seconds counter")
        metrics = append(metrics, "govc_uptime_seconds "+formatFloat(uptime))

        // Go runtime metrics
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use")
        metrics = append(metrics, "# TYPE go_memstats_alloc_bytes gauge")
        metrics = append(metrics, "go_memstats_alloc_bytes "+strconv.FormatUint(memStats.Alloc, 10))

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP go_memstats_total_alloc_bytes Total number of bytes allocated, even if freed")
        metrics = append(metrics, "# TYPE go_memstats_total_alloc_bytes counter")
        metrics = append(metrics, "go_memstats_total_alloc_bytes "+strconv.FormatUint(memStats.TotalAlloc, 10))

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP go_memstats_sys_bytes Number of bytes obtained from system")
        metrics = append(metrics, "# TYPE go_memstats_sys_bytes gauge")
        metrics = append(metrics, "go_memstats_sys_bytes "+strconv.FormatUint(memStats.Sys, 10))

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP go_goroutines Number of goroutines that currently exist")
        metrics = append(metrics, "# TYPE go_goroutines gauge")
        metrics = append(metrics, "go_goroutines "+strconv.Itoa(runtime.NumGoroutine()))

        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP go_memstats_gc_total Number of completed GC cycles")
        metrics = append(metrics, "# TYPE go_memstats_gc_total counter")
        metrics = append(metrics, "go_memstats_gc_total "+strconv.FormatUint(uint64(memStats.NumGC), 10))

        // Last metrics update
        lastUpdate := p.lastMetricsUpdate.Unix()
        metrics = append(metrics, "")
        metrics = append(metrics, "# HELP govc_last_metrics_update_timestamp_seconds Timestamp of the last metrics update")
        metrics = append(metrics, "# TYPE govc_last_metrics_update_timestamp_seconds gauge")
        metrics = append(metrics, "govc_last_metrics_update_timestamp_seconds "+strconv.FormatInt(lastUpdate, 10))

        return joinMetrics(metrics)</span>
}

// Helper functions

func splitMethodStatus(key string) []string <span class="cov5" title="19">{
        for i := 0; i &lt; len(key); i++ </span><span class="cov7" title="73">{
                if key[i] == ':' </span><span class="cov5" title="17">{
                        return []string{key[:i], key[i+1:]}
                }</span>
        }
        <span class="cov1" title="2">return []string{key}</span>
}

func splitMethodPath(key string) []string <span class="cov5" title="17">{
        for i := 0; i &lt; len(key); i++ </span><span class="cov7" title="72">{
                if key[i] == ':' </span><span class="cov4" title="16">{
                        return []string{key[:i], key[i+1:]}
                }</span>
        }
        <span class="cov1" title="1">return []string{key}</span>
}

func sanitizePrometheusLabel(path string) string <span class="cov5" title="20">{
        // Replace path parameters with placeholders for better grouping
        result := path

        // Common replacements for API paths
        replacements := map[string]string{
                "/api/v1/repos/": "/api/v1/repos/{repo_id}",
                "/commits/":      "/commits/{commit}",
                "/branches/":     "/branches/{branch}",
                "/stash/":        "/stash/{stash_id}",
                "/users/":        "/users/{user_id}",
                "/hooks/":        "/hooks/{hook_id}",
        }

        for pattern, replacement := range replacements </span><span class="cov7" title="120">{
                if len(result) &gt; len(pattern) </span><span class="cov6" title="51">{
                        // Simple pattern matching for common API structures
                        for i := 0; i &lt;= len(result)-len(pattern); i++ </span><span class="cov9" title="542">{
                                if result[i:i+len(pattern)] == pattern </span><span class="cov3" title="7">{
                                        // Check if there's more path after the pattern
                                        remaining := result[i+len(pattern):]
                                        if remaining != "" </span><span class="cov3" title="7">{
                                                // Find the next slash or end
                                                nextSlash := 0
                                                for j, c := range remaining </span><span class="cov6" title="57">{
                                                        if c == '/' </span><span class="cov1" title="1">{
                                                                nextSlash = j
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov3" title="7">if nextSlash == 0 </span><span class="cov3" title="6">{
                                                        nextSlash = len(remaining)
                                                }</span>

                                                // Replace the ID with placeholder
                                                <span class="cov3" title="7">result = result[:i] + replacement + remaining[nextSlash:]
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov5" title="20">return result</span>
}

func formatFloat(f float64) string <span class="cov5" title="30">{
        return strconv.FormatFloat(f, 'f', -1, 64)
}</span>

func joinMetrics(metrics []string) string <span class="cov4" title="14">{
        result := ""
        for i, metric := range metrics </span><span class="cov10" title="571">{
                result += metric
                if i &lt; len(metrics)-1 </span><span class="cov9" title="558">{
                        result += "\n"
                }</span>
        }
        <span class="cov4" title="14">return result + "\n"</span>
}

// Middleware for automatic metrics collection
func (p *PrometheusMetrics) GinMiddleware() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov1" title="2">{
                start := time.Now()
                path := c.Request.URL.Path
                method := c.Request.Method

                // Increment in-flight requests
                p.IncHTTPInFlight()
                defer p.DecHTTPInFlight()

                // Process request
                c.Next()

                // Record metrics
                duration := time.Since(start)
                status := c.Writer.Status()

                p.RecordHTTPRequest(method, path, status, duration)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package core

import (
        "fmt"
        "sync"

        "github.com/Caia-Tech/govc/pkg/object"
        "github.com/Caia-Tech/govc/pkg/refs"
        "github.com/Caia-Tech/govc/pkg/storage"
)

// ObjectStoreAdapter adapts existing storage.Store to ObjectStore interface
type ObjectStoreAdapter struct {
        Store *storage.Store
}

func (a *ObjectStoreAdapter) Get(hash string) (object.Object, error) <span class="cov0" title="0">{
        return a.Store.GetObject(hash)
}</span>

func (a *ObjectStoreAdapter) Put(obj object.Object) (string, error) <span class="cov0" title="0">{
        return a.Store.StoreObject(obj)
}</span>

func (a *ObjectStoreAdapter) Exists(hash string) bool <span class="cov0" title="0">{
        _, err := a.Store.GetObject(hash)
        return err == nil
}</span>

func (a *ObjectStoreAdapter) List() ([]string, error) <span class="cov0" title="0">{
        // This would need to be implemented in storage.Store
        return nil, fmt.Errorf("list not implemented")
}</span>

func (a *ObjectStoreAdapter) Size() (int64, error) <span class="cov0" title="0">{
        // This would need to be implemented in storage.Store
        return 0, fmt.Errorf("size not implemented")
}</span>

func (a *ObjectStoreAdapter) Close() error <span class="cov0" title="0">{
        // Storage.Store doesn't have Close
        return nil
}</span>

// RefStoreAdapter adapts refs.RefManager to RefStore interface
type RefStoreAdapter struct {
        RefManager *refs.RefManager
        Store      refs.RefStore
}

func (a *RefStoreAdapter) GetRef(name string) (string, error) <span class="cov0" title="0">{
        return a.Store.GetRef(name)
}</span>

func (a *RefStoreAdapter) UpdateRef(name, hash string) error <span class="cov0" title="0">{
        return a.Store.SetRef(name, hash)
}</span>

func (a *RefStoreAdapter) DeleteRef(name string) error <span class="cov0" title="0">{
        return a.Store.DeleteRef(name)
}</span>

func (a *RefStoreAdapter) ListRefs() (map[string]string, error) <span class="cov0" title="0">{
        refs, err := a.Store.ListRefs("")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[string]string)
        for _, ref := range refs </span><span class="cov0" title="0">{
                result[ref.Name] = ref.Hash
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (a *RefStoreAdapter) GetHEAD() (string, error) <span class="cov0" title="0">{
        return a.RefManager.GetHEAD()
}</span>

func (a *RefStoreAdapter) SetHEAD(ref string) error <span class="cov0" title="0">{
        // Try to set as branch first
        if err := a.RefManager.SetHEADToBranch(ref); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Otherwise set as detached
        <span class="cov0" title="0">return a.RefManager.SetHEADToCommit(ref)</span>
}

func (a *RefStoreAdapter) Close() error <span class="cov0" title="0">{
        // RefManager doesn't have Close
        return nil
}</span>

// MemoryObjectStore is a simple in-memory implementation of ObjectStore
type MemoryObjectStore struct {
        mu      sync.RWMutex
        objects map[string]object.Object
}

func NewMemoryObjectStore() *MemoryObjectStore <span class="cov5" title="5">{
        return &amp;MemoryObjectStore{
                objects: make(map[string]object.Object),
        }
}</span>

func (m *MemoryObjectStore) Get(hash string) (object.Object, error) <span class="cov10" title="37">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        obj, ok := m.objects[hash]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object not found: %s", hash)
        }</span>
        <span class="cov10" title="37">return obj, nil</span>
}

func (m *MemoryObjectStore) Put(obj object.Object) (string, error) <span class="cov8" title="19">{
        hash := obj.Hash()
        m.mu.Lock()
        defer m.mu.Unlock()
        m.objects[hash] = obj
        return hash, nil
}</span>

func (m *MemoryObjectStore) Exists(hash string) bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        _, ok := m.objects[hash]
        return ok
}</span>

func (m *MemoryObjectStore) List() ([]string, error) <span class="cov1" title="1">{
        hashes := make([]string, 0, len(m.objects))
        for hash := range m.objects </span><span class="cov2" title="2">{
                hashes = append(hashes, hash)
        }</span>
        <span class="cov1" title="1">return hashes, nil</span>
}

func (m *MemoryObjectStore) Size() (int64, error) <span class="cov1" title="1">{
        var size int64
        for _, obj := range m.objects </span><span class="cov2" title="2">{
                size += obj.Size()
        }</span>
        <span class="cov1" title="1">return size, nil</span>
}

func (m *MemoryObjectStore) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// MemoryRefStore is a simple in-memory implementation of RefStore
type MemoryRefStore struct {
        mu   sync.RWMutex
        refs map[string]string
        head string
}

func NewMemoryRefStore() *MemoryRefStore <span class="cov5" title="5">{
        return &amp;MemoryRefStore{
                refs: make(map[string]string),
                head: "refs/heads/main",
        }
}</span>

func (m *MemoryRefStore) GetRef(name string) (string, error) <span class="cov9" title="25">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        hash, ok := m.refs[name]
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("ref not found: %s", name)
        }</span>
        <span class="cov8" title="24">return hash, nil</span>
}

func (m *MemoryRefStore) UpdateRef(name, hash string) error <span class="cov7" title="12">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.refs[name] = hash
        return nil
}</span>

func (m *MemoryRefStore) DeleteRef(name string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.refs, name)
        return nil
}</span>

func (m *MemoryRefStore) ListRefs() (map[string]string, error) <span class="cov3" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        result := make(map[string]string)
        for k, v := range m.refs </span><span class="cov5" title="7">{
                result[k] = v
        }</span>
        <span class="cov3" title="3">return result, nil</span>
}

func (m *MemoryRefStore) GetHEAD() (string, error) <span class="cov5" title="5">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.head, nil
}</span>

func (m *MemoryRefStore) SetHEAD(ref string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.head = ref
        return nil
}</span>

func (m *MemoryRefStore) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// MemoryWorkingStorage is an in-memory implementation of WorkingStorage
type MemoryWorkingStorage struct {
        mu    sync.RWMutex
        files map[string][]byte
}

func NewMemoryWorkingStorage() *MemoryWorkingStorage <span class="cov4" title="4">{
        return &amp;MemoryWorkingStorage{
                files: make(map[string][]byte),
        }
}</span>

func (m *MemoryWorkingStorage) Read(path string) ([]byte, error) <span class="cov9" title="26">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        content, ok := m.files[path]
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("file not found: %s", path)
        }</span>
        <span class="cov9" title="25">return content, nil</span>
}

func (m *MemoryWorkingStorage) Write(path string, content []byte) error <span class="cov8" title="18">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.files[path] = content
        return nil
}</span>

func (m *MemoryWorkingStorage) Delete(path string) error <span class="cov3" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.files, path)
        return nil
}</span>

func (m *MemoryWorkingStorage) List() ([]string, error) <span class="cov7" title="12">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        paths := make([]string, 0, len(m.files))
        for path := range m.files </span><span class="cov8" title="18">{
                paths = append(paths, path)
        }</span>
        <span class="cov7" title="12">return paths, nil</span>
}

func (m *MemoryWorkingStorage) Clear() error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.files = make(map[string][]byte)
        return nil
}</span>

func (m *MemoryWorkingStorage) Exists(path string) bool <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        _, ok := m.files[path]
        return ok
}</span>

func (m *MemoryWorkingStorage) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// FileWorkingStorage is a file-based implementation of WorkingStorage
type FileWorkingStorage struct {
        root string
}

func NewFileWorkingStorage(root string) *FileWorkingStorage <span class="cov0" title="0">{
        return &amp;FileWorkingStorage{root: root}
}</span>

func (f *FileWorkingStorage) Read(path string) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would read from filesystem
        return nil, fmt.Errorf("not implemented")
}</span>

func (f *FileWorkingStorage) Write(path string, content []byte) error <span class="cov0" title="0">{
        // Implementation would write to filesystem
        return fmt.Errorf("not implemented")
}</span>

func (f *FileWorkingStorage) Delete(path string) error <span class="cov0" title="0">{
        // Implementation would delete from filesystem
        return fmt.Errorf("not implemented")
}</span>

func (f *FileWorkingStorage) List() ([]string, error) <span class="cov0" title="0">{
        // Implementation would list files
        return nil, fmt.Errorf("not implemented")
}</span>

func (f *FileWorkingStorage) Clear() error <span class="cov0" title="0">{
        // Implementation would clear working directory
        return fmt.Errorf("not implemented")
}</span>

func (f *FileWorkingStorage) Exists(path string) bool <span class="cov0" title="0">{
        // Implementation would check filesystem
        return false
}</span>

func (f *FileWorkingStorage) Close() error <span class="cov0" title="0">{
        return nil
}</span>

// MemoryConfigStore is an in-memory config store
type MemoryConfigStore struct {
        values map[string]string
}

func NewMemoryConfigStore() *MemoryConfigStore <span class="cov4" title="4">{
        return &amp;MemoryConfigStore{
                values: make(map[string]string),
        }
}</span>

func (m *MemoryConfigStore) Get(key string) (string, error) <span class="cov6" title="8">{
        value, ok := m.values[key]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("key not found: %s", key)
        }</span>
        <span class="cov6" title="8">return value, nil</span>
}

func (m *MemoryConfigStore) Set(key, value string) error <span class="cov6" title="8">{
        m.values[key] = value
        return nil
}</span>

func (m *MemoryConfigStore) Delete(key string) error <span class="cov0" title="0">{
        delete(m.values, key)
        return nil
}</span>

func (m *MemoryConfigStore) List() (map[string]string, error) <span class="cov0" title="0">{
        result := make(map[string]string)
        for k, v := range m.values </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (m *MemoryConfigStore) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

// Config manages repository configuration
type Config struct {
        store ConfigStore
}

// NewConfig creates a new config manager
func NewConfig(store ConfigStore) *Config <span class="cov7" title="4">{
        return &amp;Config{store: store}
}</span>

// Get retrieves a configuration value
func (c *Config) Get(key string) (string, error) <span class="cov0" title="0">{
        return c.store.Get(key)
}</span>

// Set sets a configuration value
func (c *Config) Set(key, value string) error <span class="cov10" title="8">{
        return c.store.Set(key, value)
}</span>

// Delete removes a configuration value
func (c *Config) Delete(key string) error <span class="cov0" title="0">{
        return c.store.Delete(key)
}</span>

// List returns all configuration values
func (c *Config) List() (map[string]string, error) <span class="cov0" title="0">{
        return c.store.List()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package core

import (
        "io"
        "time"

        "github.com/Caia-Tech/govc/pkg/object"
)

// ObjectStore defines the interface for storing immutable Git objects
type ObjectStore interface {
        // Get retrieves an object by its hash
        Get(hash string) (object.Object, error)

        // Put stores an object and returns its hash
        Put(obj object.Object) (string, error)

        // Exists checks if an object exists
        Exists(hash string) bool

        // List returns all object hashes
        List() ([]string, error)

        // Size returns the total size of stored objects
        Size() (int64, error)

        // Close releases any resources
        io.Closer
}

// RefStore defines the interface for managing references
type RefStore interface {
        // GetRef returns the hash a reference points to
        GetRef(name string) (string, error)

        // UpdateRef updates a reference to point to a new hash
        UpdateRef(name string, hash string) error

        // DeleteRef removes a reference
        DeleteRef(name string) error

        // ListRefs returns all references
        ListRefs() (map[string]string, error)

        // GetHEAD returns what HEAD points to
        GetHEAD() (string, error)

        // SetHEAD updates HEAD
        SetHEAD(target string) error

        // Close releases any resources
        io.Closer
}

// WorkingStorage defines the interface for working directory storage
type WorkingStorage interface {
        // Read reads a file from working directory
        Read(path string) ([]byte, error)

        // Write writes a file to working directory
        Write(path string, data []byte) error

        // Delete removes a file from working directory
        Delete(path string) error

        // List returns all files in working directory
        List() ([]string, error)

        // Clear removes all files
        Clear() error

        // Exists checks if a file exists
        Exists(path string) bool

        // Close releases any resources
        io.Closer
}

// ConfigStore defines the interface for configuration storage
type ConfigStore interface {
        // Get retrieves a config value
        Get(key string) (string, error)

        // Set stores a config value
        Set(key, value string) error

        // Delete removes a config value
        Delete(key string) error

        // List returns all config keys
        List() (map[string]string, error)

        // Close releases any resources
        io.Closer
}

// Repository represents the core immutable Git repository
// It only handles objects and references, no mutable state
type Repository struct {
        objects ObjectStore
        refs    RefStore
}

// NewRepository creates a new repository with the given stores
func NewRepository(objects ObjectStore, refs RefStore) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                objects: objects,
                refs:    refs,
        }
}</span>

// Objects returns the object store
func (r *Repository) Objects() ObjectStore <span class="cov0" title="0">{
        return r.objects
}</span>

// Refs returns the reference store
func (r *Repository) Refs() RefStore <span class="cov0" title="0">{
        return r.refs
}</span>

// Workspace represents the mutable working directory state
type Workspace struct {
        repo    *Repository
        working WorkingStorage
        staging *StagingArea
}

// NewWorkspace creates a new workspace
func NewWorkspace(repo *Repository, working WorkingStorage) *Workspace <span class="cov0" title="0">{
        return &amp;Workspace{
                repo:    repo,
                working: working,
                staging: NewStagingArea(),
        }
}</span>

// StagingArea represents the Git staging area (index)
type StagingArea struct {
        entries map[string]StagedEntry
}

// StagedEntry represents a file in the staging area
type StagedEntry struct {
        Hash string
        Mode string
}

// NewStagingArea creates a new empty staging area
func NewStagingArea() *StagingArea <span class="cov0" title="0">{
        return &amp;StagingArea{
                entries: make(map[string]StagedEntry),
        }
}</span>

// Event represents a repository event
type Event struct {
        Type      string
        Timestamp time.Time
        Data      interface{}
}

// EventHandler handles repository events
type EventHandler func(event Event) error

// EventManager manages repository events and webhooks
type EventManager struct {
        handlers []EventHandler
}

// NewEventManager creates a new event manager
func NewEventManager() *EventManager <span class="cov0" title="0">{
        return &amp;EventManager{
                handlers: make([]EventHandler, 0),
        }
}</span>

// Subscribe adds an event handler
func (em *EventManager) Subscribe(handler EventHandler) <span class="cov0" title="0">{
        em.handlers = append(em.handlers, handler)
}</span>

// Publish sends an event to all handlers
func (em *EventManager) Publish(event Event) <span class="cov0" title="0">{
        for _, handler := range em.handlers </span><span class="cov0" title="0">{
                // Run handlers asynchronously
                go handler(event)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package core

import (
        "time"

        "github.com/Caia-Tech/govc/pkg/object"
        "github.com/Caia-Tech/govc/pkg/refs"
        "github.com/Caia-Tech/govc/pkg/storage"
)

// MigrateRepository shows how to migrate from old Repository to new architecture
// This is a temporary helper during refactoring
func MigrateRepository(old interface{}) (*Repository, *Workspace, error) <span class="cov0" title="0">{
        // This would extract the stores from the old repository
        // and create the new clean separation

        // For now, return a simple example
        objStore := storage.NewMemoryObjectStore()
        refStore := storage.NewMemoryRefStore()

        repo := NewRepository(objStore, refStore)

        workingStore := storage.NewMemoryWorkingStorage()
        workspace := NewWorkspace(repo, workingStore)

        return repo, workspace, nil
}</span>

// GitOperations provides high-level Git operations using the clean architecture
type GitOperations struct {
        repo      *Repository
        workspace *Workspace
        config    *Config
        events    *EventManager
}

// NewGitOperations creates a new Git operations handler
func NewGitOperations(repo *Repository, workspace *Workspace, config *Config) *GitOperations <span class="cov0" title="0">{
        return &amp;GitOperations{
                repo:      repo,
                workspace: workspace,
                config:    config,
                events:    NewEventManager(),
        }
}</span>

// Add stages a file (example of how operations would work)
func (g *GitOperations) Add(path string) error <span class="cov0" title="0">{
        // Read from working directory
        content, err := g.workspace.working.Read(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create blob object
        <span class="cov0" title="0">blob := object.NewBlob(content)

        // Store in object database
        hash, err := g.repo.objects.Put(blob)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add to staging area
        <span class="cov0" title="0">g.workspace.staging.entries[path] = StagedEntry{
                Hash: hash,
                Mode: "100644",
        }

        // Publish event
        g.events.Publish(Event{
                Type: "file.staged",
                Data: map[string]string{
                        "path": path,
                        "hash": hash,
                },
        })

        return nil</span>
}

// Commit creates a new commit (example of clean separation)
func (g *GitOperations) Commit(message string) (string, error) <span class="cov0" title="0">{
        // Build tree from staging area
        tree := g.buildTreeFromStaging()

        // Store tree object
        treeHash, err := g.repo.objects.Put(tree)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get parent commit
        <span class="cov0" title="0">parentHash := ""
        headRef, err := g.repo.refs.GetHEAD()
        if err == nil &amp;&amp; headRef != "" </span><span class="cov0" title="0">{
                // Resolve ref to commit hash
                if ref, err := g.repo.refs.GetRef(headRef); err == nil </span><span class="cov0" title="0">{
                        parentHash = ref
                }</span>
        }

        // Create commit object
        <span class="cov0" title="0">authorName, _ := g.config.store.Get("user.name")
        authorEmail, _ := g.config.store.Get("user.email")
        author := object.Author{
                Name:  authorName,
                Email: authorEmail,
                Time:  time.Now(),
        }

        commit := object.NewCommit(treeHash, author, message)
        if parentHash != "" </span><span class="cov0" title="0">{
                commit.SetParent(parentHash)
        }</span>

        // Store commit
        <span class="cov0" title="0">commitHash, err := g.repo.objects.Put(commit)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Update HEAD
        <span class="cov0" title="0">err = g.repo.refs.UpdateRef("HEAD", commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Clear staging area
        <span class="cov0" title="0">g.workspace.staging = NewStagingArea()

        // Publish event
        g.events.Publish(Event{
                Type: "commit.created",
                Data: map[string]string{
                        "hash":    commitHash,
                        "message": message,
                },
        })

        return commitHash, nil</span>
}

func (g *GitOperations) buildTreeFromStaging() *object.Tree <span class="cov0" title="0">{
        entries := make([]object.TreeEntry, 0, len(g.workspace.staging.entries))

        for path, staged := range g.workspace.staging.entries </span><span class="cov0" title="0">{
                entries = append(entries, object.TreeEntry{
                        Mode: staged.Mode,
                        Name: path,
                        Hash: staged.Hash,
                })
        }</span>

        <span class="cov0" title="0">tree := object.NewTree()
        tree.Entries = entries
        return tree</span>
}

// Example of how to use adapters during migration
func AdaptOldRefManager(oldRefManager *refs.RefManager) RefStore <span class="cov0" title="0">{
        return storage.NewRefManagerAdapter(oldRefManager)
}</span>

// Example of how to adapt old store
func AdaptOldStore(oldStore *storage.Store) ObjectStore <span class="cov0" title="0">{
        return storage.NewStoreAdapter(oldStore)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package core

import (
        "fmt"
        "time"

        "github.com/Caia-Tech/govc/pkg/object"
)

// Operations provides high-level Git operations using clean architecture
type Operations struct {
        repo      *CleanRepository
        workspace *CleanWorkspace
        config    *Config
}

// NewOperations creates a new operations handler
func NewOperations(repo *CleanRepository, workspace *CleanWorkspace, config *Config) *Operations <span class="cov10" title="4">{
        return &amp;Operations{
                repo:      repo,
                workspace: workspace,
                config:    config,
        }
}</span>

// Init initializes a new repository
func (ops *Operations) Init() error <span class="cov10" title="4">{
        // Create initial branch reference
        return ops.repo.refs.UpdateRef("refs/heads/main", "")
}</span>

// Add stages files
func (ops *Operations) Add(paths ...string) error <span class="cov8" title="3">{
        for _, path := range paths </span><span class="cov8" title="3">{
                if err := ops.workspace.Add(path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="3">return nil</span>
}

// Commit creates a new commit
func (ops *Operations) Commit(message string) (string, error) <span class="cov10" title="4">{
        // Check if there are changes to commit
        staging := ops.workspace.GetStagingArea()
        if len(staging.entries) == 0 &amp;&amp; len(staging.removed) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("nothing to commit")
        }</span>

        // Get author info from config
        <span class="cov10" title="4">authorName, _ := ops.config.store.Get("user.name")
        if authorName == "" </span><span class="cov0" title="0">{
                authorName = "Unknown"
        }</span>

        <span class="cov10" title="4">authorEmail, _ := ops.config.store.Get("user.email")
        if authorEmail == "" </span><span class="cov0" title="0">{
                authorEmail = "unknown@example.com"
        }</span>

        <span class="cov10" title="4">author := object.Author{
                Name:  authorName,
                Email: authorEmail,
                Time:  time.Now(),
        }

        // Build tree from staging area
        tree := ops.buildTreeFromStaging()
        treeHash, err := ops.repo.objects.Put(tree)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get parent commit
        <span class="cov10" title="4">parentHash := ""
        if currentBranch := ops.workspace.branch; currentBranch != "" </span><span class="cov10" title="4">{
                parentHash, _ = ops.repo.GetBranch(currentBranch)
        }</span>

        // Create commit
        <span class="cov10" title="4">commit := object.NewCommit(treeHash, author, message)
        if parentHash != "" </span><span class="cov0" title="0">{
                commit.SetParent(parentHash)
        }</span>
        <span class="cov10" title="4">commitHash, err := ops.repo.objects.Put(commit)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Update branch reference
        <span class="cov10" title="4">branchRef := fmt.Sprintf("refs/heads/%s", ops.workspace.branch)
        if err := ops.repo.refs.UpdateRef(branchRef, commitHash); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Clear staging area
        <span class="cov10" title="4">ops.workspace.Reset()

        return commitHash, nil</span>
}

// Branch creates a new branch
func (ops *Operations) Branch(name string) error <span class="cov1" title="1">{
        // Get current HEAD
        currentHash, err := ops.repo.GetBranch(ops.workspace.branch)
        if err != nil </span><span class="cov0" title="0">{
                // No commits yet
                currentHash = ""
        }</span>

        // Create branch reference
        <span class="cov1" title="1">branchRef := fmt.Sprintf("refs/heads/%s", name)
        return ops.repo.refs.UpdateRef(branchRef, currentHash)</span>
}

// DeleteBranch deletes a branch
func (ops *Operations) DeleteBranch(name string) error <span class="cov0" title="0">{
        // Don't allow deleting current branch
        if name == ops.workspace.branch </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete current branch")
        }</span>

        // Check if branch exists
        <span class="cov0" title="0">if _, err := ops.repo.GetBranch(name); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("branch not found: %s", name)
        }</span>

        // Delete branch reference
        <span class="cov0" title="0">branchRef := fmt.Sprintf("refs/heads/%s", name)
        return ops.repo.refs.DeleteRef(branchRef)</span>
}

// Checkout switches to a branch
func (ops *Operations) Checkout(branch string) error <span class="cov1" title="1">{
        return ops.workspace.Checkout(branch)
}</span>

// Status returns repository status
func (ops *Operations) Status() (*Status, error) <span class="cov10" title="4">{
        return ops.workspace.Status()
}</span>

// Log returns commit history
func (ops *Operations) Log(limit int) ([]*object.Commit, error) <span class="cov1" title="1">{
        // Get current branch
        currentHash, err := ops.repo.GetBranch(ops.workspace.branch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no commits on branch %s", ops.workspace.branch)
        }</span>

        <span class="cov1" title="1">return ops.repo.Log(currentHash, limit)</span>
}

// Merge merges another branch into current branch
func (ops *Operations) Merge(branch string, message string) (string, error) <span class="cov0" title="0">{
        // Get both branch commits
        currentHash, err := ops.repo.GetBranch(ops.workspace.branch)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("current branch has no commits")
        }</span>

        <span class="cov0" title="0">otherHash, err := ops.repo.GetBranch(branch)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("branch %s not found", branch)
        }</span>

        // For now, implement fast-forward only
        // Full merge would require three-way merge algorithm

        // Check if fast-forward is possible
        <span class="cov0" title="0">commits, err := ops.repo.Log(otherHash, 0)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if current is ancestor of other
        <span class="cov0" title="0">isAncestor := false
        for _, commit := range commits </span><span class="cov0" title="0">{
                if commit.Hash() == currentHash </span><span class="cov0" title="0">{
                        isAncestor = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if isAncestor </span><span class="cov0" title="0">{
                // Fast-forward merge
                branchRef := fmt.Sprintf("refs/heads/%s", ops.workspace.branch)
                if err := ops.repo.refs.UpdateRef(branchRef, otherHash); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Update working directory
                <span class="cov0" title="0">if err := ops.workspace.Checkout(ops.workspace.branch); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return otherHash, nil</span>
        }

        // Would need three-way merge here
        <span class="cov0" title="0">return "", fmt.Errorf("three-way merge not yet implemented")</span>
}

// Tag creates a new tag
func (ops *Operations) Tag(name string) error <span class="cov1" title="1">{
        // Get current HEAD
        currentHash, err := ops.repo.GetBranch(ops.workspace.branch)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no commits to tag")
        }</span>

        // Create tag reference
        <span class="cov1" title="1">tagRef := fmt.Sprintf("refs/tags/%s", name)
        return ops.repo.refs.UpdateRef(tagRef, currentHash)</span>
}

// buildTreeFromStaging creates a tree from staging area
func (ops *Operations) buildTreeFromStaging() *object.Tree <span class="cov10" title="4">{
        staging := ops.workspace.GetStagingArea()
        entries := make([]object.TreeEntry, 0, len(staging.entries))

        for path, staged := range staging.entries </span><span class="cov10" title="4">{
                entries = append(entries, object.TreeEntry{
                        Mode: staged.Mode,
                        Name: path,
                        Hash: staged.Hash,
                })
        }</span>

        // Sort entries for consistent trees
        <span class="cov10" title="4">tree := object.NewTree()
        tree.Entries = entries
        return tree</span>
}

// Clone clones a repository (simplified version)
func Clone(sourceRepo *CleanRepository, targetObjects ObjectStore, targetRefs RefStore) (*CleanRepository, error) <span class="cov0" title="0">{
        // Copy all objects
        hashes, err := sourceRepo.objects.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, hash := range hashes </span><span class="cov0" title="0">{
                obj, err := sourceRepo.objects.Get(hash)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if _, err := targetObjects.Put(obj); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Copy all refs
        <span class="cov0" title="0">refs, err := sourceRepo.refs.ListRefs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for name, hash := range refs </span><span class="cov0" title="0">{
                if err := targetRefs.UpdateRef(name, hash); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Copy HEAD
        <span class="cov0" title="0">head, err := sourceRepo.refs.GetHEAD()
        if err == nil </span><span class="cov0" title="0">{
                targetRefs.SetHEAD(head)
        }</span>

        <span class="cov0" title="0">return NewCleanRepository(targetObjects, targetRefs), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

import (
        "fmt"
        "sort"
        "strings"

        "github.com/Caia-Tech/govc/pkg/object"
)

// CleanRepository represents the core immutable Git repository
// It only handles objects and references - no mutable state, no config, no webhooks
type CleanRepository struct {
        objects ObjectStore
        refs    RefStore
}

// NewCleanRepository creates a new clean repository
func NewCleanRepository(objects ObjectStore, refs RefStore) *CleanRepository <span class="cov4" title="4">{
        return &amp;CleanRepository{
                objects: objects,
                refs:    refs,
        }
}</span>

// GetObject retrieves any Git object by hash
func (r *CleanRepository) GetObject(hash string) (object.Object, error) <span class="cov0" title="0">{
        return r.objects.Get(hash)
}</span>

// GetCommit retrieves a commit by hash
func (r *CleanRepository) GetCommit(hash string) (*object.Commit, error) <span class="cov8" title="16">{
        obj, err := r.objects.Get(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="16">commit, ok := obj.(*object.Commit)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a commit", hash)
        }</span>

        <span class="cov8" title="16">return commit, nil</span>
}

// GetTree retrieves a tree by hash
func (r *CleanRepository) GetTree(hash string) (*object.Tree, error) <span class="cov8" title="15">{
        obj, err := r.objects.Get(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="15">tree, ok := obj.(*object.Tree)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a tree", hash)
        }</span>

        <span class="cov8" title="15">return tree, nil</span>
}

// GetBlob retrieves a blob by hash
func (r *CleanRepository) GetBlob(hash string) (*object.Blob, error) <span class="cov4" title="4">{
        obj, err := r.objects.Get(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="4">blob, ok := obj.(*object.Blob)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a blob", hash)
        }</span>

        <span class="cov4" title="4">return blob, nil</span>
}

// ListBranches returns all branches
func (r *CleanRepository) ListBranches() ([]Branch, error) <span class="cov1" title="1">{
        refs, err := r.refs.ListRefs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var branches []Branch
        for name, hash := range refs </span><span class="cov2" title="2">{
                if strings.HasPrefix(name, "refs/heads/") </span><span class="cov2" title="2">{
                        branchName := strings.TrimPrefix(name, "refs/heads/")
                        branches = append(branches, Branch{
                                Name: branchName,
                                Hash: hash,
                        })
                }</span>
        }

        // Sort for consistent output
        <span class="cov1" title="1">sort.Slice(branches, func(i, j int) bool </span><span class="cov1" title="1">{
                return branches[i].Name &lt; branches[j].Name
        }</span>)

        <span class="cov1" title="1">return branches, nil</span>
}

// GetBranch retrieves a specific branch
func (r *CleanRepository) GetBranch(name string) (string, error) <span class="cov10" title="23">{
        return r.refs.GetRef("refs/heads/" + name)
}</span>

// ListTags returns all tags
func (r *CleanRepository) ListTags() ([]Tag, error) <span class="cov1" title="1">{
        refs, err := r.refs.ListRefs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var tags []Tag
        for name, hash := range refs </span><span class="cov4" title="3">{
                if strings.HasPrefix(name, "refs/tags/") </span><span class="cov1" title="1">{
                        tagName := strings.TrimPrefix(name, "refs/tags/")
                        tags = append(tags, Tag{
                                Name: tagName,
                                Hash: hash,
                        })
                }</span>
        }

        // Sort for consistent output
        <span class="cov1" title="1">sort.Slice(tags, func(i, j int) bool </span><span class="cov0" title="0">{
                return tags[i].Name &lt; tags[j].Name
        }</span>)

        <span class="cov1" title="1">return tags, nil</span>
}

// GetTag retrieves a specific tag
func (r *CleanRepository) GetTag(name string) (string, error) <span class="cov0" title="0">{
        return r.refs.GetRef("refs/tags/" + name)
}</span>

// GetHEAD returns what HEAD points to
func (r *CleanRepository) GetHEAD() (string, error) <span class="cov4" title="3">{
        return r.refs.GetHEAD()
}</span>

// ResolveRef resolves a reference to a commit hash
func (r *CleanRepository) ResolveRef(ref string) (string, error) <span class="cov0" title="0">{
        // Try as direct hash first
        if r.objects.Exists(ref) </span><span class="cov0" title="0">{
                return ref, nil
        }</span>

        // Try as branch
        <span class="cov0" title="0">if hash, err := r.GetBranch(ref); err == nil </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        // Try as tag
        <span class="cov0" title="0">if hash, err := r.GetTag(ref); err == nil </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        // Try as full ref
        <span class="cov0" title="0">if hash, err := r.refs.GetRef(ref); err == nil </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        // Try HEAD
        <span class="cov0" title="0">if ref == "HEAD" </span><span class="cov0" title="0">{
                return r.GetHEAD()
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("reference not found: %s", ref)</span>
}

// Log returns commit history starting from a given commit
func (r *CleanRepository) Log(startHash string, limit int) ([]*object.Commit, error) <span class="cov1" title="1">{
        var commits []*object.Commit
        visited := make(map[string]bool)

        var walk func(hash string) error
        walk = func(hash string) error </span><span class="cov1" title="1">{
                if limit &gt; 0 &amp;&amp; len(commits) &gt;= limit </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov1" title="1">if visited[hash] </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov1" title="1">visited[hash] = true

                commit, err := r.GetCommit(hash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">commits = append(commits, commit)

                // Walk parent
                if commit.ParentHash != "" </span><span class="cov0" title="0">{
                        return walk(commit.ParentHash)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov1" title="1">if err := walk(startHash); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return commits, nil</span>
}

// Branch represents a Git branch
type Branch struct {
        Name string
        Hash string
}

// Tag represents a Git tag
type Tag struct {
        Name string
        Hash string
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "fmt"
        "time"

        "github.com/Caia-Tech/govc/pkg/object"
        "github.com/google/uuid"
)

// StashManager manages repository stashes
type StashManager struct {
        repo      *CleanRepository
        workspace *CleanWorkspace
        stashes   []*Stash
}

// NewStashManager creates a new stash manager
func NewStashManager(repo *CleanRepository, workspace *CleanWorkspace) *StashManager <span class="cov10" title="3">{
        return &amp;StashManager{
                repo:      repo,
                workspace: workspace,
                stashes:   make([]*Stash, 0),
        }
}</span>

// Stash represents a saved workspace state
type Stash struct {
        ID           string
        Message      string
        Author       object.Author
        TreeHash     string // Hash of the stashed tree
        ParentCommit string // Commit hash when stash was created
        Timestamp    time.Time
        Changes      map[string][]byte // Unstaged changes
        Index        map[string]string // Staged changes (path -&gt; hash)
        Untracked    map[string][]byte // Untracked files
}

// Create creates a new stash
func (sm *StashManager) Create(message string, includeUntracked bool) (*Stash, error) <span class="cov10" title="3">{
        // Get current HEAD
        head, err := sm.repo.GetHEAD()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot stash without commits")
        }</span>

        // Get current branch
        <span class="cov10" title="3">currentBranch := sm.workspace.branch
        currentCommit, err := sm.repo.GetBranch(currentBranch)
        if err != nil </span><span class="cov0" title="0">{
                currentCommit = head
        }</span>

        // Get status
        <span class="cov10" title="3">status, err := sm.workspace.Status()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">if status.Clean() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no local changes to stash")
        }</span>

        // Save staged changes
        <span class="cov10" title="3">staging := sm.workspace.GetStagingArea()
        index := make(map[string]string)
        for path, entry := range staging.entries </span><span class="cov6" title="2">{
                index[path] = entry.Hash
        }</span>

        // Save unstaged changes
        <span class="cov10" title="3">changes := make(map[string][]byte)
        for _, path := range status.Modified </span><span class="cov10" title="3">{
                content, err := sm.workspace.ReadFile(path)
                if err == nil </span><span class="cov10" title="3">{
                        changes[path] = content
                }</span>
        }

        // Save untracked files if requested
        <span class="cov10" title="3">untrackedFiles := make(map[string][]byte)
        if includeUntracked </span><span class="cov1" title="1">{
                for _, path := range status.Untracked </span><span class="cov1" title="1">{
                        content, err := sm.workspace.ReadFile(path)
                        if err == nil </span><span class="cov1" title="1">{
                                untrackedFiles[path] = content
                        }</span>
                }
        }

        // Create tree from current state
        <span class="cov10" title="3">tree := sm.buildTreeFromWorkspace()
        treeHash, err := sm.repo.objects.Put(tree)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create stash
        <span class="cov10" title="3">stash := &amp;Stash{
                ID:      uuid.New().String(),
                Message: message,
                Author: object.Author{
                        Name:  "Stash",
                        Email: "stash@govc",
                        Time:  time.Now(),
                },
                TreeHash:     treeHash,
                ParentCommit: currentCommit,
                Timestamp:    time.Now(),
                Changes:      changes,
                Index:        index,
                Untracked:    untrackedFiles,
        }

        sm.stashes = append(sm.stashes, stash)

        // Reset workspace to clean state
        sm.workspace.Reset()

        // Also need to restore files to their committed state
        // Get the committed tree
        commit, _ := sm.repo.GetCommit(currentCommit)
        var committedFiles map[string]string
        if commit != nil </span><span class="cov10" title="3">{
                tree, _ := sm.repo.GetTree(commit.TreeHash)
                if tree != nil </span><span class="cov10" title="3">{
                        committedFiles = make(map[string]string)
                        for _, entry := range tree.Entries </span><span class="cov10" title="3">{
                                committedFiles[entry.Name] = entry.Hash
                        }</span>
                }
        }

        // Restore modified files to committed state
        <span class="cov10" title="3">for path := range changes </span><span class="cov10" title="3">{
                if hash, exists := committedFiles[path]; exists </span><span class="cov10" title="3">{
                        // Restore original content
                        blob, err := sm.repo.GetBlob(hash)
                        if err == nil </span><span class="cov10" title="3">{
                                sm.workspace.WriteFile(path, blob.Content)
                        }</span>
                }
        }

        // Remove newly added files that were staged
        <span class="cov10" title="3">for path := range index </span><span class="cov6" title="2">{
                if _, exists := committedFiles[path]; !exists </span><span class="cov6" title="2">{
                        // This was a new file, remove it
                        sm.workspace.working.Delete(path)
                }</span>
        }

        // Remove untracked files if they were included
        <span class="cov10" title="3">for path := range untrackedFiles </span><span class="cov1" title="1">{
                sm.workspace.working.Delete(path)
        }</span>

        <span class="cov10" title="3">return stash, nil</span>
}

// List returns all stashes
func (sm *StashManager) List() []*Stash <span class="cov1" title="1">{
        return sm.stashes
}</span>

// Get returns a specific stash
func (sm *StashManager) Get(id string) (*Stash, error) <span class="cov6" title="2">{
        for _, stash := range sm.stashes </span><span class="cov6" title="2">{
                if stash.ID == id </span><span class="cov6" title="2">{
                        return stash, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("stash not found: %s", id)</span>
}

// Apply applies a stash to the current workspace
func (sm *StashManager) Apply(id string) error <span class="cov6" title="2">{
        stash, err := sm.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if workspace is clean
        <span class="cov6" title="2">status, err := sm.workspace.Status()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="2">if !status.Clean() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot apply stash: workspace has uncommitted changes")
        }</span>

        // Restore staged changes
        <span class="cov6" title="2">for path, hash := range stash.Index </span><span class="cov6" title="2">{
                // The object already exists in the repository
                sm.workspace.staging.entries[path] = StagedEntry{
                        Hash: hash,
                        Mode: "100644",
                }
        }</span>

        // Restore unstaged changes
        <span class="cov6" title="2">for path, content := range stash.Changes </span><span class="cov6" title="2">{
                if err := sm.workspace.WriteFile(path, content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Restore untracked files
        <span class="cov6" title="2">for path, content := range stash.Untracked </span><span class="cov1" title="1">{
                if err := sm.workspace.WriteFile(path, content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="2">return nil</span>
}

// Drop removes a stash
func (sm *StashManager) Drop(id string) error <span class="cov0" title="0">{
        for i, stash := range sm.stashes </span><span class="cov0" title="0">{
                if stash.ID == id </span><span class="cov0" title="0">{
                        // Remove from slice
                        sm.stashes = append(sm.stashes[:i], sm.stashes[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("stash not found: %s", id)</span>
}

// Pop applies and drops a stash
func (sm *StashManager) Pop(id string) error <span class="cov0" title="0">{
        if err := sm.Apply(id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sm.Drop(id)</span>
}

// buildTreeFromWorkspace creates a tree from the current workspace state
func (sm *StashManager) buildTreeFromWorkspace() *object.Tree <span class="cov10" title="3">{
        staging := sm.workspace.GetStagingArea()
        entries := make([]object.TreeEntry, 0, len(staging.entries))

        for path, staged := range staging.entries </span><span class="cov6" title="2">{
                entries = append(entries, object.TreeEntry{
                        Mode: staged.Mode,
                        Name: path,
                        Hash: staged.Hash,
                })
        }</span>

        <span class="cov10" title="3">tree := object.NewTree()
        tree.Entries = entries
        return tree</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/google/uuid"
)

// WebhookManager manages repository webhooks
type WebhookManager struct {
        webhooks map[string]*Webhook
}

// NewWebhookManager creates a new webhook manager
func NewWebhookManager() *WebhookManager <span class="cov10" title="14">{
        return &amp;WebhookManager{
                webhooks: make(map[string]*Webhook),
        }
}</span>

// Webhook represents a repository webhook
type Webhook struct {
        ID          string   `json:"id"`
        URL         string   `json:"url"`
        Events      []string `json:"events"`
        Secret      string   `json:"secret"`
        ContentType string   `json:"content_type"`
}

// WebhookPayload represents the payload sent to webhooks
type WebhookPayload struct {
        Event      string      `json:"event"`
        Repository string      `json:"repository"`
        Timestamp  time.Time   `json:"timestamp"`
        Data       interface{} `json:"data"`
}

// Register adds a new webhook
func (wm *WebhookManager) Register(url string, events []string, secret string) (*Webhook, error) <span class="cov10" title="14">{
        webhook := &amp;Webhook{
                ID:          uuid.New().String(),
                URL:         url,
                Events:      events,
                Secret:      secret,
                ContentType: "application/json",
        }

        wm.webhooks[webhook.ID] = webhook
        return webhook, nil
}</span>

// Unregister removes a webhook
func (wm *WebhookManager) Unregister(id string) error <span class="cov4" title="3">{
        delete(wm.webhooks, id)
        return nil
}</span>

// List returns all webhooks
func (wm *WebhookManager) List() []*Webhook <span class="cov7" title="6">{
        hooks := make([]*Webhook, 0, len(wm.webhooks))
        for _, hook := range wm.webhooks </span><span class="cov6" title="5">{
                hooks = append(hooks, hook)
        }</span>
        <span class="cov7" title="6">return hooks</span>
}

// Get returns a specific webhook
func (wm *WebhookManager) Get(id string) (*Webhook, error) <span class="cov4" title="3">{
        hook, ok := wm.webhooks[id]
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("webhook not found: %s", id)
        }</span>
        <span class="cov3" title="2">return hook, nil</span>
}

// Trigger sends an event to all registered webhooks
func (wm *WebhookManager) Trigger(event string, repoName string, data interface{}) <span class="cov5" title="4">{
        payload := WebhookPayload{
                Event:      event,
                Repository: repoName,
                Timestamp:  time.Now(),
                Data:       data,
        }

        for _, webhook := range wm.webhooks </span><span class="cov7" title="6">{
                // Check if webhook is subscribed to this event
                subscribed := false
                for _, e := range webhook.Events </span><span class="cov7" title="6">{
                        if e == event || e == "*" </span><span class="cov6" title="5">{
                                subscribed = true
                                break</span>
                        }
                }

                <span class="cov7" title="6">if subscribed </span><span class="cov6" title="5">{
                        // Send webhook asynchronously
                        go wm.sendWebhook(webhook, payload)
                }</span>
        }
}

// sendWebhook sends a webhook request
func (wm *WebhookManager) sendWebhook(webhook *Webhook, payload WebhookPayload) <span class="cov6" title="5">{
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                // Log error
                return
        }</span>

        <span class="cov6" title="5">req, err := http.NewRequest("POST", webhook.URL, bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                // Log error
                return
        }</span>

        <span class="cov6" title="5">req.Header.Set("Content-Type", webhook.ContentType)
        req.Header.Set("X-Govc-Event", payload.Event)
        req.Header.Set("X-Govc-Delivery", uuid.New().String())

        // Add signature if secret is set
        if webhook.Secret != "" </span><span class="cov1" title="1">{
                signature := wm.calculateSignature(webhook.Secret, body)
                req.Header.Set("X-Govc-Signature", signature)
        }</span>

        <span class="cov6" title="5">client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // Log error
                return
        }</span>
        <span class="cov6" title="5">defer resp.Body.Close()</span>

        // Log response status
}

// calculateSignature calculates HMAC-SHA256 signature
func (wm *WebhookManager) calculateSignature(secret string, body []byte) string <span class="cov6" title="5">{
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(body)
        return "sha256=" + hex.EncodeToString(mac.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        "fmt"
        "path/filepath"
        "sort"
        "sync"

        "github.com/Caia-Tech/govc/pkg/object"
)

// CleanWorkspace manages the mutable working directory state
// Separated from repository to maintain clean architecture
type CleanWorkspace struct {
        mu      sync.RWMutex
        repo    *CleanRepository
        working WorkingStorage
        staging *CleanStagingArea
        branch  string // Current branch
}

// NewCleanWorkspace creates a new workspace
func NewCleanWorkspace(repo *CleanRepository, working WorkingStorage) *CleanWorkspace <span class="cov5" title="4">{
        return &amp;CleanWorkspace{
                repo:    repo,
                working: working,
                staging: NewCleanStagingArea(),
                branch:  "main", // Default branch
        }
}</span>

// CleanStagingArea represents the Git index/staging area
type CleanStagingArea struct {
        mu      sync.RWMutex
        entries map[string]StagedEntry
        removed map[string]bool // Track removed files
}

// NewCleanStagingArea creates a new staging area
func NewCleanStagingArea() *CleanStagingArea <span class="cov8" title="12">{
        return &amp;CleanStagingArea{
                entries: make(map[string]StagedEntry),
                removed: make(map[string]bool),
        }
}</span>

// Add stages a file
func (w *CleanWorkspace) Add(path string) error <span class="cov6" title="6">{
        // Check if file exists in working directory
        content, err := w.working.Read(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read file %s: %w", path, err)
        }</span>

        // Create blob
        <span class="cov6" title="6">blob := object.NewBlob(content)
        hash, err := w.repo.objects.Put(blob)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot store blob: %w", err)
        }</span>

        // Add to staging
        <span class="cov6" title="6">w.staging.mu.Lock()
        w.staging.entries[path] = StagedEntry{
                Hash: hash,
                Mode: "100644", // Regular file
        }

        // Remove from removed list if it was there
        delete(w.staging.removed, path)
        w.staging.mu.Unlock()

        return nil</span>
}

// Remove stages a file removal
func (w *CleanWorkspace) Remove(path string) error <span class="cov0" title="0">{
        // Mark as removed
        w.staging.mu.Lock()
        w.staging.removed[path] = true

        // Remove from staged entries
        delete(w.staging.entries, path)
        w.staging.mu.Unlock()

        // Remove from working directory
        return w.working.Delete(path)
}</span>

// Status returns the current workspace status
func (w *CleanWorkspace) Status() (*Status, error) <span class="cov8" title="12">{
        w.mu.RLock()
        currentBranch := w.branch
        w.mu.RUnlock()

        status := &amp;Status{
                Branch:    currentBranch,
                Staged:    []string{},
                Modified:  []string{},
                Untracked: []string{},
        }

        // Get current commit tree
        head, err := w.repo.GetBranch(currentBranch)
        if err != nil </span><span class="cov0" title="0">{
                // New repository, no commits yet
                head = ""
        }</span>

        <span class="cov8" title="12">var currentTree *object.Tree
        if head != "" </span><span class="cov8" title="11">{
                commit, err := w.repo.GetCommit(head)
                if err == nil </span><span class="cov8" title="11">{
                        currentTree, _ = w.repo.GetTree(commit.TreeHash)
                }</span>
        }

        // Build map of files in current commit
        <span class="cov8" title="12">committedFiles := make(map[string]string)
        if currentTree != nil </span><span class="cov8" title="11">{
                for _, entry := range currentTree.Entries </span><span class="cov8" title="11">{
                        committedFiles[entry.Name] = entry.Hash
                }</span>
        }

        // Check staged files
        <span class="cov8" title="12">w.staging.mu.RLock()
        for path := range w.staging.entries </span><span class="cov6" title="5">{
                status.Staged = append(status.Staged, path)
        }</span>
        <span class="cov8" title="12">for path := range w.staging.removed </span><span class="cov0" title="0">{
                status.Staged = append(status.Staged, path+" (deleted)")
        }</span>
        <span class="cov8" title="12">w.staging.mu.RUnlock()

        // Check working directory files
        workingFiles, _ := w.working.List()
        for _, path := range workingFiles </span><span class="cov10" title="18">{
                // Skip if already staged
                w.staging.mu.RLock()
                _, isStaged := w.staging.entries[path]
                w.staging.mu.RUnlock()
                if isStaged </span><span class="cov4" title="3">{
                        continue</span>
                }

                // Check if file is tracked
                <span class="cov9" title="15">if commitHash, isTracked := committedFiles[path]; isTracked </span><span class="cov8" title="11">{
                        // File is tracked, check if modified
                        content, err := w.working.Read(path)
                        if err == nil </span><span class="cov8" title="11">{
                                blob := object.NewBlob(content)
                                if blob.Hash() != commitHash </span><span class="cov6" title="5">{
                                        status.Modified = append(status.Modified, path)
                                }</span>
                        }
                } else<span class="cov5" title="4"> {
                        // File is untracked
                        status.Untracked = append(status.Untracked, path)
                }</span>
        }

        // Sort for consistent output
        <span class="cov8" title="12">sort.Strings(status.Staged)
        sort.Strings(status.Modified)
        sort.Strings(status.Untracked)

        return status, nil</span>
}

// Checkout switches branches and updates working directory
func (w *CleanWorkspace) Checkout(branch string) error <span class="cov1" title="1">{
        // Get branch commit
        commitHash, err := w.repo.GetBranch(branch)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("branch not found: %s", branch)
        }</span>

        // Get commit
        <span class="cov1" title="1">commit, err := w.repo.GetCommit(commitHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get tree
        <span class="cov1" title="1">tree, err := w.repo.GetTree(commit.TreeHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clear working directory
        <span class="cov1" title="1">if err := w.working.Clear(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Restore files from tree
        <span class="cov1" title="1">for _, entry := range tree.Entries </span><span class="cov1" title="1">{
                blob, err := w.repo.GetBlob(entry.Hash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">if err := w.working.Write(entry.Name, blob.Content); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Update current branch and staging area
        <span class="cov1" title="1">w.mu.Lock()
        w.branch = branch
        w.staging = NewCleanStagingArea()
        w.mu.Unlock()

        return nil</span>
}

// Reset resets staging area
func (w *CleanWorkspace) Reset() <span class="cov7" title="7">{
        w.mu.Lock()
        w.staging = NewCleanStagingArea()
        w.mu.Unlock()
}</span>

// GetStagingArea returns the current staging area
func (w *CleanWorkspace) GetStagingArea() *CleanStagingArea <span class="cov9" title="14">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return w.staging
}</span>

// Status represents the workspace status
type Status struct {
        Branch    string
        Staged    []string
        Modified  []string
        Untracked []string
}

// Clean checks if working directory is clean
func (s *Status) Clean() bool <span class="cov7" title="7">{
        return len(s.Staged) == 0 &amp;&amp; len(s.Modified) == 0 &amp;&amp; len(s.Untracked) == 0
}</span>

// ReadFile reads a file from working directory
func (w *CleanWorkspace) ReadFile(path string) ([]byte, error) <span class="cov7" title="9">{
        return w.working.Read(path)
}</span>

// WriteFile writes a file to working directory
func (w *CleanWorkspace) WriteFile(path string, content []byte) error <span class="cov9" title="17">{
        // Ensure directory exists for file-based storage
        dir := filepath.Dir(path)
        if dir != "." &amp;&amp; dir != "" </span>{<span class="cov0" title="0">
                // This is a simplified version - real implementation would handle this better
                // For memory storage, directories don't matter
        }</span>

        <span class="cov9" title="17">return w.working.Write(path, content)</span>
}

// ListFiles returns all files in working directory
func (w *CleanWorkspace) ListFiles() ([]string, error) <span class="cov0" title="0">{
        return w.working.List()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package object

import (
        "bytes"
        "compress/zlib"
        "crypto/sha1"
        "encoding/hex"
        "fmt"
        "io"
        "strconv"
        "strings"
        "time"
)

type Type string

const (
        TypeBlob   Type = "blob"
        TypeTree   Type = "tree"
        TypeCommit Type = "commit"
        TypeTag    Type = "tag"
)

type Object interface {
        Type() Type
        Size() int64
        Hash() string
        Serialize() ([]byte, error)
}

type Blob struct {
        Content []byte
}

func NewBlob(content []byte) *Blob <span class="cov5" title="3">{
        return &amp;Blob{Content: content}
}</span>

func (b *Blob) Type() Type <span class="cov8" title="6">{
        return TypeBlob
}</span>

func (b *Blob) Size() int64 <span class="cov8" title="6">{
        return int64(len(b.Content))
}</span>

func (b *Blob) Hash() string <span class="cov5" title="3">{
        data, _ := b.Serialize()
        return HashObject(data)
}</span>

func (b *Blob) Serialize() ([]byte, error) <span class="cov5" title="3">{
        header := fmt.Sprintf("%s %d\x00", b.Type(), b.Size())
        return append([]byte(header), b.Content...), nil
}</span>

type TreeEntry struct {
        Mode string
        Name string
        Hash string
}

type Tree struct {
        Entries []TreeEntry
}

func NewTree() *Tree <span class="cov5" title="3">{
        return &amp;Tree{
                Entries: make([]TreeEntry, 0),
        }
}</span>

func (t *Tree) AddEntry(mode, name, hash string) <span class="cov9" title="7">{
        t.Entries = append(t.Entries, TreeEntry{
                Mode: mode,
                Name: name,
                Hash: hash,
        })
}</span>

func (t *Tree) Type() Type <span class="cov7" title="4">{
        return TypeTree
}</span>

func (t *Tree) Size() int64 <span class="cov0" title="0">{
        content := t.serializeContent()
        return int64(len(content))
}</span>

func (t *Tree) Hash() string <span class="cov4" title="2">{
        data, _ := t.Serialize()
        return HashObject(data)
}</span>

func (t *Tree) serializeContent() []byte <span class="cov5" title="3">{
        var buf bytes.Buffer
        for _, entry := range t.Entries </span><span class="cov10" title="8">{
                fmt.Fprintf(&amp;buf, "%s %s\x00", entry.Mode, entry.Name)
                hash, _ := hex.DecodeString(entry.Hash)
                buf.Write(hash)
        }</span>
        <span class="cov5" title="3">return buf.Bytes()</span>
}

func (t *Tree) Serialize() ([]byte, error) <span class="cov5" title="3">{
        content := t.serializeContent()
        header := fmt.Sprintf("%s %d\x00", t.Type(), len(content))
        return append([]byte(header), content...), nil
}</span>

type Author struct {
        Name  string
        Email string
        Time  time.Time
}

func (a Author) String() string <span class="cov7" title="5">{
        timestamp := a.Time.Unix()
        tz := a.Time.Format("-0700")
        return fmt.Sprintf("%s &lt;%s&gt; %d %s", a.Name, a.Email, timestamp, tz)
}</span>

type Commit struct {
        TreeHash   string
        ParentHash string
        Author     Author
        Committer  Author
        Message    string
}

func NewCommit(treeHash string, author Author, message string) *Commit <span class="cov1" title="1">{
        return &amp;Commit{
                TreeHash:  treeHash,
                Author:    author,
                Committer: author,
                Message:   message,
        }
}</span>

func (c *Commit) SetParent(parentHash string) <span class="cov1" title="1">{
        c.ParentHash = parentHash
}</span>

func (c *Commit) Type() Type <span class="cov4" title="2">{
        return TypeCommit
}</span>

func (c *Commit) Size() int64 <span class="cov0" title="0">{
        content := c.serializeContent()
        return int64(len(content))
}</span>

func (c *Commit) Hash() string <span class="cov0" title="0">{
        data, _ := c.Serialize()
        return HashObject(data)
}</span>

func (c *Commit) serializeContent() []byte <span class="cov1" title="1">{
        var buf bytes.Buffer
        fmt.Fprintf(&amp;buf, "tree %s\n", c.TreeHash)
        if c.ParentHash != "" </span><span class="cov1" title="1">{
                fmt.Fprintf(&amp;buf, "parent %s\n", c.ParentHash)
        }</span>
        <span class="cov1" title="1">fmt.Fprintf(&amp;buf, "author %s\n", c.Author.String())
        fmt.Fprintf(&amp;buf, "committer %s\n", c.Committer.String())
        fmt.Fprintf(&amp;buf, "\n%s", c.Message)
        return buf.Bytes()</span>
}

func (c *Commit) Serialize() ([]byte, error) <span class="cov1" title="1">{
        content := c.serializeContent()
        header := fmt.Sprintf("%s %d\x00", c.Type(), len(content))
        return append([]byte(header), content...), nil
}</span>

type Tag struct {
        ObjectHash string
        ObjectType Type
        TagName    string
        Tagger     Author
        Message    string
}

func NewTag(objectHash string, objectType Type, tagName string, tagger Author, message string) *Tag <span class="cov1" title="1">{
        return &amp;Tag{
                ObjectHash: objectHash,
                ObjectType: objectType,
                TagName:    tagName,
                Tagger:     tagger,
                Message:    message,
        }
}</span>

func (t *Tag) Type() Type <span class="cov5" title="3">{
        return TypeTag
}</span>

func (t *Tag) Size() int64 <span class="cov0" title="0">{
        content := t.serializeContent()
        return int64(len(content))
}</span>

func (t *Tag) Hash() string <span class="cov4" title="2">{
        data, _ := t.Serialize()
        return HashObject(data)
}</span>

func (t *Tag) serializeContent() []byte <span class="cov4" title="2">{
        var buf bytes.Buffer
        fmt.Fprintf(&amp;buf, "object %s\n", t.ObjectHash)
        fmt.Fprintf(&amp;buf, "type %s\n", t.ObjectType)
        fmt.Fprintf(&amp;buf, "tag %s\n", t.TagName)
        fmt.Fprintf(&amp;buf, "tagger %s\n", t.Tagger.String())
        fmt.Fprintf(&amp;buf, "\n%s", t.Message)
        return buf.Bytes()
}</span>

func (t *Tag) Serialize() ([]byte, error) <span class="cov4" title="2">{
        content := t.serializeContent()
        header := fmt.Sprintf("%s %d\x00", t.Type(), len(content))
        return append([]byte(header), content...), nil
}</span>

func HashObject(data []byte) string <span class="cov9" title="7">{
        h := sha1.New()
        h.Write(data)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func Compress(data []byte) ([]byte, error) <span class="cov1" title="1">{
        var buf bytes.Buffer
        w := zlib.NewWriter(&amp;buf)
        if _, err := w.Write(data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return buf.Bytes(), nil</span>
}

func Decompress(data []byte) ([]byte, error) <span class="cov1" title="1">{
        r, err := zlib.NewReader(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer r.Close()
        return io.ReadAll(r)</span>
}

func ParseObject(data []byte) (Object, error) <span class="cov7" title="5">{
        nullIndex := bytes.IndexByte(data, 0)
        if nullIndex == -1 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid object format: no null byte")
        }</span>

        <span class="cov7" title="4">header := string(data[:nullIndex])
        parts := strings.Split(header, " ")
        if len(parts) != 2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid header format: %s", header)
        }</span>

        <span class="cov5" title="3">objType := Type(parts[0])
        size, err := strconv.ParseInt(parts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid size: %v", err)
        }</span>

        <span class="cov5" title="3">content := data[nullIndex+1:]
        if int64(len(content)) != size </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("content size mismatch: expected %d, got %d", size, len(content))
        }</span>

        <span class="cov4" title="2">switch objType </span>{
        case TypeBlob:<span class="cov1" title="1">
                return &amp;Blob{Content: content}, nil</span>
        case TypeTree:<span class="cov1" title="1">
                return parseTree(content)</span>
        case TypeCommit:<span class="cov0" title="0">
                return parseCommit(content)</span>
        case TypeTag:<span class="cov0" title="0">
                return parseTag(content)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown object type: %s", objType)</span>
        }
}

func parseTree(content []byte) (*Tree, error) <span class="cov1" title="1">{
        tree := NewTree()
        buf := bytes.NewBuffer(content)

        for buf.Len() &gt; 0 </span><span class="cov4" title="2">{
                modeAndName, err := buf.ReadBytes(0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading tree entry: %v", err)
                }</span>
                <span class="cov4" title="2">modeAndName = modeAndName[:len(modeAndName)-1]

                parts := strings.SplitN(string(modeAndName), " ", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid tree entry format")
                }</span>

                <span class="cov4" title="2">hash := make([]byte, 20)
                if _, err := buf.Read(hash); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading hash: %v", err)
                }</span>

                <span class="cov4" title="2">tree.AddEntry(parts[0], parts[1], hex.EncodeToString(hash))</span>
        }

        <span class="cov1" title="1">return tree, nil</span>
}

func parseCommit(content []byte) (*Commit, error) <span class="cov0" title="0">{
        lines := strings.Split(string(content), "\n")
        commit := &amp;Commit{}

        messageStart := 0
        for i, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        messageStart = i + 1
                        break</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, " ", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch parts[0] </span>{
                case "tree":<span class="cov0" title="0">
                        commit.TreeHash = parts[1]</span>
                case "parent":<span class="cov0" title="0">
                        commit.ParentHash = parts[1]</span>
                case "author":<span class="cov0" title="0">
                        author, err := parseAuthor(parts[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing author: %v", err)
                        }</span>
                        <span class="cov0" title="0">commit.Author = author</span>
                case "committer":<span class="cov0" title="0">
                        committer, err := parseAuthor(parts[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing committer: %v", err)
                        }</span>
                        <span class="cov0" title="0">commit.Committer = committer</span>
                }
        }

        <span class="cov0" title="0">if messageStart &lt; len(lines) </span><span class="cov0" title="0">{
                commit.Message = strings.Join(lines[messageStart:], "\n")
        }</span>

        <span class="cov0" title="0">return commit, nil</span>
}

func parseAuthor(authorStr string) (Author, error) <span class="cov0" title="0">{
        emailStart := strings.Index(authorStr, "&lt;")
        emailEnd := strings.Index(authorStr, "&gt;")
        if emailStart == -1 || emailEnd == -1 || emailStart &gt;= emailEnd </span><span class="cov0" title="0">{
                return Author{}, fmt.Errorf("invalid author format")
        }</span>

        <span class="cov0" title="0">name := strings.TrimSpace(authorStr[:emailStart])
        email := authorStr[emailStart+1 : emailEnd]

        timestampParts := strings.Fields(authorStr[emailEnd+1:])
        if len(timestampParts) &lt; 2 </span><span class="cov0" title="0">{
                return Author{}, fmt.Errorf("invalid timestamp format")
        }</span>

        <span class="cov0" title="0">timestamp, err := strconv.ParseInt(timestampParts[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return Author{}, fmt.Errorf("invalid timestamp: %v", err)
        }</span>

        <span class="cov0" title="0">return Author{
                Name:  name,
                Email: email,
                Time:  time.Unix(timestamp, 0),
        }, nil</span>
}

func parseTag(content []byte) (*Tag, error) <span class="cov0" title="0">{
        lines := strings.Split(string(content), "\n")
        tag := &amp;Tag{}

        messageStart := 0
        for i, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        messageStart = i + 1
                        break</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, " ", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">switch parts[0] </span>{
                case "object":<span class="cov0" title="0">
                        tag.ObjectHash = parts[1]</span>
                case "type":<span class="cov0" title="0">
                        tag.ObjectType = Type(parts[1])</span>
                case "tag":<span class="cov0" title="0">
                        tag.TagName = parts[1]</span>
                case "tagger":<span class="cov0" title="0">
                        tagger, err := parseAuthor(parts[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing tagger: %v", err)
                        }</span>
                        <span class="cov0" title="0">tag.Tagger = tagger</span>
                }
        }

        <span class="cov0" title="0">if messageStart &lt; len(lines) </span><span class="cov0" title="0">{
                tag.Message = strings.Join(lines[messageStart:], "\n")
        }</span>

        <span class="cov0" title="0">return tag, nil</span>
}

// Deserialize creates an object from serialized data
func Deserialize(data []byte) (Object, error) <span class="cov0" title="0">{
        return ParseObject(data)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package refs

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
)

type RefType string

const (
        RefTypeBranch RefType = "branch"
        RefTypeTag    RefType = "tag"
        RefTypeRemote RefType = "remote"
)

type Ref struct {
        Name string
        Hash string
        Type RefType
}

type RefStore interface {
        GetRef(name string) (string, error)
        SetRef(name string, hash string) error
        DeleteRef(name string) error
        ListRefs(prefix string) ([]Ref, error)
        GetHEAD() (string, error)
        SetHEAD(ref string) error
}

// MemoryRefStore keeps all references in memory.
// In traditional Git, each ref is a file. Here, refs are just map entries.
// This is why operations like creating branches or switching between them
// are instant - no file I/O, just pointer updates.
type MemoryRefStore struct {
        refs map[string]string
        head string
        mu   sync.RWMutex
}

func NewMemoryRefStore() *MemoryRefStore <span class="cov2" title="3">{
        return &amp;MemoryRefStore{
                refs: make(map[string]string),
                head: "refs/heads/main",
        }
}</span>

func (m *MemoryRefStore) GetRef(name string) (string, error) <span class="cov4" title="21">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        fullName := m.normalizeRefName(name)
        hash, exists := m.refs[fullName]
        if !exists </span><span class="cov3" title="9">{
                return "", fmt.Errorf("ref not found: %s", name)
        }</span>
        <span class="cov4" title="12">return hash, nil</span>
}

func (m *MemoryRefStore) SetRef(name string, hash string) error <span class="cov9" title="1021">{
        m.mu.Lock()
        defer m.mu.Unlock()

        fullName := m.normalizeRefName(name)
        m.refs[fullName] = hash
        return nil
}</span>

func (m *MemoryRefStore) DeleteRef(name string) error <span class="cov1" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        fullName := m.normalizeRefName(name)
        delete(m.refs, fullName)
        return nil
}</span>

func (m *MemoryRefStore) ListRefs(prefix string) ([]Ref, error) <span class="cov3" title="6">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        refs := make([]Ref, 0)
        for name, hash := range m.refs </span><span class="cov9" title="1017">{
                if prefix == "" || strings.HasPrefix(name, prefix) </span><span class="cov9" title="1011">{
                        refType := m.getRefType(name)
                        refs = append(refs, Ref{
                                Name: name,
                                Hash: hash,
                                Type: refType,
                        })
                }</span>
        }
        <span class="cov3" title="6">return refs, nil</span>
}

func (m *MemoryRefStore) GetHEAD() (string, error) <span class="cov2" title="4">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.head == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("HEAD not set")
        }</span>

        // Handle symbolic references (e.g., "ref: refs/heads/main")
        <span class="cov2" title="4">if strings.HasPrefix(m.head, "ref: ") </span><span class="cov1" title="1">{
                ref := strings.TrimPrefix(m.head, "ref: ")
                hash, exists := m.refs[ref]
                if !exists </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("HEAD points to non-existent ref: %s", ref)
                }</span>
                <span class="cov1" title="1">return hash, nil</span>
        }

        // Handle direct references that start with refs/
        <span class="cov2" title="3">if strings.HasPrefix(m.head, "refs/") </span><span class="cov1" title="1">{
                hash, exists := m.refs[m.head]
                if !exists </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("HEAD points to non-existent ref: %s", m.head)
                }</span>
                <span class="cov1" title="1">return hash, nil</span>
        }

        <span class="cov1" title="2">return m.head, nil</span>
}

func (m *MemoryRefStore) SetHEAD(ref string) error <span class="cov2" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.head = ref
        return nil
}</span>

func (m *MemoryRefStore) normalizeRefName(name string) string <span class="cov10" title="1044">{
        if strings.HasPrefix(name, "refs/") </span><span class="cov9" title="1042">{
                return name
        }</span>
        <span class="cov1" title="2">if strings.Contains(name, "/") </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov1" title="2">return "refs/heads/" + name</span>
}

func (m *MemoryRefStore) getRefType(name string) RefType <span class="cov9" title="1011">{
        if strings.HasPrefix(name, "refs/heads/") </span><span class="cov9" title="1007">{
                return RefTypeBranch
        }</span>
        <span class="cov2" title="4">if strings.HasPrefix(name, "refs/tags/") </span><span class="cov2" title="3">{
                return RefTypeTag
        }</span>
        <span class="cov1" title="1">if strings.HasPrefix(name, "refs/remotes/") </span><span class="cov1" title="1">{
                return RefTypeRemote
        }</span>
        <span class="cov0" title="0">return RefTypeBranch</span>
}

type FileRefStore struct {
        path string
        mu   sync.RWMutex
}

func NewFileRefStore(path string) *FileRefStore <span class="cov1" title="1">{
        return &amp;FileRefStore{
                path: path,
        }
}</span>

func (f *FileRefStore) GetRef(name string) (string, error) <span class="cov2" title="3">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        fullName := f.normalizeRefName(name)
        refPath := filepath.Join(f.path, fullName)

        data, err := os.ReadFile(refPath)
        if err != nil </span><span class="cov1" title="1">{
                packedRefs, err := f.readPackedRefs()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("ref not found: %s", name)
                }</span>
                <span class="cov1" title="1">hash, exists := packedRefs[fullName]
                if !exists </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("ref not found: %s", name)
                }</span>
                <span class="cov1" title="1">return hash, nil</span>
        }

        <span class="cov1" title="2">return strings.TrimSpace(string(data)), nil</span>
}

func (f *FileRefStore) SetRef(name string, hash string) error <span class="cov1" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        fullName := f.normalizeRefName(name)
        refPath := filepath.Join(f.path, fullName)
        dir := filepath.Dir(refPath)

        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ref directory: %v", err)
        }</span>

        <span class="cov1" title="1">return os.WriteFile(refPath, []byte(hash+"\n"), 0644)</span>
}

func (f *FileRefStore) DeleteRef(name string) error <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        fullName := f.normalizeRefName(name)
        refPath := filepath.Join(f.path, fullName)

        return os.Remove(refPath)
}</span>

func (f *FileRefStore) ListRefs(prefix string) ([]Ref, error) <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        refs := make([]Ref, 0)

        looseRefs, err := f.listLooseRefs(prefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">refs = append(refs, looseRefs...)

        packedRefs, err := f.readPackedRefs()
        if err == nil </span><span class="cov0" title="0">{
                for name, hash := range packedRefs </span><span class="cov0" title="0">{
                        if prefix == "" || strings.HasPrefix(name, prefix) </span><span class="cov0" title="0">{
                                refType := f.getRefType(name)
                                refs = append(refs, Ref{
                                        Name: name,
                                        Hash: hash,
                                        Type: refType,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return refs, nil</span>
}

func (f *FileRefStore) GetHEAD() (string, error) <span class="cov1" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        headPath := filepath.Join(f.path, "HEAD")
        data, err := os.ReadFile(headPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read HEAD: %v", err)
        }</span>

        <span class="cov1" title="1">content := strings.TrimSpace(string(data))
        if strings.HasPrefix(content, "ref: ") </span><span class="cov1" title="1">{
                ref := strings.TrimPrefix(content, "ref: ")
                return f.GetRef(ref)
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

func (f *FileRefStore) SetHEAD(ref string) error <span class="cov1" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        headPath := filepath.Join(f.path, "HEAD")
        content := ref
        if strings.HasPrefix(ref, "refs/") </span><span class="cov1" title="1">{
                content = "ref: " + ref
        }</span>
        <span class="cov1" title="1">return os.WriteFile(headPath, []byte(content+"\n"), 0644)</span>
}

func (f *FileRefStore) normalizeRefName(name string) string <span class="cov2" title="4">{
        if strings.HasPrefix(name, "refs/") </span><span class="cov2" title="4">{
                return name
        }</span>
        <span class="cov0" title="0">if strings.Contains(name, "/") </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return "refs/heads/" + name</span>
}

func (f *FileRefStore) getRefType(name string) RefType <span class="cov0" title="0">{
        if strings.HasPrefix(name, "refs/heads/") </span><span class="cov0" title="0">{
                return RefTypeBranch
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "refs/tags/") </span><span class="cov0" title="0">{
                return RefTypeTag
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "refs/remotes/") </span><span class="cov0" title="0">{
                return RefTypeRemote
        }</span>
        <span class="cov0" title="0">return RefTypeBranch</span>
}

func (f *FileRefStore) listLooseRefs(prefix string) ([]Ref, error) <span class="cov0" title="0">{
        refs := make([]Ref, 0)
        refsDir := filepath.Join(f.path, "refs")

        err := filepath.Walk(refsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil || info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(f.path, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if prefix != "" &amp;&amp; !strings.HasPrefix(relPath, prefix) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">hash, err := f.GetRef(relPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">refType := f.getRefType(relPath)
                refs = append(refs, Ref{
                        Name: relPath,
                        Hash: hash,
                        Type: refType,
                })

                return nil</span>
        })

        <span class="cov0" title="0">return refs, err</span>
}

func (f *FileRefStore) readPackedRefs() (map[string]string, error) <span class="cov1" title="1">{
        packedPath := filepath.Join(f.path, "packed-refs")
        data, err := os.ReadFile(packedPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">refs := make(map[string]string)
        lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov2" title="4">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov1" title="2">{
                        continue</span>
                }

                <span class="cov1" title="2">parts := strings.Fields(line)
                if len(parts) == 2 </span><span class="cov1" title="2">{
                        refs[parts[1]] = parts[0]
                }</span>
        }

        <span class="cov1" title="1">return refs, nil</span>
}

type RefManager struct {
        store RefStore
}

func NewRefManager(store RefStore) *RefManager <span class="cov1" title="2">{
        return &amp;RefManager{
                store: store,
        }
}</span>

func (r *RefManager) CreateBranch(name string, commitHash string) error <span class="cov9" title="1003">{
        return r.store.SetRef("refs/heads/"+name, commitHash)
}</span>

func (r *RefManager) DeleteBranch(name string) error <span class="cov1" title="1">{
        return r.store.DeleteRef("refs/heads/" + name)
}</span>

func (r *RefManager) ListBranches() ([]Ref, error) <span class="cov1" title="2">{
        return r.store.ListRefs("refs/heads/")
}</span>

func (r *RefManager) GetBranch(name string) (string, error) <span class="cov2" title="3">{
        return r.store.GetRef("refs/heads/" + name)
}</span>

func (r *RefManager) CreateTag(name string, objectHash string) error <span class="cov1" title="1">{
        return r.store.SetRef("refs/tags/"+name, objectHash)
}</span>

func (r *RefManager) DeleteTag(name string) error <span class="cov0" title="0">{
        return r.store.DeleteRef("refs/tags/" + name)
}</span>

func (r *RefManager) ListTags() ([]Ref, error) <span class="cov1" title="1">{
        return r.store.ListRefs("refs/tags/")
}</span>

func (r *RefManager) GetTag(name string) (string, error) <span class="cov1" title="1">{
        return r.store.GetRef("refs/tags/" + name)
}</span>

func (r *RefManager) GetHEAD() (string, error) <span class="cov1" title="2">{
        return r.store.GetHEAD()
}</span>

func (r *RefManager) SetHEAD(ref string) error <span class="cov0" title="0">{
        return r.store.SetHEAD(ref)
}</span>

func (r *RefManager) SetHEADToBranch(branchName string) error <span class="cov1" title="1">{
        return r.store.SetHEAD("ref: refs/heads/" + branchName)
}</span>

func (r *RefManager) SetHEADToCommit(commitHash string) error <span class="cov1" title="1">{
        return r.store.SetHEAD(commitHash)
}</span>

func (r *RefManager) GetCurrentBranch() (string, error) <span class="cov0" title="0">{
        // We need to get the raw HEAD value, not the resolved one
        // For MemoryRefStore, we need to access the head field directly
        if memStore, ok := r.store.(*MemoryRefStore); ok </span><span class="cov0" title="0">{
                memStore.mu.RLock()
                head := memStore.head
                memStore.mu.RUnlock()

                if strings.HasPrefix(head, "ref: refs/heads/") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(head, "ref: refs/heads/"), nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("HEAD is detached")</span>
        }

        // For FileRefStore, read HEAD file directly
        <span class="cov0" title="0">if fileStore, ok := r.store.(*FileRefStore); ok </span><span class="cov0" title="0">{
                fileStore.mu.RLock()
                defer fileStore.mu.RUnlock()

                headPath := filepath.Join(fileStore.path, "HEAD")
                data, err := os.ReadFile(headPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read HEAD: %v", err)
                }</span>

                <span class="cov0" title="0">content := strings.TrimSpace(string(data))
                if strings.HasPrefix(content, "ref: refs/heads/") </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(content, "ref: refs/heads/"), nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("HEAD is detached")</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("unknown ref store type")</span>
}

func (r *RefManager) UpdateRef(name string, newHash string, oldHash string) error <span class="cov1" title="2">{
        if oldHash != "" </span><span class="cov1" title="2">{
                currentHash, err := r.store.GetRef(name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="2">if currentHash != oldHash </span><span class="cov1" title="1">{
                        return fmt.Errorf("ref %s has changed", name)
                }</span>
        }
        <span class="cov1" title="1">return r.store.SetRef(name, newHash)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package storage

import (
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "sync/atomic"

        "github.com/Caia-Tech/govc/pkg/object"
)

// HybridObjectStore implements memory-first storage with disk backup
// Objects are kept in memory for speed but also persisted to disk
type HybridObjectStore struct {
        memory     *MemoryObjectStore
        diskPath   string
        maxMemory  int64
        usedMemory int64
        mu         sync.RWMutex
}

// NewHybridObjectStore creates a memory-first object store with disk backup
func NewHybridObjectStore(diskPath string, maxMemory int64) (*HybridObjectStore, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(filepath.Join(diskPath, "objects"), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, IOError("failed to create objects directory", err)
        }</span>

        <span class="cov0" title="0">return &amp;HybridObjectStore{
                memory:    NewMemoryObjectStore(),
                diskPath:  diskPath,
                maxMemory: maxMemory,
        }, nil</span>
}

func (s *HybridObjectStore) Get(hash string) (object.Object, error) <span class="cov0" title="0">{
        // Try memory first
        obj, err := s.memory.Get(hash)
        if err == nil </span><span class="cov0" title="0">{
                return obj, nil
        }</span>

        // If not in memory, try disk
        <span class="cov0" title="0">obj, err = s.loadFromDisk(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Load into memory for future access
        <span class="cov0" title="0">s.memory.Put(obj)
        atomic.AddInt64(&amp;s.usedMemory, s.estimateObjectSize(obj))

        return obj, nil</span>
}

func (s *HybridObjectStore) Put(obj object.Object) (string, error) <span class="cov0" title="0">{
        if obj == nil </span><span class="cov0" title="0">{
                return "", InvalidObjectError("cannot store nil object")
        }</span>

        <span class="cov0" title="0">hash := obj.Hash()

        // Always store in memory first
        _, err := s.memory.Put(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Update memory usage
        <span class="cov0" title="0">size := s.estimateObjectSize(obj)
        newUsage := atomic.AddInt64(&amp;s.usedMemory, size)

        // If over memory limit, evict some objects
        if newUsage &gt; s.maxMemory </span><span class="cov0" title="0">{
                s.evictLRU()
        }</span>

        // Also persist to disk
        <span class="cov0" title="0">if err := s.saveToDisk(hash, obj); err != nil </span>{<span class="cov0" title="0">
                // Log error but don't fail - memory storage succeeded
                // In a production system, you'd want proper logging here
        }</span>

        <span class="cov0" title="0">return hash, nil</span>
}

func (s *HybridObjectStore) Exists(hash string) bool <span class="cov0" title="0">{
        // Check memory first
        if s.memory.Exists(hash) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check disk
        <span class="cov0" title="0">objPath := filepath.Join(s.diskPath, "objects", hash[:2], hash[2:])
        _, err := os.Stat(objPath)
        return err == nil</span>
}

func (s *HybridObjectStore) List() ([]string, error) <span class="cov0" title="0">{
        // Start with memory objects
        memoryHashes, err := s.memory.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add disk objects
        <span class="cov0" title="0">hashSet := make(map[string]bool)
        for _, hash := range memoryHashes </span><span class="cov0" title="0">{
                hashSet[hash] = true
        }</span>

        // Walk disk objects directory
        <span class="cov0" title="0">objectsDir := filepath.Join(s.diskPath, "objects")
        err = filepath.Walk(objectsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        // Reconstruct hash from directory structure
                        rel, _ := filepath.Rel(objectsDir, path)
                        if len(rel) &gt;= 3 </span><span class="cov0" title="0">{
                                hash := filepath.Dir(rel) + filepath.Base(rel)
                                hashSet[hash] = true
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Return memory hashes if disk walk fails
                return memoryHashes, nil
        }</span>

        // Convert back to slice
        <span class="cov0" title="0">result := make([]string, 0, len(hashSet))
        for hash := range hashSet </span><span class="cov0" title="0">{
                result = append(result, hash)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (s *HybridObjectStore) Size() (int64, error) <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;s.usedMemory), nil
}</span>

func (s *HybridObjectStore) Close() error <span class="cov0" title="0">{
        s.memory.Close()
        return nil
}</span>

// Helper methods

func (s *HybridObjectStore) loadFromDisk(hash string) (object.Object, error) <span class="cov0" title="0">{
        objPath := filepath.Join(s.diskPath, "objects", hash[:2], hash[2:])

        data, err := os.ReadFile(objPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, NotFoundError(fmt.Sprintf("object %s not found", hash))
                }</span>
                <span class="cov0" title="0">return nil, IOError(fmt.Sprintf("failed to read object %s", hash), err)</span>
        }

        // Deserialize object based on type
        // This is a simplified implementation - in reality you'd need proper deserialization
        <span class="cov0" title="0">obj, err := object.Deserialize(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, InvalidObjectError(fmt.Sprintf("failed to deserialize object %s", hash))
        }</span>

        <span class="cov0" title="0">return obj, nil</span>
}

func (s *HybridObjectStore) saveToDisk(hash string, obj object.Object) error <span class="cov0" title="0">{
        objDir := filepath.Join(s.diskPath, "objects", hash[:2])
        if err := os.MkdirAll(objDir, 0755); err != nil </span><span class="cov0" title="0">{
                return IOError("failed to create object directory", err)
        }</span>

        <span class="cov0" title="0">objPath := filepath.Join(objDir, hash[2:])

        // Serialize object
        data, err := obj.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return IOError("failed to serialize object", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(objPath, data, 0644)</span>
}

func (s *HybridObjectStore) estimateObjectSize(obj object.Object) int64 <span class="cov0" title="0">{
        // Rough estimate - in production you'd want more accurate sizing
        data, err := obj.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return 1024 // fallback estimate
        }</span>
        <span class="cov0" title="0">return int64(len(data))</span>
}

func (s *HybridObjectStore) evictLRU() <span class="cov0" title="0">{
        // Simplified LRU eviction - remove half the objects
        // In production you'd want proper LRU tracking
        s.mu.Lock()
        defer s.mu.Unlock()

        hashes, _ := s.memory.List()
        evictCount := len(hashes) / 2

        for i := 0; i &lt; evictCount &amp;&amp; i &lt; len(hashes); i++ </span><span class="cov0" title="0">{
                hash := hashes[i]
                if obj, err := s.memory.Get(hash); err == nil </span><span class="cov0" title="0">{
                        size := s.estimateObjectSize(obj)
                        atomic.AddInt64(&amp;s.usedMemory, -size)
                }</span>

                // Remove from memory (but keep on disk)
                <span class="cov0" title="0">s.memory.objects[hash] = nil
                delete(s.memory.objects, hash)</span>
        }
}

// HybridStorageFactory creates hybrid storage instances
type HybridStorageFactory struct {
        basePath string
}

// NewHybridStorageFactory creates a new hybrid storage factory
func NewHybridStorageFactory(basePath string) *HybridStorageFactory <span class="cov0" title="0">{
        return &amp;HybridStorageFactory{basePath: basePath}
}</span>

func (f *HybridStorageFactory) CreateObjectStore(config ObjectStoreConfig) (ObjectStore, error) <span class="cov0" title="0">{
        if config.Type != "hybrid" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported object store type: %s", config.Type)
        }</span>

        <span class="cov0" title="0">path := config.Path
        if path == "" </span><span class="cov0" title="0">{
                path = filepath.Join(f.basePath, "objects")
        }</span>

        <span class="cov0" title="0">maxMemory := config.MaxMemory
        if maxMemory &lt;= 0 </span><span class="cov0" title="0">{
                maxMemory = 100 * 1024 * 1024 // 100MB default
        }</span>

        <span class="cov0" title="0">return NewHybridObjectStore(path, maxMemory)</span>
}

func (f *HybridStorageFactory) CreateRefStore(config RefStoreConfig) (RefStore, error) <span class="cov0" title="0">{
        // For now, refs are always in memory for speed
        // Could be extended to hybrid as well
        return NewMemoryRefStore(), nil
}</span>

func (f *HybridStorageFactory) CreateWorkingStorage(config WorkingStorageConfig) (WorkingStorage, error) <span class="cov0" title="0">{
        // Working storage is typically memory-based for performance
        return NewMemoryWorkingStorage(), nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package storage

import (
        "github.com/Caia-Tech/govc/pkg/object"
)

// ObjectStore handles immutable Git objects (commits, trees, blobs)
// This is the core of Git's content-addressable storage
type ObjectStore interface {
        // Get retrieves an object by its hash
        Get(hash string) (object.Object, error)

        // Put stores an object and returns its hash
        Put(obj object.Object) (string, error)

        // Exists checks if an object exists without retrieving it
        Exists(hash string) bool

        // List returns all object hashes (for debugging/maintenance)
        List() ([]string, error)

        // Size returns the storage size metrics
        Size() (int64, error)

        // Close releases any resources held by the store
        Close() error
}

// RefStore handles mutable references (branches, tags, HEAD)
// These are pointers to commits in the object store
type RefStore interface {
        // GetRef returns the hash that a reference points to
        GetRef(name string) (string, error)

        // UpdateRef updates a reference to point to a new hash
        UpdateRef(name string, hash string) error

        // DeleteRef removes a reference
        DeleteRef(name string) error

        // ListRefs returns all references with their target hashes
        ListRefs() (map[string]string, error)

        // GetHEAD returns what HEAD points to (branch name or commit hash)
        GetHEAD() (string, error)

        // SetHEAD updates HEAD to point to a branch or commit
        SetHEAD(target string) error

        // Close releases any resources held by the store
        Close() error
}

// WorkingStorage handles mutable working directory content
// This is separate from Git objects and can be cleared/restored
type WorkingStorage interface {
        // Read retrieves file content from the working directory
        Read(path string) ([]byte, error)

        // Write stores file content in the working directory
        Write(path string, data []byte) error

        // Delete removes a file from the working directory
        Delete(path string) error

        // List returns all files in the working directory
        List() ([]string, error)

        // Clear removes all files from the working directory
        Clear() error

        // Exists checks if a file exists
        Exists(path string) bool

        // Close releases any resources held by the storage
        Close() error
}

// StorageFactory creates storage instances
// This allows different storage backends (memory, disk, hybrid)
type StorageFactory interface {
        // CreateObjectStore creates an object store with the given configuration
        CreateObjectStore(config ObjectStoreConfig) (ObjectStore, error)

        // CreateRefStore creates a reference store with the given configuration
        CreateRefStore(config RefStoreConfig) (RefStore, error)

        // CreateWorkingStorage creates working storage with the given configuration
        CreateWorkingStorage(config WorkingStorageConfig) (WorkingStorage, error)
}

// Configuration types for different storage backends

type ObjectStoreConfig struct {
        Type      string                 // "memory", "disk", "hybrid"
        Path      string                 // For disk storage
        MaxMemory int64                  // For hybrid storage
        Options   map[string]interface{} // Backend-specific options
}

type RefStoreConfig struct {
        Type    string                 // "memory", "disk", "hybrid"
        Path    string                 // For disk storage
        Options map[string]interface{} // Backend-specific options
}

type WorkingStorageConfig struct {
        Type    string                 // "memory", "disk", "hybrid"
        Path    string                 // For disk storage
        Options map[string]interface{} // Backend-specific options
}

// Errors for storage operations
type Error struct {
        Type    string // "not_found", "invalid_object", "io_error", etc.
        Message string
        Cause   error
}

func (e *Error) Error() string <span class="cov7" title="6">{
        if e.Cause != nil </span><span class="cov3" title="2">{
                return e.Message + ": " + e.Cause.Error()
        }</span>
        <span class="cov5" title="4">return e.Message</span>
}

func (e *Error) Unwrap() error <span class="cov1" title="1">{
        return e.Cause
}</span>

// Common error constructors
func NotFoundError(message string) *Error <span class="cov9" title="12">{
        return &amp;Error{Type: "not_found", Message: message}
}</span>

func InvalidObjectError(message string) *Error <span class="cov10" title="13">{
        return &amp;Error{Type: "invalid_object", Message: message}
}</span>

func IOError(message string, cause error) *Error <span class="cov1" title="1">{
        return &amp;Error{Type: "io_error", Message: message, Cause: cause}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package storage

import (
        "fmt"
        "sort"
        "sync"

        "github.com/Caia-Tech/govc/pkg/object"
)

// MemoryObjectStore implements ObjectStore in memory
type MemoryObjectStore struct {
        objects map[string]object.Object
        mu      sync.RWMutex
}

// NewMemoryObjectStore creates a new in-memory object store
func NewMemoryObjectStore() *MemoryObjectStore <span class="cov5" title="6">{
        return &amp;MemoryObjectStore{
                objects: make(map[string]object.Object),
        }
}</span>

func (s *MemoryObjectStore) Get(hash string) (object.Object, error) <span class="cov5" title="7">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        obj, exists := s.objects[hash]
        if !exists </span><span class="cov3" title="3">{
                return nil, NotFoundError(fmt.Sprintf("object %s not found", hash))
        }</span>

        <span class="cov4" title="4">return obj, nil</span>
}

func (s *MemoryObjectStore) Put(obj object.Object) (string, error) <span class="cov8" title="17">{
        if obj == nil </span><span class="cov1" title="1">{
                return "", InvalidObjectError("cannot store nil object")
        }</span>

        <span class="cov8" title="16">hash := obj.Hash()
        if hash == "" </span><span class="cov1" title="1">{
                return "", InvalidObjectError("object has empty hash")
        }</span>

        <span class="cov7" title="15">s.mu.Lock()
        defer s.mu.Unlock()

        s.objects[hash] = obj
        return hash, nil</span>
}

func (s *MemoryObjectStore) Exists(hash string) bool <span class="cov2" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        _, exists := s.objects[hash]
        return exists
}</span>

func (s *MemoryObjectStore) List() ([]string, error) <span class="cov3" title="3">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        hashes := make([]string, 0, len(s.objects))
        for hash := range s.objects </span><span class="cov7" title="14">{
                hashes = append(hashes, hash)
        }</span>

        <span class="cov3" title="3">sort.Strings(hashes)
        return hashes, nil</span>
}

func (s *MemoryObjectStore) Size() (int64, error) <span class="cov2" title="2">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Rough size calculation - in a real implementation we'd track bytes
        return int64(len(s.objects)), nil
}</span>

func (s *MemoryObjectStore) Close() error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Clear the objects map to help with garbage collection
        s.objects = nil
        return nil
}</span>

// MemoryRefStore implements RefStore in memory
type MemoryRefStore struct {
        refs map[string]string // ref name -&gt; commit hash
        head string            // what HEAD points to
        mu   sync.RWMutex
}

// NewMemoryRefStore creates a new in-memory reference store
func NewMemoryRefStore() *MemoryRefStore <span class="cov5" title="5">{
        return &amp;MemoryRefStore{
                refs: make(map[string]string),
                head: "refs/heads/main", // Default to main branch
        }
}</span>

func (s *MemoryRefStore) GetRef(name string) (string, error) <span class="cov8" title="20">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        hash, exists := s.refs[name]
        if !exists </span><span class="cov4" title="4">{
                return "", NotFoundError(fmt.Sprintf("reference %s not found", name))
        }</span>

        <span class="cov8" title="16">return hash, nil</span>
}

func (s *MemoryRefStore) UpdateRef(name string, hash string) error <span class="cov10" title="34">{
        if name == "" </span><span class="cov2" title="2">{
                return InvalidObjectError("reference name cannot be empty")
        }</span>
        <span class="cov9" title="32">if hash == "" </span><span class="cov1" title="1">{
                return InvalidObjectError("hash cannot be empty")
        }</span>

        <span class="cov9" title="31">s.mu.Lock()
        defer s.mu.Unlock()

        s.refs[name] = hash
        return nil</span>
}

func (s *MemoryRefStore) DeleteRef(name string) error <span class="cov4" title="4">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Idempotent operation - deleting non-existent ref is not an error
        delete(s.refs, name)
        return nil
}</span>

func (s *MemoryRefStore) ListRefs() (map[string]string, error) <span class="cov3" title="3">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Return a copy to prevent external modification
        refs := make(map[string]string, len(s.refs))
        for name, hash := range s.refs </span><span class="cov8" title="19">{
                refs[name] = hash
        }</span>

        <span class="cov3" title="3">return refs, nil</span>
}

func (s *MemoryRefStore) GetHEAD() (string, error) <span class="cov4" title="4">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return s.head, nil
}</span>

func (s *MemoryRefStore) SetHEAD(target string) error <span class="cov4" title="4">{
        if target == "" </span><span class="cov2" title="2">{
                return InvalidObjectError("HEAD target cannot be empty")
        }</span>

        <span class="cov2" title="2">s.mu.Lock()
        defer s.mu.Unlock()

        s.head = target
        return nil</span>
}

func (s *MemoryRefStore) Close() error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.refs = nil
        return nil
}</span>

// MemoryWorkingStorage implements WorkingStorage in memory
type MemoryWorkingStorage struct {
        files map[string][]byte
        mu    sync.RWMutex
}

// NewMemoryWorkingStorage creates a new in-memory working storage
func NewMemoryWorkingStorage() *MemoryWorkingStorage <span class="cov3" title="3">{
        return &amp;MemoryWorkingStorage{
                files: make(map[string][]byte),
        }
}</span>

func (s *MemoryWorkingStorage) Read(path string) ([]byte, error) <span class="cov5" title="7">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        data, exists := s.files[path]
        if !exists </span><span class="cov3" title="3">{
                return nil, NotFoundError(fmt.Sprintf("file %s not found", path))
        }</span>

        // Return a copy to prevent external modification
        <span class="cov4" title="4">result := make([]byte, len(data))
        copy(result, data)
        return result, nil</span>
}

func (s *MemoryWorkingStorage) Write(path string, data []byte) error <span class="cov7" title="14">{
        if path == "" </span><span class="cov1" title="1">{
                return InvalidObjectError("file path cannot be empty")
        }</span>

        <span class="cov7" title="13">s.mu.Lock()
        defer s.mu.Unlock()

        // Store a copy to prevent external modification
        fileCopy := make([]byte, len(data))
        copy(fileCopy, data)
        s.files[path] = fileCopy

        return nil</span>
}

func (s *MemoryWorkingStorage) Delete(path string) error <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, exists := s.files[path]; !exists </span><span class="cov1" title="1">{
                return NotFoundError(fmt.Sprintf("file %s not found", path))
        }</span>

        <span class="cov2" title="2">delete(s.files, path)
        return nil</span>
}

func (s *MemoryWorkingStorage) List() ([]string, error) <span class="cov5" title="5">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        paths := make([]string, 0, len(s.files))
        for path := range s.files </span><span class="cov5" title="7">{
                paths = append(paths, path)
        }</span>

        <span class="cov5" title="5">sort.Strings(paths)
        return paths, nil</span>
}

func (s *MemoryWorkingStorage) Clear() error <span class="cov4" title="4">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Clear all files
        for path := range s.files </span><span class="cov7" title="11">{
                delete(s.files, path)
        }</span>

        <span class="cov4" title="4">return nil</span>
}

func (s *MemoryWorkingStorage) Exists(path string) bool <span class="cov5" title="5">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        _, exists := s.files[path]
        return exists
}</span>

func (s *MemoryWorkingStorage) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.files = nil
        return nil
}</span>

// MemoryStorageFactory creates memory-based storage instances
type MemoryStorageFactory struct{}

// NewMemoryStorageFactory creates a new memory storage factory
func NewMemoryStorageFactory() *MemoryStorageFactory <span class="cov1" title="1">{
        return &amp;MemoryStorageFactory{}
}</span>

func (f *MemoryStorageFactory) CreateObjectStore(config ObjectStoreConfig) (ObjectStore, error) <span class="cov2" title="2">{
        if config.Type != "memory" &amp;&amp; config.Type != "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("unsupported object store type: %s", config.Type)
        }</span>
        <span class="cov1" title="1">return NewMemoryObjectStore(), nil</span>
}

func (f *MemoryStorageFactory) CreateRefStore(config RefStoreConfig) (RefStore, error) <span class="cov1" title="1">{
        if config.Type != "memory" &amp;&amp; config.Type != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported ref store type: %s", config.Type)
        }</span>
        <span class="cov1" title="1">return NewMemoryRefStore(), nil</span>
}

func (f *MemoryStorageFactory) CreateWorkingStorage(config WorkingStorageConfig) (WorkingStorage, error) <span class="cov1" title="1">{
        if config.Type != "memory" &amp;&amp; config.Type != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported working storage type: %s", config.Type)
        }</span>
        <span class="cov1" title="1">return NewMemoryWorkingStorage(), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package storage

import (
        "strings"

        "github.com/Caia-Tech/govc/pkg/refs"
)

// RefManagerAdapter adapts the existing RefManager to implement storage.RefStore interface
// This provides backward compatibility while transitioning to the new architecture
type RefManagerAdapter struct {
        manager *refs.RefManager
}

// NewRefManagerAdapter creates a RefStore adapter for the existing RefManager
func NewRefManagerAdapter(manager *refs.RefManager) *RefManagerAdapter <span class="cov1" title="1">{
        return &amp;RefManagerAdapter{manager: manager}
}</span>

func (a *RefManagerAdapter) GetRef(name string) (string, error) <span class="cov4" title="2">{
        // Use RefManager methods for known ref types
        if strings.HasPrefix(name, "refs/heads/") </span><span class="cov4" title="2">{
                branchName := strings.TrimPrefix(name, "refs/heads/")
                return a.manager.GetBranch(branchName)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "refs/tags/") </span><span class="cov0" title="0">{
                tagName := strings.TrimPrefix(name, "refs/tags/")
                return a.manager.GetTag(tagName)
        }</span>
        // For HEAD or other special refs, try direct access
        <span class="cov0" title="0">if name == "HEAD" </span><span class="cov0" title="0">{
                return a.manager.GetHEAD()
        }</span>
        // For other refs, we can't get them without access to the underlying store
        <span class="cov0" title="0">return "", NotFoundError("ref not found: " + name)</span>
}

func (a *RefManagerAdapter) UpdateRef(name string, hash string) error <span class="cov10" title="5">{
        // Use the RefManager's UpdateRef method
        return a.manager.UpdateRef(name, hash, "")
}</span>

func (a *RefManagerAdapter) DeleteRef(name string) error <span class="cov1" title="1">{
        // Use RefManager methods for known ref types
        if strings.HasPrefix(name, "refs/heads/") </span><span class="cov1" title="1">{
                branchName := strings.TrimPrefix(name, "refs/heads/")
                return a.manager.DeleteBranch(branchName)
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(name, "refs/tags/") </span><span class="cov0" title="0">{
                tagName := strings.TrimPrefix(name, "refs/tags/")
                return a.manager.DeleteTag(tagName)
        }</span>
        // For other refs, we can't delete them without access to the underlying store
        <span class="cov0" title="0">return NotFoundError("ref not found: " + name)</span>
}

func (a *RefManagerAdapter) ListRefs() (map[string]string, error) <span class="cov1" title="1">{
        result := make(map[string]string)

        // List branches
        branches, err := a.manager.ListBranches()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, branch := range branches </span><span class="cov4" title="2">{
                result[branch.Name] = branch.Hash
        }</span>

        // List tags
        <span class="cov1" title="1">tags, err := a.manager.ListTags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">for _, tag := range tags </span><span class="cov1" title="1">{
                result[tag.Name] = tag.Hash
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func (a *RefManagerAdapter) GetHEAD() (string, error) <span class="cov4" title="2">{
        return a.manager.GetHEAD()
}</span>

func (a *RefManagerAdapter) SetHEAD(target string) error <span class="cov4" title="2">{
        return a.manager.SetHEAD(target)
}</span>

func (a *RefManagerAdapter) Close() error <span class="cov1" title="1">{
        // RefManager doesn't have a Close method, so nothing to do
        return nil
}</span>

// Helper method to access the underlying RefStore
func (a *RefManagerAdapter) getUnderlyingStore() refs.RefStore <span class="cov0" title="0">{
        // This requires access to the manager's store field
        // Since it's not exported, we'll need to add a getter method or use reflection
        // For now, return nil and rely on the RefManager methods
        return nil
}</span>

// NewRefStoreFromRefsStore creates a storage.RefStore from a refs.RefStore
func NewRefStoreFromRefsStore(refStore refs.RefStore) RefStore <span class="cov0" title="0">{
        manager := refs.NewRefManager(refStore)
        return NewRefManagerAdapter(manager)
}</span>

// NewMemoryRefStoreFromRefs creates a memory-only RefStore using the refs package
func NewMemoryRefStoreFromRefs() RefStore <span class="cov0" title="0">{
        memoryStore := refs.NewMemoryRefStore()
        manager := refs.NewRefManager(memoryStore)
        return NewRefManagerAdapter(manager)
}</span>

// NewFileRefStore creates a file-backed RefStore using the refs package
func NewFileRefStore(path string) RefStore <span class="cov0" title="0">{
        fileStore := refs.NewFileRefStore(path)
        manager := refs.NewRefManager(fileStore)
        return NewRefManagerAdapter(manager)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package storage

import (
        "github.com/Caia-Tech/govc/pkg/refs"
)

// RefsStoreAdapter adapts refs.RefStore to implement storage.RefStore interface
// This provides a more direct bridge between the two interfaces
type RefsStoreAdapter struct {
        store refs.RefStore
}

// NewRefsStoreAdapter creates a storage.RefStore adapter for refs.RefStore
func NewRefsStoreAdapter(store refs.RefStore) *RefsStoreAdapter <span class="cov1" title="1">{
        return &amp;RefsStoreAdapter{store: store}
}</span>

func (a *RefsStoreAdapter) GetRef(name string) (string, error) <span class="cov7" title="3">{
        return a.store.GetRef(name)
}</span>

func (a *RefsStoreAdapter) UpdateRef(name string, hash string) error <span class="cov10" title="5">{
        if name == "" </span><span class="cov1" title="1">{
                return InvalidObjectError("reference name cannot be empty")
        }</span>
        <span class="cov8" title="4">if hash == "" </span><span class="cov1" title="1">{
                return InvalidObjectError("hash cannot be empty")
        }</span>
        <span class="cov7" title="3">return a.store.SetRef(name, hash)</span>
}

func (a *RefsStoreAdapter) DeleteRef(name string) error <span class="cov4" title="2">{
        // Idempotent operation - deleting non-existent ref is not an error
        return a.store.DeleteRef(name)
}</span>

func (a *RefsStoreAdapter) ListRefs() (map[string]string, error) <span class="cov1" title="1">{
        // Get all refs by listing with empty prefix
        refsList, err := a.store.ListRefs("")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert []refs.Ref to map[string]string
        <span class="cov1" title="1">result := make(map[string]string)
        for _, ref := range refsList </span><span class="cov7" title="3">{
                result[ref.Name] = ref.Hash
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

func (a *RefsStoreAdapter) GetHEAD() (string, error) <span class="cov4" title="2">{
        // For MemoryRefStore, we need to emulate the storage interface behavior
        if _, ok := a.store.(*refs.MemoryRefStore); ok </span><span class="cov4" title="2">{
                // The refs store will resolve HEAD, but if the target doesn't exist, it will error
                // Let's try to get the resolved HEAD and catch any errors
                _, err := a.store.GetHEAD()
                if err != nil </span><span class="cov1" title="1">{
                        return "", err
                }</span>
                // If no error, return the symbolic reference
                // TODO: This is a limitation - we need access to the head field
                <span class="cov1" title="1">return "refs/heads/main", nil</span>
        }

        // For other stores, return the resolved value
        <span class="cov0" title="0">return a.store.GetHEAD()</span>
}

func (a *RefsStoreAdapter) SetHEAD(target string) error <span class="cov1" title="1">{
        return a.store.SetHEAD(target)
}</span>

func (a *RefsStoreAdapter) Close() error <span class="cov0" title="0">{
        // refs.RefStore doesn't have a Close method, so nothing to do
        return nil
}</span>

// Convenience constructors using the refs package stores

// NewMemoryRefStoreAdapter creates a memory-only RefStore using refs.MemoryRefStore
func NewMemoryRefStoreAdapter() RefStore <span class="cov1" title="1">{
        memoryStore := refs.NewMemoryRefStore()
        return NewRefsStoreAdapter(memoryStore)
}</span>

// NewFileRefStoreAdapter creates a file-backed RefStore using refs.FileRefStore
func NewFileRefStoreAdapter(path string) RefStore <span class="cov0" title="0">{
        fileStore := refs.NewFileRefStore(path)
        return NewRefsStoreAdapter(fileStore)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package storage

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"

        "github.com/Caia-Tech/govc/pkg/object"
)

type Backend interface {
        ReadObject(hash string) ([]byte, error)
        WriteObject(hash string, data []byte) error
        HasObject(hash string) bool
        ListObjects() ([]string, error)
}

// MemoryBackend stores all Git objects in memory.
// This is the foundation of govc's memory-first approach - no disk I/O
// means operations complete in microseconds instead of milliseconds.
// Creating 1000 branches? That's just creating 1000 pointers in a map.
type MemoryBackend struct {
        objects map[string][]byte
        mu      sync.RWMutex
}

func NewMemoryBackend() *MemoryBackend <span class="cov5" title="25">{
        return &amp;MemoryBackend{
                objects: make(map[string][]byte),
        }
}</span>

func (m *MemoryBackend) ReadObject(hash string) ([]byte, error) <span class="cov6" title="35">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        data, exists := m.objects[hash]
        if !exists </span><span class="cov4" title="8">{
                return nil, fmt.Errorf("object not found: %s", hash)
        }</span>
        <span class="cov5" title="27">return data, nil</span>
}

func (m *MemoryBackend) WriteObject(hash string, data []byte) error <span class="cov10" title="405">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.objects[hash] = data
        return nil
}</span>

func (m *MemoryBackend) HasObject(hash string) bool <span class="cov9" title="261">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        _, exists := m.objects[hash]
        return exists
}</span>

func (m *MemoryBackend) ListObjects() ([]string, error) <span class="cov4" title="9">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        hashes := make([]string, 0, len(m.objects))
        for hash := range m.objects </span><span class="cov6" title="45">{
                hashes = append(hashes, hash)
        }</span>
        <span class="cov4" title="9">return hashes, nil</span>
}

type FileBackend struct {
        path string
        mu   sync.RWMutex
}

func NewFileBackend(path string) *FileBackend <span class="cov2" title="2">{
        return &amp;FileBackend{
                path: path,
        }
}</span>

func (f *FileBackend) objectPath(hash string) string <span class="cov7" title="105">{
        if len(hash) &lt; 2 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="105">dir := hash[:2]
        file := hash[2:]
        return filepath.Join(f.path, "objects", dir, file)</span>
}

func (f *FileBackend) ReadObject(hash string) ([]byte, error) <span class="cov2" title="2">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        path := f.objectPath(hash)
        compressed, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object not found: %s", hash)
        }</span>

        <span class="cov2" title="2">return object.Decompress(compressed)</span>
}

func (f *FileBackend) WriteObject(hash string, data []byte) error <span class="cov7" title="102">{
        f.mu.Lock()
        defer f.mu.Unlock()

        path := f.objectPath(hash)
        dir := filepath.Dir(path)

        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %v", err)
        }</span>

        <span class="cov7" title="102">compressed, err := object.Compress(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress object: %v", err)
        }</span>

        <span class="cov7" title="102">return os.WriteFile(path, compressed, 0644)</span>
}

func (f *FileBackend) HasObject(hash string) bool <span class="cov1" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        path := f.objectPath(hash)
        _, err := os.Stat(path)
        return err == nil
}</span>

func (f *FileBackend) ListObjects() ([]string, error) <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        var hashes []string
        objectsDir := filepath.Join(f.path, "objects")

        dirs, err := os.ReadDir(objectsDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return hashes, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">for _, dir := range dirs </span><span class="cov0" title="0">{
                if !dir.IsDir() || len(dir.Name()) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">subDir := filepath.Join(objectsDir, dir.Name())
                files, err := os.ReadDir(subDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                        if !file.IsDir() </span><span class="cov0" title="0">{
                                hash := dir.Name() + file.Name()
                                hashes = append(hashes, hash)
                        }</span>
                }
        }

        <span class="cov0" title="0">return hashes, nil</span>
}

// Store provides a unified interface to Git objects.
// The key innovation: cache isn't just for performance, it's the primary
// storage layer. The backend is optional - you can run entirely in memory.
// This enables use cases like testing infrastructure changes without
// ever touching disk.
type Store struct {
        backend    Backend
        cache      *MemoryBackend // Memory-first: cache is primary, backend is optional
        memoryPool interface{}    // Memory pool for optimized allocations
}

func NewStore(backend Backend) *Store <span class="cov4" title="12">{
        return &amp;Store{
                backend: backend,
                cache:   NewMemoryBackend(),
        }
}</span>

func (s *Store) StoreObject(obj object.Object) (string, error) <span class="cov9" title="244">{
        data, err := obj.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="244">hash := object.HashObject(data)

        if s.cache.HasObject(hash) </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        <span class="cov9" title="244">if err := s.cache.WriteObject(hash, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov9" title="244">if err := s.backend.WriteObject(hash, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov9" title="244">return hash, nil</span>
}

func (s *Store) GetObject(hash string) (object.Object, error) <span class="cov5" title="25">{
        var data []byte
        var err error

        data, err = s.cache.ReadObject(hash)
        if err != nil </span><span class="cov3" title="4">{
                data, err = s.backend.ReadObject(hash)
                if err != nil </span><span class="cov2" title="3">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">_ = s.cache.WriteObject(hash, data)</span>
        }

        <span class="cov5" title="22">return object.ParseObject(data)</span>
}

func (s *Store) HasObject(hash string) bool <span class="cov3" title="4">{
        return s.cache.HasObject(hash) || s.backend.HasObject(hash)
}</span>

func (s *Store) ListObjects() ([]string, error) <span class="cov3" title="5">{
        return s.backend.ListObjects()
}</span>

func (s *Store) StoreBlob(content []byte) (string, error) <span class="cov3" title="7">{
        blob := object.NewBlob(content)
        return s.StoreObject(blob)
}</span>

func (s *Store) GetBlob(hash string) (*object.Blob, error) <span class="cov1" title="1">{
        obj, err := s.GetObject(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">blob, ok := obj.(*object.Blob)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a blob", hash)
        }</span>

        <span class="cov1" title="1">return blob, nil</span>
}

func (s *Store) StoreTree(tree *object.Tree) (string, error) <span class="cov1" title="1">{
        return s.StoreObject(tree)
}</span>

func (s *Store) GetTree(hash string) (*object.Tree, error) <span class="cov2" title="2">{
        obj, err := s.GetObject(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">tree, ok := obj.(*object.Tree)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("object %s is not a tree", hash)
        }</span>

        <span class="cov1" title="1">return tree, nil</span>
}

func (s *Store) StoreCommit(commit *object.Commit) (string, error) <span class="cov1" title="1">{
        return s.StoreObject(commit)
}</span>

func (s *Store) GetCommit(hash string) (*object.Commit, error) <span class="cov1" title="1">{
        obj, err := s.GetObject(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">commit, ok := obj.(*object.Commit)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a commit", hash)
        }</span>

        <span class="cov1" title="1">return commit, nil</span>
}

func (s *Store) StoreTag(tag *object.Tag) (string, error) <span class="cov0" title="0">{
        return s.StoreObject(tag)
}</span>

func (s *Store) GetTag(hash string) (*object.Tag, error) <span class="cov0" title="0">{
        obj, err := s.GetObject(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tag, ok := obj.(*object.Tag)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("object %s is not a tag", hash)
        }</span>

        <span class="cov0" title="0">return tag, nil</span>
}

type PackFile struct {
        Version    uint32
        NumObjects uint32
        Objects    []PackedObject
}

type PackedObject struct {
        Type   object.Type
        Size   uint64
        Offset uint64
        Data   []byte
}

func (s *Store) WritePack(w io.Writer, hashes []string) error <span class="cov0" title="0">{
        pack := &amp;PackFile{
                Version:    2,
                NumObjects: uint32(len(hashes)),
                Objects:    make([]PackedObject, 0, len(hashes)),
        }

        for _, hash := range hashes </span><span class="cov0" title="0">{
                obj, err := s.GetObject(hash)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">data, err := obj.Serialize()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">packed := PackedObject{
                        Type: obj.Type(),
                        Size: uint64(obj.Size()),
                        Data: data,
                }
                pack.Objects = append(pack.Objects, packed)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) ReadPack(r io.Reader) error <span class="cov0" title="0">{
        return nil
}</span>

// SetMemoryPool sets the memory pool for optimized allocations
func (s *Store) SetMemoryPool(pool interface{}) <span class="cov0" title="0">{
        s.memoryPool = pool
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "github.com/Caia-Tech/govc/pkg/object"
)

// StoreAdapter adapts the existing Store to implement ObjectStore interface
// This provides backward compatibility while transitioning to the new architecture
type StoreAdapter struct {
        store *Store
}

// NewStoreAdapter creates an ObjectStore adapter for the existing Store
func NewStoreAdapter(store *Store) *StoreAdapter <span class="cov5" title="7">{
        return &amp;StoreAdapter{store: store}
}</span>

func (a *StoreAdapter) Get(hash string) (object.Object, error) <span class="cov8" title="18">{
        return a.store.GetObject(hash)
}</span>

func (a *StoreAdapter) Put(obj object.Object) (string, error) <span class="cov10" title="37">{
        if obj == nil </span><span class="cov2" title="2">{
                return "", InvalidObjectError("cannot store nil object")
        }</span>
        <span class="cov9" title="35">return a.store.StoreObject(obj)</span>
}

func (a *StoreAdapter) Exists(hash string) bool <span class="cov4" title="4">{
        return a.store.HasObject(hash)
}</span>

func (a *StoreAdapter) List() ([]string, error) <span class="cov4" title="4">{
        return a.store.ListObjects()
}</span>

func (a *StoreAdapter) Size() (int64, error) <span class="cov3" title="3">{
        // Return number of objects in cache as a rough size estimate
        hashes, err := a.store.cache.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov3" title="3">return int64(len(hashes)), nil</span>
}

func (a *StoreAdapter) Close() error <span class="cov1" title="1">{
        // Store doesn't have a Close method, so nothing to do
        return nil
}</span>

// NewObjectStoreFromBackend creates an ObjectStore from a Backend
func NewObjectStoreFromBackend(backend Backend) ObjectStore <span class="cov0" title="0">{
        store := NewStore(backend)
        return NewStoreAdapter(store)
}</span>

// NewMemoryObjectStoreFromStore creates a memory-only ObjectStore
func NewMemoryObjectStoreFromStore() ObjectStore <span class="cov1" title="1">{
        backend := NewMemoryBackend()
        store := NewStore(backend)
        return NewStoreAdapter(store)
}</span>

// NewFileObjectStore creates a file-backed ObjectStore
func NewFileObjectStore(path string) ObjectStore <span class="cov0" title="0">{
        backend := NewFileBackend(path)
        store := NewStore(backend)
        return NewStoreAdapter(store)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
