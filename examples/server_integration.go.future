package main

import (
	"context"
	"fmt"
	"log"
	"time"

	govc "github.com/caiatech/govc"
)

func main() {
	// Example 1: Basic client usage
	basicClientExample()

	// Example 2: Authentication
	authenticationExample()

	// Example 3: Remote operations
	remoteOperationsExample()

	// Example 4: Real-time events
	eventStreamExample()

	// Example 5: Pool management
	poolExample()
}

func basicClientExample() {
	fmt.Println("=== Basic Client Example ===")

	// Create client
	client, err := govc.NewClient("http://localhost:8080", govc.ClientOptions{
		Timeout: 30 * time.Second,
	})
	if err != nil {
		log.Fatal("Failed to create client:", err)
	}

	// Create a repository
	repo, err := client.CreateRepo(context.Background(), "my-project", &govc.CreateRepoOptions{
		Description: "My awesome project",
		Private:     false,
	})
	if err != nil {
		log.Fatal("Failed to create repository:", err)
	}

	fmt.Printf("Created repository: %s\n", repo.ID)

	// Write a file
	content := []byte("# My Project\n\nBuilt with govc!")
	if err := repo.WriteFile(context.Background(), "README.md", content); err != nil {
		log.Fatal("Failed to write file:", err)
	}

	// Commit changes
	commit, err := repo.Commit(context.Background(), "Initial commit", &govc.CommitOptions{
		Author: "John Doe <john@example.com>",
	})
	if err != nil {
		log.Fatal("Failed to commit:", err)
	}

	fmt.Printf("Created commit: %s\n", commit.Hash)
	fmt.Println()
}

func authenticationExample() {
	fmt.Println("=== Authentication Example ===")

	// JWT authentication
	client, err := govc.NewClient("http://localhost:8080", govc.ClientOptions{
		AuthToken: "eyJhbGciOiJIUzI1NiIs...", // Your JWT token
	})
	if err != nil {
		log.Fatal("Failed to create client:", err)
	}

	// API key authentication
	clientWithAPIKey, err := govc.NewClient("http://localhost:8080", govc.ClientOptions{
		APIKey: "your-api-key-here",
	})
	if err != nil {
		log.Fatal("Failed to create client:", err)
	}

	// Login to get token
	authClient := govc.NewAuthClient("http://localhost:8080")
	token, err := authClient.Login(context.Background(), "username", "password")
	if err != nil {
		log.Fatal("Failed to login:", err)
	}

	fmt.Printf("Received auth token: %s...\n", token[:20])

	// Create authenticated client
	authenticatedClient, _ := govc.NewClient("http://localhost:8080", govc.ClientOptions{
		AuthToken: token,
	})

	// Check who we are
	user, err := authenticatedClient.GetCurrentUser(context.Background())
	if err != nil {
		log.Fatal("Failed to get user:", err)
	}

	fmt.Printf("Logged in as: %s (%s)\n", user.Name, user.Email)
	fmt.Println()
}

func remoteOperationsExample() {
	fmt.Println("=== Remote Operations Example ===")

	client, _ := govc.NewClient("http://localhost:8080", govc.ClientOptions{})

	// List repositories
	repos, err := client.ListRepos(context.Background())
	if err != nil {
		log.Fatal("Failed to list repos:", err)
	}

	fmt.Printf("Found %d repositories:\n", len(repos))
	for _, repo := range repos {
		fmt.Printf("  - %s: %s\n", repo.ID, repo.Description)
	}

	if len(repos) == 0 {
		// Create a test repo
		repo, _ := client.CreateRepo(context.Background(), "test-repo", nil)
		repos = append(repos, repo)
	}

	// Get specific repository
	repo, err := client.GetRepo(context.Background(), repos[0].ID)
	if err != nil {
		log.Fatal("Failed to get repo:", err)
	}

	// List branches
	branches, err := repo.ListBranches(context.Background())
	if err != nil {
		log.Fatal("Failed to list branches:", err)
	}

	fmt.Printf("\nBranches in %s:\n", repo.ID)
	for _, branch := range branches {
		fmt.Printf("  - %s\n", branch.Name)
	}

	// Get commit log
	commits, err := repo.Log(context.Background(), &govc.LogOptions{
		MaxCount: 5,
	})
	if err != nil {
		log.Fatal("Failed to get log:", err)
	}

	fmt.Printf("\nRecent commits:\n")
	for _, commit := range commits {
		fmt.Printf("  %s: %s\n", commit.Hash[:8], commit.Message)
	}

	// Search content
	results, err := repo.SearchContent(context.Background(), "TODO", nil)
	if err != nil {
		log.Fatal("Failed to search:", err)
	}

	fmt.Printf("\nSearch results for 'TODO':\n")
	for _, result := range results {
		fmt.Printf("  %s:%d: %s\n", result.File, result.Line, result.Content)
	}
	fmt.Println()
}

func eventStreamExample() {
	fmt.Println("=== Event Stream Example ===")

	client, _ := govc.NewClient("http://localhost:8080", govc.ClientOptions{})

	// Get repository
	repo, err := client.GetRepo(context.Background(), "my-project")
	if err != nil {
		// Create if doesn't exist
		repo, _ = client.CreateRepo(context.Background(), "my-project", nil)
	}

	// Subscribe to events
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	events, err := repo.Watch(ctx)
	if err != nil {
		log.Fatal("Failed to watch events:", err)
	}

	// Handle events in goroutine
	go func() {
		for event := range events {
			switch event.Type {
			case govc.EventCommit:
				fmt.Printf("New commit: %s - %s\n", event.Data["hash"], event.Data["message"])
			case govc.EventBranch:
				fmt.Printf("Branch event: %s on %s\n", event.Data["action"], event.Data["branch"])
			case govc.EventTag:
				fmt.Printf("Tag created: %s\n", event.Data["tag"])
			case govc.EventPush:
				fmt.Printf("Push event: %s pushed to %s\n", event.Data["user"], event.Data["branch"])
			}
		}
	}()

	// Simulate some events
	repo.WriteFile(context.Background(), "test.txt", []byte("test content"))
	repo.Commit(context.Background(), "Test commit", nil)
	repo.Branch(context.Background(), "feature-branch")
	repo.Tag(context.Background(), "v1.0.0", nil)

	// Let events process
	time.Sleep(2 * time.Second)
	cancel()
	fmt.Println()
}

func poolExample() {
	fmt.Println("=== Repository Pool Example ===")

	// Create a pool for managing multiple repositories
	pool := govc.NewRepositoryPool(govc.PoolOptions{
		MaxSize:        10,
		MaxIdleTime:    30 * time.Minute,
		CleanupInterval: 5 * time.Minute,
		ServerURL:      "http://localhost:8080",
	})

	// Start pool
	pool.Start()
	defer pool.Stop()

	// Get repository from pool
	repo, err := pool.Get(context.Background(), "project-1")
	if err != nil {
		log.Fatal("Failed to get repository:", err)
	}
	defer pool.Put("project-1") // Return to pool when done

	// Use the repository
	repo.WriteFile(context.Background(), "pooled.txt", []byte("From pool"))
	repo.Commit(context.Background(), "Pool commit", nil)

	// Get pool statistics
	stats := pool.GetStatistics()
	fmt.Printf("\nPool Statistics:\n")
	fmt.Printf("  Active connections: %d\n", stats.ActiveCount)
	fmt.Printf("  Idle connections: %d\n", stats.IdleCount)
	fmt.Printf("  Total created: %d\n", stats.TotalCreated)
	fmt.Printf("  Cache hits: %d\n", stats.CacheHits)
	fmt.Printf("  Cache misses: %d\n", stats.CacheMisses)
	fmt.Println()
}

func transactionClientExample() {
	fmt.Println("=== Client Transaction Example ===")

	client, _ := govc.NewClient("http://localhost:8080", govc.ClientOptions{})
	repo, _ := client.GetRepo(context.Background(), "my-project")

	// Start a transaction
	tx, err := repo.BeginTransaction(context.Background())
	if err != nil {
		log.Fatal("Failed to begin transaction:", err)
	}

	// Make multiple changes
	files := map[string]string{
		"src/main.go":    "package main\n\nfunc main() {}\n",
		"src/config.go":  "package main\n\n// Config\n",
		"go.mod":         "module myproject\n\ngo 1.21\n",
		"README.md":      "# My Project\n",
	}

	for path, content := range files {
		if err := tx.WriteFile(path, []byte(content)); err != nil {
			tx.Rollback()
			log.Fatal("Failed to write file:", err)
		}
	}

	// Commit the transaction
	if err := tx.Commit("Add project structure"); err != nil {
		log.Fatal("Failed to commit transaction:", err)
	}

	fmt.Println("Transaction completed successfully!")
}

func parallelRealityClientExample() {
	fmt.Println("=== Client Parallel Reality Example ===")

	client, _ := govc.NewClient("http://localhost:8080", govc.ClientOptions{})
	repo, _ := client.GetRepo(context.Background(), "my-project")

	// Create parallel realities
	pr1, err := repo.CreateParallelReality(context.Background(), "experiment-ui")
	if err != nil {
		log.Fatal("Failed to create parallel reality:", err)
	}

	pr2, err := repo.CreateParallelReality(context.Background(), "experiment-api")
	if err != nil {
		log.Fatal("Failed to create parallel reality:", err)
	}

	// Work in parallel realities
	go func() {
		pr1.WriteFile(context.Background(), "ui.js", []byte("// New UI code"))
		pr1.Commit(context.Background(), "Add new UI", nil)
	}()

	go func() {
		pr2.WriteFile(context.Background(), "api.go", []byte("// New API code"))
		pr2.Commit(context.Background(), "Add new API", nil)
	}()

	time.Sleep(1 * time.Second)

	// List parallel realities
	realities, _ := repo.ListParallelRealities(context.Background())
	fmt.Println("Active parallel realities:")
	for _, r := range realities {
		fmt.Printf("  - %s\n", r.Name)
	}

	// Merge successful experiment
	if err := repo.MergeParallelReality(context.Background(), "experiment-ui"); err != nil {
		log.Fatal("Failed to merge:", err)
	}

	fmt.Println("Successfully merged UI experiment!")
}