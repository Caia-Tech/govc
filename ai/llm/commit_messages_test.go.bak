package llm

import (
	"context"
	"strings"
	"testing"
	"time"
)

// Mock repository for testing commit message generation
type mockCommitRepository struct {
	status       *mockStatus
	stagedFiles  []string
	modifiedFiles []string
	commits      []*mockCommit
}

type mockStatus struct {
	Staged   []string
	Modified []string
	Deleted  []string
}

type mockCommit struct {
	hash    string
	message string
	author  mockAuthor
}

type mockAuthor struct {
	Name  string
	Email string
	Time  time.Time
}

func (m *mockCommitRepository) Status() (*mockStatus, error) {
	return m.status, nil
}

func (m *mockCommitRepository) Log(limit int) ([]*mockCommit, error) {
	if limit > len(m.commits) {
		limit = len(m.commits)
	}
	return m.commits[:limit], nil
}

func (m *mockCommitRepository) ReadFile(path string) ([]byte, error) {
	// Mock file content based on filename
	switch path {
	case "auth.go":
		return []byte("package auth\nfunc Login(user, pass string) bool {\n    return authenticate(user, pass)\n}"), nil
	case "main.go":
		return []byte("package main\nfunc main() {\n    fmt.Println(\"Hello World\")\n}"), nil
	case "README.md":
		return []byte("# Project\n\nThis is an authentication system."), nil
	default:
		return []byte("// Generic file content"), nil
	}
}

// Mock LLM provider for testing
type mockLLMProvider struct {
	responses map[string]string
}

func (m *mockLLMProvider) GenerateText(ctx context.Context, prompt string, options GenerationOptions) (string, error) {
	// Return different responses based on prompt content
	if strings.Contains(prompt, "conventional") {
		return "feat: add user authentication system", nil
	}
	if strings.Contains(prompt, "semantic") {
		return "Add authentication functionality for user login", nil
	}
	if strings.Contains(prompt, "multiple") {
		return "1. feat: implement user authentication\n2. add: user login system\n3. feature: authentication module", nil
	}
	
	// Default response
	return "Update code with improvements", nil
}

func (m *mockLLMProvider) GenerateStructuredOutput(ctx context.Context, prompt string, schema map[string]interface{}, options GenerationOptions) (string, error) {
	return `{"type": "feature", "description": "user authentication"}`, nil
}

func (m *mockLLMProvider) GetModelInfo() ModelInfo {
	return ModelInfo{
		Provider:  "mock",
		Model:     "mock-model",
		MaxTokens: 1000,
	}
}

func TestDefaultCommitMessageConfig(t *testing.T) {
	config := DefaultCommitMessageConfig()
	
	if config.Style != "conventional" {
		t.Errorf("Expected default style 'conventional', got %s", config.Style)
	}
	
	if config.Language != "en" {
		t.Errorf("Expected default language 'en', got %s", config.Language)
	}
	
	if config.MaxLength != 72 {
		t.Errorf("Expected default MaxLength 72, got %d", config.MaxLength)
	}
	
	if !config.IncludeContext {
		t.Error("Expected IncludeContext to be true by default")
	}
}

func TestNewCommitMessageGenerator(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	
	generator := NewCommitMessageGenerator(provider, config)
	
	if generator == nil {
		t.Fatal("Generator should not be nil")
	}
	
	if generator.provider != provider {
		t.Error("Provider not set correctly")
	}
	
	if generator.config.Style != config.Style {
		t.Error("Config not set correctly")
	}
}

func TestCommitMessageGenerator_GenerateCommitMessage(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	config.Style = "conventional"
	generator := NewCommitMessageGenerator(provider, config)
	
	// Create mock repository with changes
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged:   []string{"auth.go", "main.go"},
			Modified: []string{"README.md"},
		},
		commits: []*mockCommit{
			{
				hash:    "abc123",
				message: "Initial commit",
				author: mockAuthor{
					Name:  "Test User",
					Email: "test@example.com",
					Time:  time.Now().Add(-24 * time.Hour),
				},
			},
		},
	}
	
	ctx := context.Background()
	message, err := generator.GenerateCommitMessage(ctx, repo)
	if err != nil {
		t.Fatalf("Failed to generate commit message: %v", err)
	}
	
	if message == "" {
		t.Error("Generated message should not be empty")
	}
	
	// Should return conventional commit format
	if !strings.Contains(message, "feat:") {
		t.Error("Conventional commit should contain type prefix")
	}
}

func TestCommitMessageGenerator_GenerateMultipleOptions(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: []string{"auth.go"},
		},
	}
	
	ctx := context.Background()
	messages, err := generator.GenerateMultipleOptions(ctx, repo, 3)
	if err != nil {
		t.Fatalf("Failed to generate multiple options: %v", err)
	}
	
	if len(messages) != 3 {
		t.Errorf("Expected 3 messages, got %d", len(messages))
	}
	
	for i, message := range messages {
		if message == "" {
			t.Errorf("Message %d should not be empty", i)
		}
	}
}

func TestCommitMessageGenerator_DifferentStyles(t *testing.T) {
	provider := &mockLLMProvider{}
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: []string{"auth.go"},
		},
	}
	
	testCases := []struct {
		style    string
		expected string
	}{
		{"conventional", "feat:"},
		{"semantic", "Add"},
		{"custom", "Update"},
	}
	
	for _, tc := range testCases {
		t.Run(tc.style, func(t *testing.T) {
			config := DefaultCommitMessageConfig()
			config.Style = tc.style
			generator := NewCommitMessageGenerator(provider, config)
			
			ctx := context.Background()
			message, err := generator.GenerateCommitMessage(ctx, repo)
			if err != nil {
				t.Fatalf("Failed to generate commit message for style %s: %v", tc.style, err)
			}
			
			if !strings.Contains(message, tc.expected) {
				t.Errorf("Style %s should contain '%s', got: %s", tc.style, tc.expected, message)
			}
		})
	}
}

func TestCommitMessageGenerator_NoChanges(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	// Repository with no changes
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged:   []string{},
			Modified: []string{},
		},
	}
	
	ctx := context.Background()
	_, err := generator.GenerateCommitMessage(ctx, repo)
	if err == nil {
		t.Error("Expected error when no changes are present")
	}
}

func TestCommitMessageGenerator_BuildPrompt(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	config.Style = "conventional"
	config.Language = "en"
	config.MaxLength = 50
	generator := NewCommitMessageGenerator(provider, config)
	
	changes := []FileChange{
		{
			Path:       "auth.go",
			ChangeType: "added",
			Language:   "go",
			Summary:    "Added authentication functions",
		},
		{
			Path:       "main.go",
			ChangeType: "modified",
			Language:   "go",
			Summary:    "Updated main function",
		},
	}
	
	context := CommitContext{
		RecentCommits: []string{
			"Initial commit",
			"Add basic structure",
		},
		Branch: "feature/auth",
	}
	
	prompt := generator.buildPrompt(changes, context)
	
	if prompt == "" {
		t.Error("Prompt should not be empty")
	}
	
	// Should contain style information
	if !strings.Contains(prompt, "conventional") {
		t.Error("Prompt should mention conventional style")
	}
	
	// Should contain language information
	if !strings.Contains(prompt, "en") || !strings.Contains(prompt, "English") {
		t.Error("Prompt should mention English language")
	}
	
	// Should contain max length
	if !strings.Contains(prompt, "50") {
		t.Error("Prompt should mention max length")
	}
	
	// Should contain file changes
	if !strings.Contains(prompt, "auth.go") {
		t.Error("Prompt should mention changed files")
	}
}

func TestCommitMessageGenerator_AnalyzeChanges(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged:   []string{"auth.go", "main.go"},
			Modified: []string{"README.md"},
		},
	}
	
	changes, err := generator.analyzeChanges(repo)
	if err != nil {
		t.Fatalf("Failed to analyze changes: %v", err)
	}
	
	if len(changes) != 3 {
		t.Errorf("Expected 3 changes, got %d", len(changes))
	}
	
	// Check that changes have required fields
	for _, change := range changes {
		if change.Path == "" {
			t.Error("Change path should not be empty")
		}
		if change.ChangeType == "" {
			t.Error("Change type should not be empty")
		}
		if change.Language == "" {
			t.Error("Language should be detected")
		}
	}
}

func TestCommitMessageGenerator_DetectLanguage(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	testCases := []struct {
		filename string
		expected string
	}{
		{"main.go", "go"},
		{"script.js", "javascript"},
		{"app.py", "python"},
		{"style.css", "css"},
		{"index.html", "html"},
		{"README.md", "markdown"},
		{"config.json", "json"},
		{"data.sql", "sql"},
		{"unknown.xyz", "text"},
	}
	
	for _, tc := range testCases {
		result := generator.detectLanguage(tc.filename)
		if result != tc.expected {
			t.Errorf("File %s: expected language %s, got %s", tc.filename, tc.expected, result)
		}
	}
}

func TestCommitMessageGenerator_ValidateMessage(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	config.MaxLength = 50
	generator := NewCommitMessageGenerator(provider, config)
	
	testCases := []struct {
		message string
		valid   bool
		reason  string
	}{
		{"feat: add user authentication", true, "valid conventional commit"},
		{"", false, "empty message"},
		{strings.Repeat("a", 100), false, "too long"},
		{"fix: resolve login bug", true, "valid fix"},
		{"docs: update README", true, "valid docs"},
		{"WIP: work in progress", false, "contains WIP"},
		{"TODO: fix this later", false, "contains TODO"},
		{"feat: add feature\n\nWith detailed description", true, "multi-line is ok"},
	}
	
	for _, tc := range testCases {
		t.Run(tc.reason, func(t *testing.T) {
			valid, reason := generator.validateMessage(tc.message)
			if valid != tc.valid {
				t.Errorf("Message '%s': expected valid=%v, got valid=%v (reason: %s)", 
					tc.message, tc.valid, valid, reason)
			}
		})
	}
}

func TestCommitMessageGenerator_MaxLengthEnforcement(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	config.MaxLength = 20 // Very short for testing
	generator := NewCommitMessageGenerator(provider, config)
	
	longMessage := "This is a very long commit message that exceeds the limit"
	truncated := generator.enforceMaxLength(longMessage)
	
	if len(truncated) > config.MaxLength {
		t.Errorf("Truncated message still too long: %d > %d", len(truncated), config.MaxLength)
	}
	
	if !strings.HasSuffix(truncated, "...") {
		t.Error("Truncated message should end with '...'")
	}
}

func TestCommitMessageGenerator_ContextCancellation(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: []string{"test.go"},
		},
	}
	
	// Create cancelled context
	ctx, cancel := context.WithCancel(context.Background())
	cancel()
	
	_, err := generator.GenerateCommitMessage(ctx, repo)
	if err == nil {
		t.Error("Expected error for cancelled context")
	}
}

func TestCommitMessageGenerator_EmptyOptionsCount(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: []string{"test.go"},
		},
	}
	
	ctx := context.Background()
	
	// Test with 0 options
	_, err := generator.GenerateMultipleOptions(ctx, repo, 0)
	if err == nil {
		t.Error("Expected error for 0 options")
	}
	
	// Test with negative options
	_, err = generator.GenerateMultipleOptions(ctx, repo, -1)
	if err == nil {
		t.Error("Expected error for negative options")
	}
}

// Test edge cases
func TestCommitMessageGenerator_LargeNumberOfFiles(t *testing.T) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	// Create many staged files
	var stagedFiles []string
	for i := 0; i < 100; i++ {
		stagedFiles = append(stagedFiles, "file"+string(rune('0'+i%10))+".go")
	}
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: stagedFiles,
		},
	}
	
	ctx := context.Background()
	message, err := generator.GenerateCommitMessage(ctx, repo)
	if err != nil {
		t.Fatalf("Failed with many files: %v", err)
	}
	
	if message == "" {
		t.Error("Should generate message even with many files")
	}
}

// Benchmark tests
func BenchmarkCommitMessageGenerator_GenerateCommitMessage(b *testing.B) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged: []string{"auth.go", "main.go", "README.md"},
		},
		commits: []*mockCommit{
			{hash: "abc123", message: "Previous commit"},
		},
	}
	
	ctx := context.Background()
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := generator.GenerateCommitMessage(ctx, repo)
		if err != nil {
			b.Fatalf("Generation failed: %v", err)
		}
	}
}

func BenchmarkCommitMessageGenerator_AnalyzeChanges(b *testing.B) {
	provider := &mockLLMProvider{}
	config := DefaultCommitMessageConfig()
	generator := NewCommitMessageGenerator(provider, config)
	
	repo := &mockCommitRepository{
		status: &mockStatus{
			Staged:   []string{"file1.go", "file2.js", "file3.py"},
			Modified: []string{"file4.md", "file5.json"},
		},
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := generator.analyzeChanges(repo)
		if err != nil {
			b.Fatalf("Analysis failed: %v", err)
		}
	}
}